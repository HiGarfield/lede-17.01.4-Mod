From fd2d9a7a935ebc02b684ac039fcbadf49d463e9c Mon Sep 17 00:00:00 2001
From: HiGarfield <HiGarfield@126.com>
Date: Tue, 13 Sep 2022 21:18:33 +0800
Subject: [PATCH] rt2x00: various experimental fixes for MT7620

---
 .../net/wireless/ralink/rt2x00/rt2800lib.c    | 196 +++++++++++++++---
 drivers/net/wireless/ralink/rt2x00/rt2x00.h   |   6 +
 .../net/wireless/ralink/rt2x00/rt2x00soc.c    |  15 ++
 3 files changed, 190 insertions(+), 27 deletions(-)

diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
index f4e4373..e639cc5 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
@@ -149,6 +149,27 @@ static u8 rt2800_bbp_read(struct rt2x00_dev *rt2x00dev, const unsigned int word)
 	return value;
 }
 
+//serge: move here for use in test
+static void rt2800_bbp_glrt_write(struct rt2x00_dev *rt2x00dev,
+				  const u8 reg, const u8 value)
+{
+	rt2800_bbp_write(rt2x00dev, 195, reg);
+	rt2800_bbp_write(rt2x00dev, 196, value);
+}
+
+static void rt2800_bbp_dcoc_write(struct rt2x00_dev *rt2x00dev,
+				  const u8 reg, const u8 value)
+{
+	rt2800_bbp_write(rt2x00dev, 158, reg);
+	rt2800_bbp_write(rt2x00dev, 159, value);
+}
+
+static u8 rt2800_bbp_dcoc_read(struct rt2x00_dev *rt2x00dev, const u8 reg)
+{
+	rt2800_bbp_write(rt2x00dev, 158, reg);
+	return rt2800_bbp_read(rt2x00dev, 159);
+}
+
 static void rt2800_rfcsr_write(struct rt2x00_dev *rt2x00dev,
 			       const unsigned int word, const u8 value)
 {
@@ -190,6 +211,28 @@ static void rt2800_rfcsr_write(struct rt2x00_dev *rt2x00dev,
 	mutex_unlock(&rt2x00dev->csr_mutex);
 }
 
+void rt6352_enable_pa_pin(struct rt2x00_dev *rt2x00dev, int enable)
+{
+	if (!rt2x00dev->pinctrl)
+		return;
+
+	if (enable) {
+		if (!rt2x00dev->pins_default) {
+			rt2x00_warn(rt2x00dev, "cannot enable PA pin! no default pinctrl\n");
+			return;
+		}
+
+		pinctrl_select_state(rt2x00dev->pinctrl, rt2x00dev->pins_default);
+	} else {
+		if (!rt2x00dev->pins_pa_gpio) {
+			rt2x00_warn(rt2x00dev, "cannot disable PA pin! no pa_gpio pinctrl\n");
+			return;
+		}
+
+		pinctrl_select_state(rt2x00dev->pinctrl, rt2x00dev->pins_pa_gpio);
+	}
+}
+
 static void rt2800_rfcsr_write_bank(struct rt2x00_dev *rt2x00dev, const u8 bank,
 				    const unsigned int reg, const u8 value)
 {
@@ -3805,6 +3848,20 @@ static void rt2800_config_channel_rf7620(struct rt2x00_dev *rt2x00dev,
 		rfcsr |= tx_agc_fc;
 		rt2800_rfcsr_write_bank(rt2x00dev, 7, 59, rfcsr);
 	}
+
+	if (conf_is_ht40(conf)) {//serge:skipped this step (1)
+		rt2800_bbp_write(rt2x00dev, 195, 141);
+		rt2800_bbp_write(rt2x00dev, 196, 0x10);
+		rt2800_bbp_write(rt2x00dev, 195, 157);
+		rt2800_bbp_write(rt2x00dev, 196, 0x2f);
+		//rt2800_bbp_write(rt2x00dev, 105, 0x3C);
+	} else {
+		rt2800_bbp_write(rt2x00dev, 195, 141);
+		rt2800_bbp_write(rt2x00dev, 196, 0x1a);
+		rt2800_bbp_write(rt2x00dev, 195, 157);
+		rt2800_bbp_write(rt2x00dev, 196, 0x40);
+		//rt2800_bbp_write(rt2x00dev, 105, 0x1C);
+	}
 }
 
 static void rt2800_config_alc(struct rt2x00_dev *rt2x00dev,
@@ -4172,6 +4229,11 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
 			rt2800_bbp_write(rt2x00dev, 86, 0x46);
 		else
 			rt2800_bbp_write(rt2x00dev, 86, 0);
+	} else if (rt2x00_rt(rt2x00dev, RT6352)) {//serge: don't overwite bbp r86 (5)
+		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
+		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
+		rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
+		rt2800_bbp_write(rt2x00dev, 86, 0x38);
 	} else {
 		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
 		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
@@ -4377,7 +4439,8 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
 		reg = (rf->channel <= 14 ? 0x1c : 0x24) + 2*rt2x00dev->lna_gain;
 		rt2800_bbp_write_with_rx_chain(rt2x00dev, 66, reg);
 
-		rt2800_iq_calibrate(rt2x00dev, rf->channel);
+		if (!rt2x00_rt(rt2x00dev, RT6352))//serge: this function for rt5592 only, for rt6352 it switch off compensations (5)
+		    rt2800_iq_calibrate(rt2x00dev, rf->channel);
 	}
 
 	if (rt2x00_rt(rt2x00dev, RT6352)) {
@@ -4417,6 +4480,31 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
 			rt2800_register_write(rt2x00dev, TX1_RF_GAIN_ATTEN,
 					      0x6C6C6B6C);
 		}
+
+		if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {//serge: for support eLNA (7a)
+			rt2x00_warn(rt2x00dev, "Correct RF/BBP for eLNA!\n");
+			reg = rt2800_register_read(rt2x00dev, RF_CONTROL3);
+			reg |= 0x00000101;
+			rt2800_register_write(rt2x00dev, RF_CONTROL3, reg);
+
+			reg = rt2800_register_read(rt2x00dev, RF_BYPASS3);
+			reg |= 0x00000101;
+			rt2800_register_write(rt2x00dev, RF_BYPASS3, reg);
+
+			rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x66);
+			rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x20);
+			rt2800_rfcsr_write_chanreg(rt2x00dev, 18, 0x42);
+			rt2800_bbp_write(rt2x00dev, 75, 0x68);//serge: move bbp eLNA init here?
+			rt2800_bbp_write(rt2x00dev, 76, 0x4C);
+			rt2800_bbp_write(rt2x00dev, 79, 0x1C);
+			rt2800_bbp_write(rt2x00dev, 80, 0x0C);
+			rt2800_bbp_write(rt2x00dev, 82, 0xB6);
+			/* bank 0 RF reg 42 and glrt BBP reg 141
+			will be set in config channel function
+			in dependence of channel and HT20/HT40
+			so don't touch it
+			*/
+		}
 	}
 
 	bbp = rt2800_bbp_read(rt2x00dev, 4);
@@ -4457,6 +4545,9 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
 		rt2x00_set_field8(&bbp, BBP49_UPDATE_FLAG, 0);
 		rt2800_bbp_write(rt2x00dev, 49, bbp);
 	}
+//serge:just print results after config channel - don't forget to remove nahren (c) <- this is copyright, not ref to comments :)
+	bbp = rt2800_bbp_dcoc_read(rt2x00dev, 0x03);
+	pr_info("BBP tx/rx compensation control=0x%02x\n", bbp);
 }
 
 static int rt2800_get_gain_calibration_delta(struct rt2x00_dev *rt2x00dev)
@@ -5527,7 +5618,7 @@ void rt2800_vco_calibration(struct rt2x00_dev *rt2x00dev)
 	}
 	rt2800_register_write(rt2x00dev, TX_PIN_CFG, tx_pin);
 
-	if (rt2x00_rt(rt2x00dev, RT6352)) {
+	if (rt2x00_rt(rt2x00dev, RT6352)) {//serge:remark - move all this code to rfcsr_6352 init?
 		if (rt2x00dev->default_ant.rx_chain_num == 1) {
 			rt2800_bbp_write(rt2x00dev, 91, 0x07);
 			rt2800_bbp_write(rt2x00dev, 95, 0x1A);
@@ -5695,7 +5786,8 @@ static inline void rt2800_set_vgc(struct rt2x00_dev *rt2x00dev,
 	if (qual->vgc_level != vgc_level) {
 		if (rt2x00_rt(rt2x00dev, RT3572) ||
 		    rt2x00_rt(rt2x00dev, RT3593) ||
-		    rt2x00_rt(rt2x00dev, RT3883)) {
+		    rt2x00_rt(rt2x00dev, RT3883) ||
+		    rt2x00_rt(rt2x00dev, RT6352)) {//serge: rt6352 too (3)
 			rt2800_bbp_write_with_rx_chain(rt2x00dev, 66,
 						       vgc_level);
 		} else if (rt2x00_rt(rt2x00dev, RT5592)) {
@@ -5918,7 +6010,7 @@ static int rt2800_init_registers(struct rt2x00_dev *rt2x00dev)
 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000404);
 	} else if (rt2x00_rt(rt2x00dev, RT6352)) {
 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000401);
-		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x000C0000);
+		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x000C0001);//serge:was 0x000C0000 (2)
 		rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
 		rt2800_register_write(rt2x00dev, TX_ALC_VGA3, 0x00000000);
 		rt2800_register_write(rt2x00dev, TX0_BB_GAIN_ATTEN, 0x0);
@@ -6180,6 +6272,29 @@ static int rt2800_init_registers(struct rt2x00_dev *rt2x00dev)
 		reg = rt2800_register_read(rt2x00dev, US_CYC_CNT);
 		rt2x00_set_field32(&reg, US_CYC_CNT_CLOCK_CYCLE, 125);
 		rt2800_register_write(rt2x00dev, US_CYC_CNT, reg);
+	} else if (rt2x00_is_soc(rt2x00dev)) {//serge:which value correct? (4)
+		struct clk *clk = clk_get_sys("bus", NULL);
+		int rate;
+
+		if (IS_ERR(clk)) {
+			rt2x00_warn(rt2x00dev, "system bus clock undefined\n");
+			clk = clk_get_sys("cpu", NULL);
+
+			if (IS_ERR(clk))
+			    rate = 125;
+			else {
+			    rate = clk_get_rate(clk) / 3000000;
+			    clk_put(clk);
+			}
+		} else {
+			rate = clk_get_rate(clk) / 1000000;
+			clk_put(clk);
+		}
+
+		rt2x00_info(rt2x00dev, "set US_CYC=%dMHz\n", rate);
+		reg = rt2800_register_read(rt2x00dev, US_CYC_CNT);
+		rt2x00_set_field32(&reg, US_CYC_CNT_CLOCK_CYCLE, rate);
+		rt2800_register_write(rt2x00dev, US_CYC_CNT, reg);
 	}
 
 	reg = rt2800_register_read(rt2x00dev, HT_FBK_CFG0);
@@ -6967,25 +7082,7 @@ static void rt2800_init_bbp_5592(struct rt2x00_dev *rt2x00dev)
 		rt2800_bbp_write(rt2x00dev, 103, 0xc0);
 }
 
-static void rt2800_bbp_glrt_write(struct rt2x00_dev *rt2x00dev,
-				  const u8 reg, const u8 value)
-{
-	rt2800_bbp_write(rt2x00dev, 195, reg);
-	rt2800_bbp_write(rt2x00dev, 196, value);
-}
-
-static void rt2800_bbp_dcoc_write(struct rt2x00_dev *rt2x00dev,
-				  const u8 reg, const u8 value)
-{
-	rt2800_bbp_write(rt2x00dev, 158, reg);
-	rt2800_bbp_write(rt2x00dev, 159, value);
-}
-
-static u8 rt2800_bbp_dcoc_read(struct rt2x00_dev *rt2x00dev, const u8 reg)
-{
-	rt2800_bbp_write(rt2x00dev, 158, reg);
-	return rt2800_bbp_read(rt2x00dev, 159);
-}
+//serge: move these function upper
 
 static void rt2800_init_bbp_6352(struct rt2x00_dev *rt2x00dev)
 {
@@ -8624,7 +8721,7 @@ void rt2800_r_calibration(struct rt2x00_dev *rt2x00dev)
 		r_cal_code = (u8)rcalcode;
 
 	rt2800_rfcsr_write_bank(rt2x00dev, 0, 7, r_cal_code);
-
+	pr_info("RF bank 0 reg 5=0x%02x\n", r_cal_code);//serge: just for info to compare with vendor driver
 	rt2800_bbp_write(rt2x00dev, 22, 0x0);
 
 	bytevalue = rt2800_bbp_read(rt2x00dev, 21);
@@ -8683,7 +8780,7 @@ void rt2800_rxdcoc_calibration(struct rt2x00_dev *rt2x00dev)
 			break;
 	}
 
-	saverfb5r4 = rt2800_rfcsr_read_bank(rt2x00dev, 5, 0);
+	saverfb5r4 = rt2800_rfcsr_read_bank(rt2x00dev, 5, 4);//serge: was 0 - typo? (6)
 	saverfb7r4 = rt2800_rfcsr_read_bank(rt2x00dev, 7, 4);
 	saverfb5r4 = saverfb5r4 & (~0x40);
 	saverfb7r4 = saverfb7r4 & (~0x40);
@@ -9014,13 +9111,15 @@ void rt2800_rxiq_calibration(struct rt2x00_dev *rt2x00dev) {
 				rt2x00_info(rt2x00dev, "RXIQ G_imb=%d, Ph_rx=%d\n", g_imb, ph_rx);
 
 				if ((ph_rx > 20) || (ph_rx < -20)) {
+					rt2x00_warn(rt2x00dev, "RXIQ calibration FAIL(ph_rx=%d out of [-20..20]", ph_rx);//serge:just to see value
 					ph_rx = 0;
-					rt2x00_warn(rt2x00dev, "RXIQ calibration FAIL");
+					//rt2x00_warn(rt2x00dev, "RXIQ calibration FAIL");
 				}
 
 				if ((g_imb > 12) || (g_imb < -12)) {
+					rt2x00_warn(rt2x00dev, "RXIQ calibration FAIL(g_imb=%d out of (-12..12]", g_imb);//serge:just to see the reason
 					g_imb = 0;
-					rt2x00_warn(rt2x00dev, "RXIQ calibration FAIL");
+					//rt2x00_warn(rt2x00dev, "RXIQ calibration FAIL");
 				}
 			}
 		else {
@@ -9031,11 +9130,21 @@ void rt2800_rxiq_calibration(struct rt2x00_dev *rt2x00dev) {
 		}
 
 		if (ch_idx == 0) {
+			//serge: just to see values
+			pr_info("RXIQ RX0 g_imb (0x37, %2x) ph_rx (0x35, %2x)\n",
+			    g_imb & 0x3f,
+			    ph_rx & 0x3f
+			);
 			rt2800_bbp_write(rt2x00dev, 158, 0x37);
 			rt2800_bbp_write(rt2x00dev, 159, g_imb & 0x3f);
 			rt2800_bbp_write(rt2x00dev, 158, 0x35);
 			rt2800_bbp_write(rt2x00dev, 159, ph_rx & 0x3f);
 		} else {
+			//serge: just to see values
+			pr_info("RXIQ RX1 g_imb (0x55, %2x) ph_rx (0x53, %2x)\n",
+			    g_imb & 0x3f,
+			    ph_rx & 0x3f
+			);
 			rt2800_bbp_write(rt2x00dev, 158, 0x55);
 			rt2800_bbp_write(rt2x00dev, 159, g_imb & 0x3f);
 			rt2800_bbp_write(rt2x00dev, 158, 0x53);
@@ -9748,6 +9857,15 @@ void rt2800_loft_iq_calibration(struct rt2x00_dev *rt2x00dev)
 	}
 
 	for (rf_alc_idx = 0; rf_alc_idx < 3; rf_alc_idx++) {
+		//serge: just to see values
+		pr_info("LOFT ALC (0xb0, %2x) I0 (0xb1, %2x) Q0 (0xb2, %2x) I1 (0xb8, %2x) Q1 (0xb9, %2x)\n",
+		    rf_alc_idx,
+		    loft_dc_search_result[CHAIN_0][rf_alc_idx][0x00] & 0x3F,
+		    loft_dc_search_result[CHAIN_0][rf_alc_idx][0x01] & 0x3F,
+		    loft_dc_search_result[CHAIN_1][rf_alc_idx][0x00] & 0x3F,
+		    loft_dc_search_result[CHAIN_1][rf_alc_idx][0x01] & 0x3F
+		);
+
 		for (idx = 0; idx < 4; idx++) {
 			rt2800_bbp_write(rt2x00dev, 158, 0xB0);
 			bbp = (idx<<2) + rf_alc_idx;
@@ -10655,6 +10773,7 @@ static void rt2800_init_rfcsr_6352(struct rt2x00_dev *rt2x00dev)
 	rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x00);
 	rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x7C);
 
+	rt6352_enable_pa_pin(rt2x00dev, 0);//serge: vendor driver do it before calibration (7b)
 	rt2800_r_calibration(rt2x00dev);
 	rt2800_rf_self_txdc_cal(rt2x00dev);
 	rt2800_rxdcoc_calibration(rt2x00dev);
@@ -10662,6 +10781,29 @@ static void rt2800_init_rfcsr_6352(struct rt2x00_dev *rt2x00dev)
 	rt2800_bw_filter_calibration(rt2x00dev, false);
 	rt2800_loft_iq_calibration(rt2x00dev);
 	rt2800_rxiq_calibration(rt2x00dev);
+	rt6352_enable_pa_pin(rt2x00dev, 1);//serge: vendor driver do it after calibration (7b)
+	/* Vendor driver restore iLNA/iPA before
+	recalibration and set correct values after.
+	Openwrt driver init iLNA and iPA but restore only
+	ePA values after recalibration.
+	So set eLNA values only
+	*/
+	if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {//serge: rf regs never corrected for eLNA (7a)
+		rt2x00_info(rt2x00dev, "Correct RF/BBP for eLNA!\n");
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x66);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x20);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 18, 0x42);
+		rt2800_bbp_write(rt2x00dev, 75, 0x68);//serge: move bbp eLNA init here?
+		rt2800_bbp_write(rt2x00dev, 76, 0x4C);
+		rt2800_bbp_write(rt2x00dev, 79, 0x1C);
+		rt2800_bbp_write(rt2x00dev, 80, 0x0C);
+		rt2800_bbp_write(rt2x00dev, 82, 0xB6);
+		/* bank 0 RF reg 42 and glrt BBP reg 141
+		will be set in config channel function
+		in dependence of channel and HT20/HT40
+		so don't touch it
+		*/
+	}
 }
 
 static void rt2800_init_rfcsr(struct rt2x00_dev *rt2x00dev)
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00.h b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
index a5bcee0..ffbe1d5 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
@@ -40,6 +40,7 @@
 #include <linux/average.h>
 #include <linux/usb.h>
 #include <linux/clk.h>
+#include <linux/pinctrl/consumer.h>
 #include <linux/rt2x00_platform.h>
 
 #include <net/mac80211.h>
@@ -1047,6 +1048,11 @@ struct rt2x00_dev {
 
 	/* Clock for System On Chip devices. */
 	struct clk *clk;
+
+	/* pinctrl and states for System On Chip devices with PA/LNA. */
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pins_default;
+	struct pinctrl_state *pins_pa_gpio;
 };
 
 struct rt2x00_bar_list_entry {
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
index 2a94b1e..c7153e9 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
@@ -108,6 +108,21 @@ int rt2x00soc_probe(struct platform_device *pdev, const struct rt2x00_ops *ops)
 	if (retval)
 		goto exit_free_reg;
 
+	rt2x00dev->pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR(rt2x00dev->pinctrl)) {
+		rt2x00dev->pinctrl = NULL;
+		rt2x00dev->pins_default = NULL;
+		rt2x00dev->pins_pa_gpio = NULL;
+	} else {
+		rt2x00dev->pins_default = pinctrl_lookup_state(rt2x00dev->pinctrl, "default");
+		if (IS_ERR(rt2x00dev->pins_default))
+			rt2x00dev->pins_default = NULL;
+
+		rt2x00dev->pins_pa_gpio = pinctrl_lookup_state(rt2x00dev->pinctrl, "pa_gpio");
+		if (IS_ERR(rt2x00dev->pins_pa_gpio))
+			rt2x00dev->pins_pa_gpio = NULL;
+	}
+
 	return 0;
 
 exit_free_reg:
-- 
2.25.1

