From 4e2e8c0ce5dcd6795782df51bbea77e922f325c5 Mon Sep 17 00:00:00 2001
From: HiGarfield <HiGarfield@126.com>
Date: Thu, 27 Mar 2025 02:07:15 +0800
Subject: [PATCH] dns_stats: fix build error on old platforms

---
 src/dns_stats.c      | 10 ++++++++
 src/dns_stats.h      | 54 ++++++++++++++++++++++++++++++++++++++------
 src/include/atomic.h | 20 ++++++++++++----
 3 files changed, 73 insertions(+), 11 deletions(-)

--- a/src/dns_stats.c
+++ b/src/dns_stats.c
@@ -22,6 +22,8 @@
 
 struct dns_stats dns_stats;
 
+pthread_spinlock_t stats_lock;
+
 #define SAMPLE_PERIOD 5
 
 void dns_stats_avg_time_update_add(struct dns_stats_avg_time *avg_time, uint64_t time)
@@ -161,11 +163,19 @@ float dns_stats_server_stats_avg_time_ge
 int dns_stats_init(void)
 {
 	memset(&dns_stats, 0, sizeof(dns_stats));
+	if (pthread_spin_init(&stats_lock, PTHREAD_PROCESS_PRIVATE) != 0) {
+		perror("pthread_spin_init failed");
+		exit(EXIT_FAILURE);
+	}
 	return 0;
 }
 
 void dns_stats_exit(void)
 {
 	memset(&dns_stats, 0, sizeof(dns_stats));
+	if (pthread_spin_destroy(&stats_lock) != 0) {
+		perror("pthread_spin_destroy failed");
+		exit(EXIT_FAILURE);
+	}
 	return;
 }
\ No newline at end of file
--- a/src/dns_stats.h
+++ b/src/dns_stats.h
@@ -20,7 +20,10 @@
 #define SMART_DNS_STATS_H
 
 #include "atomic.h"
+#include <pthread.h>
 #include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -58,39 +61,76 @@ struct dns_server_stats {
 
 extern struct dns_stats dns_stats;
 
+extern pthread_spinlock_t stats_lock;
+
+static inline void acquire_stats_lock(void)
+{
+	if (pthread_spin_lock(&stats_lock) != 0) {
+		perror("pthread_spin_lock failed");
+		exit(EXIT_FAILURE);
+	}
+}
+
+static inline void release_stats_lock(void)
+{
+	if (pthread_spin_unlock(&stats_lock) != 0) {
+		perror("pthread_spin_unlock failed");
+		exit(EXIT_FAILURE);
+	}
+}
+
 static inline uint64_t stats_read(const uint64_t *s)
 {
-	return READ_ONCE((*s));
+	uint64_t val;
+	acquire_stats_lock();
+	val = READ_ONCE(*s);
+	release_stats_lock();
+	return val;
 }
 
 static inline uint64_t stats_read_and_set(uint64_t *s, uint64_t v)
 {
-	return __sync_lock_test_and_set(s, v);
+	uint64_t old_val;
+	acquire_stats_lock();
+	old_val = READ_ONCE(*s);
+	WRITE_ONCE(*s, v);
+	release_stats_lock();
+	return old_val;
 }
 
 static inline void stats_set(uint64_t *s, uint64_t v)
 {
-	*s = v;
+	acquire_stats_lock();
+	WRITE_ONCE(*s, v);
+	release_stats_lock();
 }
 
 static inline void stats_add(uint64_t *s, uint64_t v)
 {
-	(void)__sync_add_and_fetch(s, v);
+	acquire_stats_lock();
+	WRITE_ONCE(*s, READ_ONCE(*s) + v);
+	release_stats_lock();
 }
 
 static inline void stats_inc(uint64_t *s)
 {
-	(void)__sync_add_and_fetch(s, 1);
+	acquire_stats_lock();
+	WRITE_ONCE(*s, READ_ONCE(*s) + 1);
+	release_stats_lock();
 }
 
 static inline void stats_sub(uint64_t *s, uint64_t v)
 {
-	(void)__sync_sub_and_fetch(s, v);
+	acquire_stats_lock();
+	WRITE_ONCE(*s, READ_ONCE(*s) - v);
+	release_stats_lock();
 }
 
 static inline void stats_dec(uint64_t *s)
 {
-	(void)__sync_sub_and_fetch(s, 1);
+	acquire_stats_lock();
+	WRITE_ONCE(*s, READ_ONCE(*s) - 1);
+	release_stats_lock();
 }
 
 void dns_stats_avg_time_update(struct dns_stats_avg_time *avg_time);
--- a/src/include/atomic.h
+++ b/src/include/atomic.h
@@ -20,10 +20,22 @@
 #ifndef _GENERIC_ATOMIC_H
 #define _GENERIC_ATOMIC_H
 
-#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&(x))
+#define ACCESS_ONCE(x) (*(volatile __typeof__(x) *)&(x))
 
-#define READ_ONCE(x) \
-({ typeof(x) ___x = ACCESS_ONCE(x); ___x; })
+#define READ_ONCE(x)                                                                                                   \
+	({                                                                                                                 \
+		__sync_synchronize();                                                                                          \
+		__typeof__(x) ___x = ACCESS_ONCE(x);                                                                           \
+		__sync_synchronize();                                                                                          \
+		___x;                                                                                                          \
+	})
+
+#define WRITE_ONCE(x, v)                                                                                               \
+	do {                                                                                                               \
+		__sync_synchronize();                                                                                          \
+		ACCESS_ONCE(x) = (v);                                                                                          \
+		__sync_synchronize();                                                                                          \
+	} while (0)
 
 /**
  * Atomic type.
