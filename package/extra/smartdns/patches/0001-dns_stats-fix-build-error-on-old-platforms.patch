From 672af5fe0654f6be274f08d600c81da4e2d7a6ee Mon Sep 17 00:00:00 2001
From: HiGarfield <HiGarfield@126.com>
Date: Thu, 27 Mar 2025 02:07:15 +0800
Subject: [PATCH] dns_stats: fix build error on old platforms

---
 src/dns_stats.c      | 10 ++++++++
 src/dns_stats.h      | 54 ++++++++++++++++++++++++++++++++++++++------
 src/include/atomic.h |  2 ++
 3 files changed, 59 insertions(+), 7 deletions(-)

--- a/src/dns_stats.c
+++ b/src/dns_stats.c
@@ -22,6 +22,8 @@
 
 struct dns_stats dns_stats;
 
+pthread_spinlock_t stats_lock;
+
 #define SAMPLE_PERIOD 5
 
 void dns_stats_avg_time_update_add(struct dns_stats_avg_time *avg_time, uint64_t time)
@@ -161,11 +163,19 @@ float dns_stats_server_stats_avg_time_ge
 int dns_stats_init(void)
 {
 	memset(&dns_stats, 0, sizeof(dns_stats));
+	if (pthread_spin_init(&stats_lock, PTHREAD_PROCESS_PRIVATE) != 0) {
+		perror("pthread_spin_init failed");
+		exit(EXIT_FAILURE);
+	}
 	return 0;
 }
 
 void dns_stats_exit(void)
 {
 	memset(&dns_stats, 0, sizeof(dns_stats));
+	if (pthread_spin_destroy(&stats_lock) != 0) {
+		perror("pthread_spin_destroy failed");
+		exit(EXIT_FAILURE);
+	}
 	return;
 }
\ No newline at end of file
--- a/src/dns_stats.h
+++ b/src/dns_stats.h
@@ -20,7 +20,10 @@
 #define SMART_DNS_STATS_H
 
 #include "atomic.h"
+#include <pthread.h>
 #include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -58,39 +61,76 @@ struct dns_server_stats {
 
 extern struct dns_stats dns_stats;
 
+extern pthread_spinlock_t stats_lock;
+
+#define ACQUIRE_LOCK()                                                                                                 \
+	do {                                                                                                               \
+		if (pthread_spin_lock(&stats_lock) != 0) {                                                                     \
+			perror("pthread_spin_lock failed");                                                                        \
+			exit(EXIT_FAILURE);                                                                                        \
+		}                                                                                                              \
+	} while (0)
+
+#define RELEASE_LOCK()                                                                                                 \
+	do {                                                                                                               \
+		if (pthread_spin_unlock(&stats_lock) != 0) {                                                                   \
+			perror("pthread_spin_unlock failed");                                                                      \
+			exit(EXIT_FAILURE);                                                                                        \
+		}                                                                                                              \
+	} while (0)
+
 static inline uint64_t stats_read(const uint64_t *s)
 {
-	return READ_ONCE((*s));
+	uint64_t val;
+	ACQUIRE_LOCK();
+	val = READ_ONCE(*s);
+	RELEASE_LOCK();
+	return val;
 }
 
 static inline uint64_t stats_read_and_set(uint64_t *s, uint64_t v)
 {
-	return __sync_lock_test_and_set(s, v);
+	uint64_t old_val;
+	ACQUIRE_LOCK();
+	old_val = READ_ONCE(*s);
+	WRITE_ONCE(*s, v);
+	RELEASE_LOCK();
+	return old_val;
 }
 
 static inline void stats_set(uint64_t *s, uint64_t v)
 {
-	*s = v;
+	ACQUIRE_LOCK();
+	WRITE_ONCE(*s, v);
+	RELEASE_LOCK();
 }
 
 static inline void stats_add(uint64_t *s, uint64_t v)
 {
-	(void)__sync_add_and_fetch(s, v);
+	ACQUIRE_LOCK();
+	WRITE_ONCE(*s, READ_ONCE(*s) + v);
+	RELEASE_LOCK();
 }
 
 static inline void stats_inc(uint64_t *s)
 {
-	(void)__sync_add_and_fetch(s, 1);
+	ACQUIRE_LOCK();
+	WRITE_ONCE(*s, READ_ONCE(*s) + 1);
+	RELEASE_LOCK();
 }
 
 static inline void stats_sub(uint64_t *s, uint64_t v)
 {
-	(void)__sync_sub_and_fetch(s, v);
+	ACQUIRE_LOCK();
+	WRITE_ONCE(*s, READ_ONCE(*s) - v);
+	RELEASE_LOCK();
 }
 
 static inline void stats_dec(uint64_t *s)
 {
-	(void)__sync_sub_and_fetch(s, 1);
+	ACQUIRE_LOCK();
+	WRITE_ONCE(*s, READ_ONCE(*s) - 1);
+	RELEASE_LOCK();
 }
 
 void dns_stats_avg_time_update(struct dns_stats_avg_time *avg_time);
--- a/src/include/atomic.h
+++ b/src/include/atomic.h
@@ -25,6 +25,8 @@
 #define READ_ONCE(x) \
 ({ typeof(x) ___x = ACCESS_ONCE(x); ___x; })
 
+#define WRITE_ONCE(x, val) ((*(volatile typeof(x) *)&(x)) = (val))
+
 /**
  * Atomic type.
  */
