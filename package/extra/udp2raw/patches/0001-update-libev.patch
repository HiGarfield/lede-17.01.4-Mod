From 2e081d8040c3e86520186af21eb4d873a08cfc81 Mon Sep 17 00:00:00 2001
From: HiGarfield <HiGarfield@126.com>
Date: Wed, 17 Aug 2022 22:35:42 +0800
Subject: [PATCH 1/2] update libev

---
 libev/CVS/Entries     |   31 -
 libev/CVS/Repository  |    1 -
 libev/CVS/Root        |    1 -
 libev/Changes         |  517 ----
 libev/LICENSE         |   37 -
 libev/Makefile.am     |   20 -
 libev/README          |   58 -
 libev/README.embed    |    3 -
 libev/Symbols.ev      |   73 -
 libev/Symbols.event   |   24 -
 libev/autogen.sh      |    3 -
 libev/configure.ac    |   27 -
 libev/ev++.h          |  218 +-
 libev/ev.3            | 5647 -----------------------------------------
 libev/ev.c            | 1117 +++++---
 libev/ev.h            |  216 +-
 libev/ev.pod          | 5570 ----------------------------------------
 libev/ev_epoll.c      |   69 +-
 libev/ev_iouring.c    |  694 +++++
 libev/ev_kqueue.c     |   24 +-
 libev/ev_linuxaio.c   |  620 +++++
 libev/ev_poll.c       |   33 +-
 libev/ev_port.c       |   13 +-
 libev/ev_select.c     |   12 +-
 libev/ev_vars.h       |   51 +-
 libev/ev_win32.c      |   14 +-
 libev/ev_wrap.h       |   72 +
 libev/event_compat.h  |  226 --
 libev/import_libevent |  131 -
 libev/libev.m4        |   42 -
 libev/update_ev_c     |    8 -
 libev/update_ev_wrap  |   19 -
 libev/update_symbols  |    7 -
 33 files changed, 2554 insertions(+), 13044 deletions(-)
 delete mode 100644 libev/CVS/Entries
 delete mode 100644 libev/CVS/Repository
 delete mode 100644 libev/CVS/Root
 delete mode 100644 libev/Changes
 delete mode 100644 libev/LICENSE
 delete mode 100644 libev/Makefile.am
 delete mode 100644 libev/README
 delete mode 100644 libev/README.embed
 delete mode 100644 libev/Symbols.ev
 delete mode 100644 libev/Symbols.event
 delete mode 100644 libev/autogen.sh
 delete mode 100644 libev/configure.ac
 delete mode 100644 libev/ev.3
 delete mode 100644 libev/ev.pod
 create mode 100644 libev/ev_iouring.c
 create mode 100644 libev/ev_linuxaio.c
 delete mode 100644 libev/event_compat.h
 delete mode 100755 libev/import_libevent
 delete mode 100644 libev/libev.m4
 delete mode 100755 libev/update_ev_c
 delete mode 100755 libev/update_ev_wrap
 delete mode 100755 libev/update_symbols

diff --git a/libev/CVS/Entries b/libev/CVS/Entries
deleted file mode 100644
index 5e21fb8..0000000
--- a/libev/CVS/Entries
+++ /dev/null
@@ -1,31 +0,0 @@
-/Changes/1.315/Wed Jun 21 14:42:30 2017//
-/LICENSE/1.11/Thu Jan 16 11:51:05 2014//
-/Makefile.am/1.9/Wed Dec 21 18:16:08 2011//
-/README/1.21/Fri Mar 30 17:43:55 2012//
-/README.embed/1.29/Sat Nov 24 10:10:26 2007//
-/Symbols.ev/1.14/Tue Jan 11 13:45:28 2011//
-/Symbols.event/1.4/Tue May  8 15:52:13 2012//
-/autogen.sh/1.3/Mon May 30 15:28:54 2011//
-/configure.ac/1.42/Wed Dec 28 04:22:06 2016//
-/ev++.h/1.63/Fri Dec  1 06:37:30 2017//
-/ev.3/1.107/Wed Jun 21 14:42:30 2017//
-/ev.c/1.481/Thu Jun  1 20:25:50 2017//
-/ev.h/1.187/Wed Dec 28 04:22:06 2016//
-/ev.pod/1.441/Thu Jul 13 10:46:52 2017//
-/ev_epoll.c/1.72/Wed Jun 21 14:42:30 2017//
-/ev_kqueue.c/1.56/Thu Feb 18 04:48:05 2016//
-/ev_poll.c/1.40/Thu Feb 18 04:48:05 2016//
-/ev_port.c/1.29/Thu Feb 18 04:48:05 2016//
-/ev_select.c/1.56/Thu Feb 18 04:48:05 2016//
-/ev_vars.h/1.58/Tue Sep  9 21:51:35 2014//
-/ev_win32.c/1.18/Thu Nov 12 07:02:37 2015//
-/ev_wrap.h/1.38/Tue Nov  6 20:56:50 2012//
-/event.c/1.52/Mon Apr  2 23:14:41 2012//
-/event.h/1.26/Mon Apr  2 23:15:27 2012//
-/event_compat.h/1.8/Wed Feb 16 08:02:51 2011//
-/import_libevent/1.29/Tue Apr 15 04:34:07 2008//
-/libev.m4/1.16/Mon Oct 28 12:36:44 2013//
-/update_ev_c/1.2/Wed Jan 18 12:13:14 2012//
-/update_ev_wrap/1.6/Sun May  6 13:09:29 2012//
-/update_symbols/1.1/Wed Dec 19 01:59:29 2007//
-D
diff --git a/libev/CVS/Repository b/libev/CVS/Repository
deleted file mode 100644
index 16429a4..0000000
--- a/libev/CVS/Repository
+++ /dev/null
@@ -1 +0,0 @@
-libev
diff --git a/libev/CVS/Root b/libev/CVS/Root
deleted file mode 100644
index 4f19ed2..0000000
--- a/libev/CVS/Root
+++ /dev/null
@@ -1 +0,0 @@
-:pserver:anonymous@cvs.schmorp.de/schmorpforge
diff --git a/libev/Changes b/libev/Changes
deleted file mode 100644
index 9968527..0000000
--- a/libev/Changes
+++ /dev/null
@@ -1,517 +0,0 @@
-Revision history for libev, a high-performance and full-featured event loop.
-
-	- ANDROID => __ANDROID__ (reported by enh@google.com).
-        - disable epoll_create1 on android because it has broken header files
-          and google is unwilling to fix them (reported by enh@google.com).
-
-4.24 Wed Dec 28 05:19:55 CET 2016
-	- bump version to 4.24, as the release tarball inexplicably
-          didn't have the right version in ev.h, even though the cvs-tagged
-          version did have the right one (reported by Ales Teska).
-
-4.23 Wed Nov 16 18:23:41 CET 2016
-	- move some declarations at the beginning to help certain retarded
-          microsoft compilers, even though their documentation claims
-          otherwise (reported by Ruslan Osmanov).
-
-4.22 Sun Dec 20 22:11:50 CET 2015
-	- when epoll detects unremovable fds in the fd set, rebuild
-          only the epoll descriptor, not the signal pipe, to avoid
-          SIGPIPE in ev_async_send. This doesn't solve it on fork,
-          so document what needs to be done in ev_loop_fork
-          (analyzed by Benjamin Mahler).
-	- remove superfluous sys/timeb.h include on win32
-          (analyzed by Jason Madden).
-        - updated libecb.
-
-4.20 Sat Jun 20 13:01:43 CEST 2015
-	- prefer noexcept over throw () with C++ 11.
-        - update ecb.h due to incompatibilities with c11.
-        - fix a potential aliasing issue when reading and writing
-          watcher callbacks.
-
-4.19 Thu Sep 25 08:18:25 CEST 2014
-	- ev.h wasn't valid C++ anymore, which tripped compilers other than
-          clang, msvc or gcc (analyzed by Raphael 'kena' Poss). Unfortunately,
-          C++ doesn't support typedefs for function pointers fully, so the affected
-          declarations have to spell out the types each time.
-	- when not using autoconf, tighten the check for clock_gettime and related
-          functionality.
-
-4.18 Fri Sep  5 17:55:26 CEST 2014
-	- events on files were not always generated properly with the
-          epoll backend (testcase by Assaf Inbal).
-	- mark event pipe fd as cloexec after a fork (analyzed by Sami Farin).
-        - (ecb) support m68k, m88k and sh (patch by Miod Vallat).
-        - use a reasonable fallback for EV_NSIG instead of erroring out
-          when we can't detect the signal set size.
-        - in the absence of autoconf, do not use the clock syscall
-          on glibc >= 2.17 (avoids the syscall AND -lrt on systems
-          doing clock_gettime in userspace).
-        - ensure extern "C" function pointers are used for externally-visible
-          loop callbacks (not watcher callbacks yet).
-        - (ecb) work around memory barriers and volatile apparently both being
-          broken in visual studio 2008 and later (analysed and patch by Nicolas Noble).
-
-4.15 Fri Mar  1 12:04:50 CET 2013
-        - destroying a non-default loop would stop the global waitpid
-          watcher (Denis Bilenko).
-	- queueing pending watchers of higher priority from a watcher now invokes
-          them in a timely fashion (reported by Denis Bilenko).
-	- add throw() to all libev functions that cannot throw exceptions, for
-          further code size decrease when compiling for C++.
-        - add throw () to callbacks that must not throw exceptions (allocator,
-          syserr, loop acquire/release, periodic reschedule cbs).
-	- fix event_base_loop return code, add event_get_callback, event_base_new,
-          event_base_get_method calls to improve libevent 1.x emulation and add
-          some libevent 2.x functionality (based on a patch by Jeff Davey).
-        - add more memory fences to fix a bug reported by Jeff Davey. Better
-          be overfenced than underprotected.
-	- ev_run now returns a boolean status (true meaning watchers are
-          still active).
-	- ev_once: undef EV_ERROR in ev_kqueue.c, to avoid clashing with
-          libev's EV_ERROR (reported by 191919).
-	- (ecb) add memory fence support for xlC (Darin McBride).
-	- (ecb) add memory fence support for gcc-mips (Anton Kirilov).
-	- (ecb) add memory fence support for gcc-alpha (Christian Weisgerber).
-        - work around some kernels losing file descriptors by leaking
-          the kqueue descriptor in the child.
-        - work around linux inotify not reporting IN_ATTRIB changes for directories
-          in many cases.
-        - include sys/syscall.h instead of plain syscall.h.
-        - check for io watcher loops in ev_verify, check for the most
-          common reported usage bug in ev_io_start.
-        - choose socket vs. WSASocket at compiletime using EV_USE_WSASOCKET.
-        - always use WSASend/WSARecv directly on windows, hoping that this
-          works in all cases (unlike read/write/send/recv...).
-        - try to detect signals around a fork faster (test program by
-          Denis Bilenko).
-        - work around recent glibc versions that leak memory in realloc.
-        - rename ev::embed::set to ev::embed::set_embed to avoid clashing
-          the watcher base set (loop) method.
-        - rewrite the async/signal pipe logic to always keep a valid fd, which
-          simplifies (and hopefully correctifies :) the race checking
-          on fork, at the cost of one extra fd.
-        - add fat, msdos, jffs2, ramfs, ntfs and btrfs to the list of
-          inotify-supporting filesystems.
-        - move orig_CFLAGS assignment to after AC_INIT, as newer autoconf
-          versions ignore it before
-          (https://bugzilla.redhat.com/show_bug.cgi?id=908096).
-        - add some untested android support.
-        - enum expressions must be of type int (reported by Juan Pablo L).
-
-4.11 Sat Feb  4 19:52:39 CET 2012
-	- INCOMPATIBLE CHANGE: ev_timer_again now clears the pending status, as
-          was documented already, but not implemented in the repeating case.
-        - new compiletime symbols: EV_NO_SMP and EV_NO_THREADS.
-	- fix a race where the workaround against the epoll fork bugs
-          caused signals to not be handled anymore.
-	- correct backend_fudge for most backends, and implement a windows
-          specific workaround to avoid looping because we call both
-          select and Sleep, both with different time resolutions.
-        - document range and guarantees of ev_sleep.
-        - document reasonable ranges for periodics interval and offset.
-        - rename backend_fudge to backend_mintime to avoid future confusion :)
-	- change the default periodic reschedule function to hopefully be more
-          exact and correct even in corner cases or in the far future.
-        - do not rely on -lm anymore: use it when available but use our
-          own floor () if it is missing. This should make it easier to embed,
-          as no external libraries are required.
-        - strategically import macros from libecb and mark rarely-used functions
-          as cache-cold (saving almost 2k code size on typical amd64 setups).
-        - add Symbols.ev and Symbols.event files, that were missing.
-        - fix backend_mintime value for epoll (was 1/1024, is 1/1000 now).
-        - fix #3 "be smart about timeouts" to not "deadlock" when
-          timeout == now, also improve the section overall.
-        - avoid "AVOIDING FINISHING BEFORE RETURNING" idiom.
-        - support new EV_API_STATIC mode to make all libev symbols
-          static.
-        - supply default CFLAGS of -g -O3 with gcc when original CFLAGS
-          were empty.
-
-4.04 Wed Feb 16 09:01:51 CET 2011
-	- fix two problems in the native win32 backend, where reuse of fd's
-          with different underlying handles caused handles not to be removed
-          or added to the select set (analyzed and tested by Bert Belder).
-	- do no rely on ceil() in ev_e?poll.c.
-        - backport libev to HP-UX versions before 11 v3.
-        - configure did not detect nanosleep and clock_gettime properly when
-          they are available in the libc (as opposed to -lrt).
-
-4.03 Tue Jan 11 14:37:25 CET 2011
-	- officially support polling files with all backends.
-	- support files, /dev/zero etc. the same way as select in the epoll
-          backend, by generating events on our own.
-        - ports backend: work around solaris bug 6874410 and many related ones
-          (EINTR, maybe more), with no performance loss (note that the solaris
-          bug report is actually wrong, reality is far more bizarre and broken
-          than that).
-	- define EV_READ/EV_WRITE as macros in event.h, as some programs use
-          #ifdef to test for them.
-        - new (experimental) function: ev_feed_signal.
-        - new (to become default) EVFLAG_NOSIGMASK flag.
-        - new EVBACKEND_MASK symbol.
-        - updated COMMON IDIOMS SECTION.
-
-4.01 Fri Nov  5 21:51:29 CET 2010
-        - automake fucked it up, apparently, --add-missing -f is not quite enough
-          to make it update its files, so 4.00 didn't install ev++.h and
-          event.h on make install. grrr.
-        - ev_loop(count|depth) didn't return anything (Robin Haberkorn).
-        - change EV_UNDEF to 0xffffffff to silence some overzealous compilers.
-        - use "(libev) " prefix for all libev error messages now.
-
-4.00 Mon Oct 25 12:32:12 CEST 2010
-	- "PORTING FROM LIBEV 3.X TO 4.X" (in ev.pod) is recommended reading.
-	- ev_embed_stop did not correctly stop the watcher (very good
-          testcase by Vladimir Timofeev).
-        - ev_run will now always update the current loop time - it erroneously
-          didn't when idle watchers were active, causing timers not to fire.
-        - fix a bug where a timeout of zero caused the timer not to fire
-          in the libevent emulation (testcase by Péter Szabó).
-	- applied win32 fixes by Michael Lenaghan (also James Mansion).
-	- replace EV_MINIMAL by EV_FEATURES.
-        - prefer EPOLL_CTL_ADD over EPOLL_CTL_MOD in some more cases, as it
-          seems the former is *much* faster than the latter.
-        - linux kernel version detection (for inotify bug workarounds)
-          did not work properly.
-        - reduce the number of spurious wake-ups with the ports backend.
-        - remove dependency on sys/queue.h on freebsd (patch by Vanilla Hsu).
-        - do async init within ev_async_start, not ev_async_set, which avoids
-          an API quirk where the set function must be called in the C++ API
-          even when there is nothing to set.
-        - add (undocumented) EV_ENABLE when adding events with kqueue,
-          this might help with OS X, which seems to need it despite documenting
-          not to need it (helpfully pointed out by Tilghman Lesher).
-        - do not use poll by default on freebsd, it's broken (what isn't
-          on freebsd...).
-        - allow to embed epoll on kernels >= 2.6.32.
-        - configure now prepends -O3, not appends it, so one can still
-          override it.
-        - ev.pod: greatly expanded the portability section, added a porting
-          section, a description of watcher states and made lots of minor fixes.
-        - disable poll backend on AIX, the poll header spams the namespace
-          and it's not worth working around dead platforms (reported
-          and analyzed by Aivars Kalvans).
-        - improve header file compatibility of the standalone eventfd code
-          in an obscure case.
-        - implement EV_AVOID_STDIO option.
-        - do not use sscanf to parse linux version number (smaller, faster,
-          no sscanf dependency).
-        - new EV_CHILD_ENABLE and EV_SIGNAL_ENABLE configurable settings.
-        - update libev.m4 HAVE_CLOCK_SYSCALL test for newer glibcs.
-        - add section on accept() problems to the manpage.
-        - rename EV_TIMEOUT to EV_TIMER.
-        - rename ev_loop_count/depth/verify/loop/unloop.
-        - remove ev_default_destroy and ev_default_fork.
-        - switch to two-digit minor version.
-        - work around an apparent gentoo compiler bug.
-        - define _DARWIN_UNLIMITED_SELECT. just so.
-        - use enum instead of #define for most constants.
-        - improve compatibility to older C++ compilers.
-        - (experimental) ev_run/ev_default_loop/ev_break/ev_loop_new have now
-          default arguments when compiled as C++.
-        - enable automake dependency tracking.
-        - ev_loop_new no longer leaks memory when loop creation failed.
-        - new ev_cleanup watcher type.
-
-3.9  Thu Dec 31 07:59:59 CET 2009
-	- signalfd is no longer used by default and has to be requested
-          explicitly - this means that easy to catch bugs become hard to
-          catch race conditions, but the users have spoken.
-        - point out the unspecified signal mask in the documentation, and
-          that this is a race condition regardless of EV_SIGNALFD.
-	- backport inotify code to C89.
-        - inotify file descriptors could leak into child processes.
-        - ev_stat watchers could keep an erroneous extra ref on the loop,
-          preventing exit when unregistering all watchers (testcases
-          provided by ry@tinyclouds.org).
-        - implement EV_WIN32_HANDLE_TO_FD and EV_WIN32_CLOSE_FD configuration
-          symbols to make it easier for apps to do their own fd management.
-        - support EV_IDLE_ENABLE being disabled in ev++.h
-          (patch by Didier Spezia).
-        - take advantage of inotify_init1, if available, to set cloexec/nonblock
-          on fd creation, to avoid races.
-        - the signal handling pipe wasn't always initialised under windows
-          (analysed by lekma).
-        - changed minimum glibc requirement from glibc 2.9 to 2.7, for
-          signalfd.
-        - add missing string.h include (Denis F. Latypoff).
-        - only replace ev_stat.prev when we detect an actual difference,
-          so prev is (almost) always different to attr. this might
-          have caused the problems with 04_stat.t.
-        - add ev::timer->remaining () method to C++ API.
-
-3.8  Sun Aug  9 14:30:45 CEST 2009
-	- incompatible change: do not necessarily reset signal handler
-          to SIG_DFL when a sighandler is stopped.
-        - ev_default_destroy did not properly free or zero some members,
-          potentially causing crashes and memory corruption on repeated
-          ev_default_destroy/ev_default_loop calls.
-	- take advantage of signalfd on GNU/Linux systems.
-	- document that the signal mask might be in an unspecified
-          state when using libev's signal handling.
-        - take advantage of some GNU/Linux calls to set cloexec/nonblock
-          on fd creation, to avoid race conditions.
-
-3.7  Fri Jul 17 16:36:32 CEST 2009
-	- ev_unloop and ev_loop wrongly used a global variable to exit loops,
-          instead of using a per-loop variable (bug caught by accident...).
-	- the ev_set_io_collect_interval interpretation has changed.
-        - add new functionality: ev_set_userdata, ev_userdata,
-          ev_set_invoke_pending_cb, ev_set_loop_release_cb,
-          ev_invoke_pending, ev_pending_count, together with a long example
-          about thread locking.
-        - add ev_timer_remaining (as requested by Denis F. Latypoff).
-        - add ev_loop_depth.
-        - calling ev_unloop in fork/prepare watchers will no longer poll
-          for new events.
-	- Denis F. Latypoff corrected many typos in example code snippets.
-        - honor autoconf detection of EV_USE_CLOCK_SYSCALL, also double-
-          check that the syscall number is available before trying to
-          use it (reported by ry@tinyclouds).
-        - use GetSystemTimeAsFileTime instead of _timeb on windows, for
-          slightly higher accuracy.
-        - properly declare ev_loop_verify and ev_now_update even when
-          !EV_MULTIPLICITY.
-        - do not compile in any priority code when EV_MAXPRI == EV_MINPRI.
-        - support EV_MINIMAL==2 for a reduced API.
-        - actually 0-initialise struct sigaction when installing signals.
-        - add section on hibernate and stopped processes to ev_timer docs.
-
-3.6  Tue Apr 28 02:49:30 CEST 2009
-	- multiple timers becoming ready within an event loop iteration
-          will be invoked in the "correct" order now.
-	- do not leave the event loop early just because we have no active
-          watchers, fixing a problem when embedding a kqueue loop
-          that has active kernel events but no registered watchers
-          (reported by blacksand blacksand).
-	- correctly zero the idx values for arrays, so destroying and
-          reinitialising the default loop actually works (patch by
-          Malek Hadj-Ali).
-        - implement ev_suspend and ev_resume.
-        - new EV_CUSTOM revents flag for use by applications.
-        - add documentation section about priorities.
-        - add a glossary to the documentation.
-        - extend the ev_fork description slightly.
-        - optimize a jump out of call_pending.
-
-3.53 Sun Feb 15 02:38:20 CET 2009
-	- fix a bug in event pipe creation on win32 that would cause a
-          failed assertion on event loop creation (patch by Malek Hadj-Ali).
-	- probe for CLOCK_REALTIME support at runtime as well and fall
-          back to gettimeofday if there is an error, to support older
-          operating systems with newer header files/libraries.
-        - prefer gettimeofday over clock_gettime with USE_CLOCK_SYSCALL
-          (default most everywhere), otherwise not.
-
-3.52 Wed Jan  7 21:43:02 CET 2009
-	- fix compilation of select backend in fd_set mode when NFDBITS is
-          missing (to get it to compile on QNX, reported by Rodrigo Campos).
-        - better select-nfds handling when select backend is in fd_set mode.
-        - diagnose fd_set overruns when select backend is in fd_set mode.
-        - due to a thinko, instead of disabling everything but
-          select on the borked OS X platform, everything but select was
-          allowed (reported by Emanuele Giaquinta).
-        - actually verify that local and remote port are matching in
-          libev's socketpair emulation, which makes denial-of-service
-          attacks harder (but not impossible - it's windows). Make sure
-          it even works under vista, which thinks that getpeer/sockname
-          should return fantasy port numbers.
-        - include "libev" in all assertion messages for potentially
-          clearer diagnostics.
-        - event_get_version (libevent compatibility) returned
-          a useless string instead of the expected version string
-          (patch by W.C.A. Wijngaards).
-
-3.51 Wed Dec 24 23:00:11 CET 2008
-        - fix a bug where an inotify watcher was added twice, causing
-          freezes on hash collisions (reported and analysed by Graham Leggett).
-	- new config symbol, EV_USE_CLOCK_SYSCALL, to make libev use
-          a direct syscall - slower, but no dependency on librt et al.
-        - assume negative return values != -1 signals success of port_getn
-          (http://cvs.epicsol.org/cgi/viewcvs.cgi/epic5/source/newio.c?rev=1.52)
-          (no known failure reports, but it doesn't hurt).
-        - fork detection in ev_embed now stops and restarts the watcher
-          automatically.
-        - EXPERIMENTAL: default the method to operator () in ev++.h,
-          to make it nicer to use functors (requested by Benedek László).
-        - fixed const object callbacks in ev++.h.
-        - replaced loop_ref argument of watcher.set (loop) by a direct
-          ev_loop * in ev++.h, to avoid clashes with functor patch.
-        - do not try to watch the empty string via inotify.
-        - inotify watchers could be leaked under certain circumstances.
-        - OS X 10.5 is actually even more broken than earlier versions,
-          so fall back to select on that piece of garbage.
-        - fixed some weirdness in the ev_embed documentation.
-
-3.49 Wed Nov 19 11:26:53 CET 2008
-	- ev_stat watchers will now use inotify as a mere hint on
-          kernels <2.6.25, or if the filesystem is not in the
-          "known to be good" list.
-        - better mingw32 compatibility (it's not as borked as native win32)
-          (analysed by Roger Pack).
-        - include stdio.h in the example program, as too many people are
-          confused by the weird C language otherwise. I guess the next thing
-          I get told is that the "..." ellipses in the examples don't compile
-          with their C compiler.
-
-3.48 Thu Oct 30 09:02:37 CET 2008
-	- further optimise away the EPOLL_CTL_ADD/MOD combo in the epoll
-          backend by assuming the kernel event mask hasn't changed if
-          ADD fails with EEXIST.
-        - work around spurious event notification bugs in epoll by using
-          a 32-bit generation counter. recreate kernel state if we receive
-          spurious notifications or unwanted events. this is very costly,
-          but I didn't come up with this horrible design.
-        - use memset to initialise most arrays now and do away with the
-          init functions.
-        - expand time-out strategies into a "Be smart about timeouts" section.
-        - drop the "struct" from all ev_watcher declarations in the
-          documentation and did other clarifications (yeah, it was a mistake
-          to have a struct AND a function called ev_loop).
-	- fix a bug where ev_default would not initialise the default
-          loop again after it was destroyed with ev_default_destroy.
-        - rename syserr to ev_syserr to avoid name clashes when embedding,
-          do similar changes for event.c.
-
-3.45 Tue Oct 21 21:59:26 CEST 2008
-	- disable inotify usage on linux <2.6.25, as it is broken
-          (reported by Yoann Vandoorselaere).
-        - ev_stat erroneously would try to add inotify watchers
-          even when inotify wasn't available (this should only
-          have a performance impact).
-	- ev_once now passes both timeout and io to the callback if both
-          occur concurrently, instead of giving timeouts precedence.
-	- disable EV_USE_INOTIFY when sys/inotify.h is too old.
-
-3.44 Mon Sep 29 05:18:39 CEST 2008
-	- embed watchers now automatically invoke ev_loop_fork on the
-          embedded loop when the parent loop forks.
-	- new function: ev_now_update (loop).
-	- verify_watcher was not marked static.
-        - improve the "associating..." manpage section.
-        - documentation tweaks here and there.
-
-3.43 Sun Jul  6 05:34:41 CEST 2008
-	- include more include files on windows to get struct _stati64
-          (reported by Chris Hulbert, but doesn't quite fix his issue).
-	- add missing #include <io.h> in ev.c on windows (reported by
-          Matt Tolton).
-
-3.42 Tue Jun 17 12:12:07 CEST 2008
-	- work around yet another windows bug: FD_SET actually adds fd's
-          multiple times to the fd_*SET*, despite official MSN docs claiming
-          otherwise. Reported and well-analysed by Matt Tolton.
-	- define NFDBITS to 0 when EV_SELECT_IS_WINSOCKET to make it compile
-          (reported any analysed by Chris Hulbert).
-        - fix a bug in ev_ebadf (this function is only used to catch
-          programming errors in the libev user). reported by Matt Tolton.
-        - fix a bug in fd_intern on win32 (could lead to compile errors
-          under some circumstances, but would work correctly if it compiles).
-          reported by Matt Tolton.
-        - (try to) work around missing lstat on windows.
-	- pass in the write fd set as except fd set under windows. windows
-          is so uncontrollably lame that it requires this. this means that
-          switching off oobinline is not supported (but tcp/ip doesn't
-          have oob, so that would be stupid anyways.
-        - use posix module symbol to auto-detect monotonic clock presence
-          and some other default values.
-
-3.41 Fri May 23 18:42:54 CEST 2008
-	- work around an obscure bug in winsocket select: if you
-          provide only empty fd sets then select returns WSAEINVAL. how sucky.
-        - improve timer scheduling stability and reduce use of time_epsilon.
-        - use 1-based 2-heap for EV_MINIMAL, simplifies code, reduces
-          codesize and makes for better cache-efficiency.
-        - use 3-based 4-heap for !EV_MINIMAL. this makes better use
-          of cpu cache lines and gives better growth behaviour than
-          2-based heaps.
-        - cache timestamp within heap for !EV_MINIMAL, to avoid random
-          memory accesses.
-        - document/add EV_USE_4HEAP and EV_HEAP_CACHE_AT.
-        - fix a potential aliasing issue in ev_timer_again.
-        - add/document ev_periodic_at, retract direct access to ->at.
-        - improve ev_stat docs.
-        - add portability requirements section.
-	- fix manpage headers etc.
-        - normalise WSA error codes to lower range on windows.
-        - add consistency check code that can be called automatically
-          or on demand to check for internal structures (ev_loop_verify).
-
-3.31 Wed Apr 16 20:45:04 CEST 2008
-	- added last minute fix for ev_poll.c by Brandon Black.
-
-3.3  Wed Apr 16 19:04:10 CEST 2008
-        - event_base_loopexit should return 0 on success
-          (W.C.A. Wijngaards).
-	- added linux eventfd support.
-        - try to autodetect epoll and inotify support
-          by libc header version if not using autoconf.
-        - new symbols: EV_DEFAULT_UC and EV_DEFAULT_UC_.
-        - declare functions defined in ev.h as inline if
-          C99 or gcc are available.
-        - enable inlining with gcc versions 2 and 3.
-        - work around broken poll implementations potentially
-          not clearing revents field in ev_poll (Brandon Black)
-          (no such systems are known at this time).
-        - work around a bug in realloc on openbsd and darwin,
-          also makes the erroneous valgrind complaints
-          go away (noted by various people).
-        - fix ev_async_pending, add c++ wrapper for ev_async
-          (based on patch sent by Johannes Deisenhofer).
-        - add sensible set method to ev::embed.
-        - made integer constants type int in ev.h.
-
-3.2  Wed Apr  2 17:11:19 CEST 2008
-	- fix a 64 bit overflow issue in the select backend,
-          by using fd_mask instead of int for the mask.
-        - rename internal sighandler to avoid clash with very old perls.
-        - entering ev_loop will not clear the ONESHOT or NONBLOCKING
-          flags of any outer loops anymore.
-        - add ev_async_pending.
-
-3.1  Thu Mar 13 13:45:22 CET 2008
-	- implement ev_async watchers.
-        - only initialise signal pipe on demand.
-	- make use of sig_atomic_t configurable.
-        - improved documentation.
-
-3.0  Mon Jan 28 13:14:47 CET 2008
-	- API/ABI bump to version 3.0.
-	- ev++.h includes "ev.h" by default now, not <ev.h>.
-	- slightly improved documentation.
-	- speed up signal detection after a fork.
-        - only optionally return trace status changed in ev_child
-          watchers.
-        - experimental (and undocumented) loop wrappers for ev++.h.
-
-2.01 Tue Dec 25 08:04:41 CET 2007
-	- separate Changes file.
-	- fix ev_path_set => ev_stat_set typo.
-        - remove event_compat.h from the libev tarball.
-        - change how include files are found.
-        - doc updates.
-        - update licenses, explicitly allow for GPL relicensing.
-
-2.0  Sat Dec 22 17:47:03 CET 2007
-        - new ev_sleep, ev_set_(io|timeout)_collect_interval.
-        - removed epoll from embeddable fd set.
-        - fix embed watchers.
-	- renamed ev_embed.loop to other.
-	- added exported Symbol tables.
-        - undefine member wrapper macros at the end of ev.c.
-        - respect EV_H in ev++.h.
-
-1.86 Tue Dec 18 02:36:57 CET 2007
-	- fix memleak on loop destroy (not relevant for perl).
-
-1.85 Fri Dec 14 20:32:40 CET 2007
-        - fix some aliasing issues w.r.t. timers and periodics
-          (not relevant for perl).
-
-(for historic versions refer to EV/Changes, found in the Perl interface)
-
-0.1  Wed Oct 31 21:31:48 CET 2007
-	- original version; hacked together in <24h.
-
diff --git a/libev/LICENSE b/libev/LICENSE
deleted file mode 100644
index 2fdabd4..0000000
--- a/libev/LICENSE
+++ /dev/null
@@ -1,37 +0,0 @@
-All files in libev are
-Copyright (c)2007,2008,2009,2010,2011,2012,2013 Marc Alexander Lehmann.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above
-      copyright notice, this list of conditions and the following
-      disclaimer in the documentation and/or other materials provided
-      with the distribution.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-Alternatively, the contents of this package may be used under the terms
-of the GNU General Public License ("GPL") version 2 or any later version,
-in which case the provisions of the GPL are applicable instead of the
-above. If you wish to allow the use of your version of this package only
-under the terms of the GPL and not to allow others to use your version of
-this file under the BSD license, indicate your decision by deleting the
-provisions above and replace them with the notice and other provisions
-required by the GPL in this and the other files of this package. If you do
-not delete the provisions above, a recipient may use your version of this
-file under either the BSD or the GPL.
diff --git a/libev/Makefile.am b/libev/Makefile.am
deleted file mode 100644
index 059305b..0000000
--- a/libev/Makefile.am
+++ /dev/null
@@ -1,20 +0,0 @@
-AUTOMAKE_OPTIONS = foreign
-
-VERSION_INFO = 4:0:0
-
-EXTRA_DIST = LICENSE Changes libev.m4 autogen.sh \
-	     ev_vars.h ev_wrap.h \
-	     ev_epoll.c ev_select.c ev_poll.c ev_kqueue.c ev_port.c ev_win32.c \
-	     ev.3 ev.pod Symbols.ev Symbols.event
-
-man_MANS = ev.3
-
-include_HEADERS = ev.h ev++.h event.h
-
-lib_LTLIBRARIES = libev.la
-
-libev_la_SOURCES = ev.c event.c
-libev_la_LDFLAGS = -version-info $(VERSION_INFO)
-
-ev.3: ev.pod
-	pod2man -n LIBEV -r "libev-$(VERSION)" -c "libev - high performance full featured event loop" -s3 <$< >$@
diff --git a/libev/README b/libev/README
deleted file mode 100644
index 31f6193..0000000
--- a/libev/README
+++ /dev/null
@@ -1,58 +0,0 @@
-libev is a high-performance event loop/event model with lots of features.
-(see benchmark at http://libev.schmorp.de/bench.html)
-
-
-ABOUT
-
-   Homepage: http://software.schmorp.de/pkg/libev
-   Mailinglist: libev@lists.schmorp.de
-                http://lists.schmorp.de/cgi-bin/mailman/listinfo/libev
-   Library Documentation: http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod
-
-   Libev is modelled (very losely) after libevent and the Event perl
-   module, but is faster, scales better and is more correct, and also more
-   featureful. And also smaller. Yay.
-
-   Some of the specialties of libev not commonly found elsewhere are:
-   
-   - extensive and detailed, readable documentation (not doxygen garbage).
-   - fully supports fork, can detect fork in various ways and automatically
-     re-arms kernel mechanisms that do not support fork.
-   - highly optimised select, poll, epoll, kqueue and event ports backends.
-   - filesystem object (path) watching (with optional linux inotify support).
-   - wallclock-based times (using absolute time, cron-like).
-   - relative timers/timeouts (handle time jumps).
-   - fast intra-thread communication between multiple
-     event loops (with optional fast linux eventfd backend).
-   - extremely easy to embed (fully documented, no dependencies,
-     autoconf supported but optional).
-   - very small codebase, no bloated library, simple code.
-   - fully extensible by being able to plug into the event loop,
-     integrate other event loops, integrate other event loop users.
-   - very little memory use (small watchers, small event loop data).
-   - optional C++ interface allowing method and function callbacks
-     at no extra memory or runtime overhead.
-   - optional Perl interface with similar characteristics (capable
-     of running Glib/Gtk2 on libev).
-   - support for other languages (multiple C++ interfaces, D, Ruby,
-     Python) available from third-parties.
-
-   Examples of programs that embed libev: the EV perl module, node.js,
-   auditd, rxvt-unicode, gvpe (GNU Virtual Private Ethernet), the
-   Deliantra MMORPG server (http://www.deliantra.net/), Rubinius (a
-   next-generation Ruby VM), the Ebb web server, the Rev event toolkit.
-
-
-CONTRIBUTORS
-
-   libev was written and designed by Marc Lehmann and Emanuele Giaquinta.
-
-   The following people sent in patches or made other noteworthy
-   contributions to the design (for minor patches, see the Changes
-   file. If I forgot to include you, please shout at me, it was an
-   accident):
-
-   W.C.A. Wijngaards
-   Christopher Layne
-   Chris Brody
-
diff --git a/libev/README.embed b/libev/README.embed
deleted file mode 100644
index 0d1bd5e..0000000
--- a/libev/README.embed
+++ /dev/null
@@ -1,3 +0,0 @@
-This file is now included in the main libev documentation, see
-
-   http://cvs.schmorp.de/libev/ev.html
diff --git a/libev/Symbols.ev b/libev/Symbols.ev
deleted file mode 100644
index 7a29a75..0000000
--- a/libev/Symbols.ev
+++ /dev/null
@@ -1,73 +0,0 @@
-ev_async_send
-ev_async_start
-ev_async_stop
-ev_backend
-ev_break
-ev_check_start
-ev_check_stop
-ev_child_start
-ev_child_stop
-ev_cleanup_start
-ev_cleanup_stop
-ev_clear_pending
-ev_default_loop
-ev_default_loop_ptr
-ev_depth
-ev_embed_start
-ev_embed_stop
-ev_embed_sweep
-ev_embeddable_backends
-ev_feed_event
-ev_feed_fd_event
-ev_feed_signal
-ev_feed_signal_event
-ev_fork_start
-ev_fork_stop
-ev_idle_start
-ev_idle_stop
-ev_invoke
-ev_invoke_pending
-ev_io_start
-ev_io_stop
-ev_iteration
-ev_loop_destroy
-ev_loop_fork
-ev_loop_new
-ev_now
-ev_now_update
-ev_once
-ev_pending_count
-ev_periodic_again
-ev_periodic_start
-ev_periodic_stop
-ev_prepare_start
-ev_prepare_stop
-ev_recommended_backends
-ev_ref
-ev_resume
-ev_run
-ev_set_allocator
-ev_set_invoke_pending_cb
-ev_set_io_collect_interval
-ev_set_loop_release_cb
-ev_set_syserr_cb
-ev_set_timeout_collect_interval
-ev_set_userdata
-ev_signal_start
-ev_signal_stop
-ev_sleep
-ev_stat_start
-ev_stat_stat
-ev_stat_stop
-ev_supported_backends
-ev_suspend
-ev_time
-ev_timer_again
-ev_timer_remaining
-ev_timer_start
-ev_timer_stop
-ev_unref
-ev_userdata
-ev_verify
-ev_version_major
-ev_version_minor
diff --git a/libev/Symbols.event b/libev/Symbols.event
deleted file mode 100644
index 799d424..0000000
--- a/libev/Symbols.event
+++ /dev/null
@@ -1,24 +0,0 @@
-event_active
-event_add
-event_base_dispatch
-event_base_free
-event_base_get_method
-event_base_loop
-event_base_loopexit
-event_base_new
-event_base_once
-event_base_priority_init
-event_base_set
-event_del
-event_dispatch
-event_get_callback
-event_get_method
-event_get_version
-event_init
-event_loop
-event_loopexit
-event_once
-event_pending
-event_priority_init
-event_priority_set
-event_set
diff --git a/libev/autogen.sh b/libev/autogen.sh
deleted file mode 100644
index 8056ee7..0000000
--- a/libev/autogen.sh
+++ /dev/null
@@ -1,3 +0,0 @@
-#!/bin/sh
-
-autoreconf --install --symlink --force
diff --git a/libev/configure.ac b/libev/configure.ac
deleted file mode 100644
index 2590f8f..0000000
--- a/libev/configure.ac
+++ /dev/null
@@ -1,27 +0,0 @@
-AC_INIT
-
-orig_CFLAGS="$CFLAGS"
-
-AC_CONFIG_SRCDIR([ev_epoll.c])
-
-dnl also update ev.h!
-AM_INIT_AUTOMAKE(libev,4.24)
-AC_CONFIG_HEADERS([config.h])
-AM_MAINTAINER_MODE
-
-AC_PROG_CC
-
-dnl Supply default CFLAGS, if not specified
-if test -z "$orig_CFLAGS"; then
-  if test x$GCC = xyes; then
-    CFLAGS="-g -O3"
-  fi
-fi
-
-AC_PROG_INSTALL
-AC_PROG_LIBTOOL
-
-m4_include([libev.m4])
-
-AC_CONFIG_FILES([Makefile])
-AC_OUTPUT
diff --git a/libev/ev++.h b/libev/ev++.h
index c9b453b..22dfcf5 100644
--- a/libev/ev++.h
+++ b/libev/ev++.h
@@ -1,7 +1,7 @@
 /*
  * libev simple C++ wrapper classes
  *
- * Copyright (c) 2007,2008,2010 Marc Alexander Lehmann <libev@schmorp.de>
+ * Copyright (c) 2007,2008,2010,2018,2020 Marc Alexander Lehmann <libev@schmorp.de>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modifica-
@@ -113,13 +113,13 @@ namespace ev {
 
   struct bad_loop
 #if EV_USE_STDEXCEPT
-  : std::runtime_error
+  : std::exception
 #endif
   {
 #if EV_USE_STDEXCEPT
-    bad_loop ()
-    : std::runtime_error ("libev event loop cannot be initialized, bad value of LIBEV_FLAGS?")
+    const char *what () const EV_NOEXCEPT
     {
+      return "libev event loop cannot be initialized, bad value of LIBEV_FLAGS?";
     }
 #endif
   };
@@ -142,14 +142,14 @@ namespace ev {
 
   struct loop_ref
   {
-    loop_ref (EV_P) throw ()
+    loop_ref (EV_P) EV_NOEXCEPT
 #if EV_MULTIPLICITY
     : EV_AX (EV_A)
 #endif
     {
     }
 
-    bool operator == (const loop_ref &other) const throw ()
+    bool operator == (const loop_ref &other) const EV_NOEXCEPT
     {
 #if EV_MULTIPLICITY
       return EV_AX == other.EV_AX;
@@ -158,7 +158,7 @@ namespace ev {
 #endif
     }
 
-    bool operator != (const loop_ref &other) const throw ()
+    bool operator != (const loop_ref &other) const EV_NOEXCEPT
     {
 #if EV_MULTIPLICITY
       return ! (*this == other);
@@ -168,27 +168,27 @@ namespace ev {
     }
 
 #if EV_MULTIPLICITY
-    bool operator == (const EV_P) const throw ()
+    bool operator == (const EV_P) const EV_NOEXCEPT
     {
       return this->EV_AX == EV_A;
     }
 
-    bool operator != (const EV_P) const throw ()
+    bool operator != (const EV_P) const EV_NOEXCEPT
     {
       return ! (*this == EV_A);
     }
 
-    operator struct ev_loop * () const throw ()
+    operator struct ev_loop * () const EV_NOEXCEPT
     {
       return EV_AX;
     }
 
-    operator const struct ev_loop * () const throw ()
+    operator const struct ev_loop * () const EV_NOEXCEPT
     {
       return EV_AX;
     }
 
-    bool is_default () const throw ()
+    bool is_default () const EV_NOEXCEPT
     {
       return EV_AX == ev_default_loop (0);
     }
@@ -200,7 +200,7 @@ namespace ev {
       ev_run (EV_AX_ flags);
     }
 
-    void unloop (how_t how = ONE) throw ()
+    void unloop (how_t how = ONE) EV_NOEXCEPT
     {
       ev_break (EV_AX_ how);
     }
@@ -211,74 +211,74 @@ namespace ev {
       ev_run (EV_AX_ flags);
     }
 
-    void break_loop (how_t how = ONE) throw ()
+    void break_loop (how_t how = ONE) EV_NOEXCEPT
     {
       ev_break (EV_AX_ how);
     }
 
-    void post_fork () throw ()
+    void post_fork () EV_NOEXCEPT
     {
       ev_loop_fork (EV_AX);
     }
 
-    unsigned int backend () const throw ()
+    unsigned int backend () const EV_NOEXCEPT
     {
       return ev_backend (EV_AX);
     }
 
-    tstamp now () const throw ()
+    tstamp now () const EV_NOEXCEPT
     {
       return ev_now (EV_AX);
     }
 
-    void ref () throw ()
+    void ref () EV_NOEXCEPT
     {
       ev_ref (EV_AX);
     }
 
-    void unref () throw ()
+    void unref () EV_NOEXCEPT
     {
       ev_unref (EV_AX);
     }
 
 #if EV_FEATURE_API
-    unsigned int iteration () const throw ()
+    unsigned int iteration () const EV_NOEXCEPT
     {
       return ev_iteration (EV_AX);
     }
 
-    unsigned int depth () const throw ()
+    unsigned int depth () const EV_NOEXCEPT
     {
       return ev_depth (EV_AX);
     }
 
-    void set_io_collect_interval (tstamp interval) throw ()
+    void set_io_collect_interval (tstamp interval) EV_NOEXCEPT
     {
       ev_set_io_collect_interval (EV_AX_ interval);
     }
 
-    void set_timeout_collect_interval (tstamp interval) throw ()
+    void set_timeout_collect_interval (tstamp interval) EV_NOEXCEPT
     {
       ev_set_timeout_collect_interval (EV_AX_ interval);
     }
 #endif
 
     // function callback
-    void once (int fd, int events, tstamp timeout, void (*cb)(int, void *), void *arg = 0) throw ()
+    void once (int fd, int events, tstamp timeout, void (*cb)(int, void *), void *arg = 0) EV_NOEXCEPT
     {
       ev_once (EV_AX_ fd, events, timeout, cb, arg);
     }
 
     // method callback
     template<class K, void (K::*method)(int)>
-    void once (int fd, int events, tstamp timeout, K *object) throw ()
+    void once (int fd, int events, tstamp timeout, K *object) EV_NOEXCEPT
     {
       once (fd, events, timeout, method_thunk<K, method>, object);
     }
 
     // default method == operator ()
     template<class K>
-    void once (int fd, int events, tstamp timeout, K *object) throw ()
+    void once (int fd, int events, tstamp timeout, K *object) EV_NOEXCEPT
     {
       once (fd, events, timeout, method_thunk<K, &K::operator ()>, object);
     }
@@ -292,7 +292,7 @@ namespace ev {
 
     // no-argument method callback
     template<class K, void (K::*method)()>
-    void once (int fd, int events, tstamp timeout, K *object) throw ()
+    void once (int fd, int events, tstamp timeout, K *object) EV_NOEXCEPT
     {
       once (fd, events, timeout, method_noargs_thunk<K, method>, object);
     }
@@ -306,7 +306,7 @@ namespace ev {
 
     // simpler function callback
     template<void (*cb)(int)>
-    void once (int fd, int events, tstamp timeout) throw ()
+    void once (int fd, int events, tstamp timeout) EV_NOEXCEPT
     {
       once (fd, events, timeout, simpler_func_thunk<cb>);
     }
@@ -320,7 +320,7 @@ namespace ev {
 
     // simplest function callback
     template<void (*cb)()>
-    void once (int fd, int events, tstamp timeout) throw ()
+    void once (int fd, int events, tstamp timeout) EV_NOEXCEPT
     {
       once (fd, events, timeout, simplest_func_thunk<cb>);
     }
@@ -332,12 +332,12 @@ namespace ev {
         ();
     }
 
-    void feed_fd_event (int fd, int revents) throw ()
+    void feed_fd_event (int fd, int revents) EV_NOEXCEPT
     {
       ev_feed_fd_event (EV_AX_ fd, revents);
     }
 
-    void feed_signal_event (int signum) throw ()
+    void feed_signal_event (int signum) EV_NOEXCEPT
     {
       ev_feed_signal_event (EV_AX_ signum);
     }
@@ -352,14 +352,14 @@ namespace ev {
   struct dynamic_loop : loop_ref
   {
 
-    dynamic_loop (unsigned int flags = AUTO) throw (bad_loop)
+    dynamic_loop (unsigned int flags = AUTO)
     : loop_ref (ev_loop_new (flags))
     {
       if (!EV_AX)
         throw bad_loop ();
     }
 
-    ~dynamic_loop () throw ()
+    ~dynamic_loop () EV_NOEXCEPT
     {
       ev_loop_destroy (EV_AX);
       EV_AX = 0;
@@ -376,7 +376,7 @@ namespace ev {
 
   struct default_loop : loop_ref
   {
-    default_loop (unsigned int flags = AUTO) throw (bad_loop)
+    default_loop (unsigned int flags = AUTO)
 #if EV_MULTIPLICITY
     : loop_ref (ev_default_loop (flags))
 #endif
@@ -396,7 +396,7 @@ namespace ev {
     default_loop &operator = (const default_loop &);
   };
 
-  inline loop_ref get_default_loop () throw ()
+  inline loop_ref get_default_loop () EV_NOEXCEPT
   {
 #if EV_MULTIPLICITY
     return ev_default_loop (0);
@@ -421,17 +421,35 @@ namespace ev {
   template<class ev_watcher, class watcher>
   struct base : ev_watcher
   {
+    // scoped pause/unpause of a watcher
+    struct freeze_guard
+    {
+      watcher &w;
+      bool active;
+
+      freeze_guard (watcher *self) EV_NOEXCEPT
+      : w (*self), active (w.is_active ())
+      {
+        if (active) w.stop ();
+      }
+
+      ~freeze_guard ()
+      {
+        if (active) w.start ();
+      }
+    };
+
     #if EV_MULTIPLICITY
       EV_PX;
 
       // loop set
-      void set (EV_P) throw ()
+      void set (EV_P) EV_NOEXCEPT
       {
         this->EV_A = EV_A;
       }
     #endif
 
-    base (EV_PX) throw ()
+    base (EV_PX) EV_NOEXCEPT
     #if EV_MULTIPLICITY
       : EV_A (EV_A)
     #endif
@@ -439,7 +457,7 @@ namespace ev {
       ev_init (this, 0);
     }
 
-    void set_ (const void *data, void (*cb)(EV_P_ ev_watcher *w, int revents)) throw ()
+    void set_ (const void *data, void (*cb)(EV_P_ ev_watcher *w, int revents)) EV_NOEXCEPT
     {
       this->data = (void *)data;
       ev_set_cb (static_cast<ev_watcher *>(this), cb);
@@ -447,7 +465,7 @@ namespace ev {
 
     // function callback
     template<void (*function)(watcher &w, int)>
-    void set (void *data = 0) throw ()
+    void set (void *data = 0) EV_NOEXCEPT
     {
       set_ (data, function_thunk<function>);
     }
@@ -461,14 +479,14 @@ namespace ev {
 
     // method callback
     template<class K, void (K::*method)(watcher &w, int)>
-    void set (K *object) throw ()
+    void set (K *object) EV_NOEXCEPT
     {
       set_ (object, method_thunk<K, method>);
     }
 
     // default method == operator ()
     template<class K>
-    void set (K *object) throw ()
+    void set (K *object) EV_NOEXCEPT
     {
       set_ (object, method_thunk<K, &K::operator ()>);
     }
@@ -482,7 +500,7 @@ namespace ev {
 
     // no-argument callback
     template<class K, void (K::*method)()>
-    void set (K *object) throw ()
+    void set (K *object) EV_NOEXCEPT
     {
       set_ (object, method_noargs_thunk<K, method>);
     }
@@ -501,76 +519,76 @@ namespace ev {
           (static_cast<ev_watcher *>(this), events);
     }
 
-    bool is_active () const throw ()
+    bool is_active () const EV_NOEXCEPT
     {
       return ev_is_active (static_cast<const ev_watcher *>(this));
     }
 
-    bool is_pending () const throw ()
+    bool is_pending () const EV_NOEXCEPT
     {
       return ev_is_pending (static_cast<const ev_watcher *>(this));
     }
 
-    void feed_event (int revents) throw ()
+    void feed_event (int revents) EV_NOEXCEPT
     {
       ev_feed_event (EV_A_ static_cast<ev_watcher *>(this), revents);
     }
   };
 
-  inline tstamp now (EV_P) throw ()
+  inline tstamp now (EV_P) EV_NOEXCEPT
   {
     return ev_now (EV_A);
   }
 
-  inline void delay (tstamp interval) throw ()
+  inline void delay (tstamp interval) EV_NOEXCEPT
   {
     ev_sleep (interval);
   }
 
-  inline int version_major () throw ()
+  inline int version_major () EV_NOEXCEPT
   {
     return ev_version_major ();
   }
 
-  inline int version_minor () throw ()
+  inline int version_minor () EV_NOEXCEPT
   {
     return ev_version_minor ();
   }
 
-  inline unsigned int supported_backends () throw ()
+  inline unsigned int supported_backends () EV_NOEXCEPT
   {
     return ev_supported_backends ();
   }
 
-  inline unsigned int recommended_backends () throw ()
+  inline unsigned int recommended_backends () EV_NOEXCEPT
   {
     return ev_recommended_backends ();
   }
 
-  inline unsigned int embeddable_backends () throw ()
+  inline unsigned int embeddable_backends () EV_NOEXCEPT
   {
     return ev_embeddable_backends ();
   }
 
-  inline void set_allocator (void *(*cb)(void *ptr, long size) throw ()) throw ()
+  inline void set_allocator (void *(*cb)(void *ptr, long size) EV_NOEXCEPT) EV_NOEXCEPT
   {
     ev_set_allocator (cb);
   }
 
-  inline void set_syserr_cb (void (*cb)(const char *msg) throw ()) throw ()
+  inline void set_syserr_cb (void (*cb)(const char *msg) EV_NOEXCEPT) EV_NOEXCEPT
   {
     ev_set_syserr_cb (cb);
   }
 
   #if EV_MULTIPLICITY
     #define EV_CONSTRUCT(cppstem,cstem)	                                                \
-      (EV_PX = get_default_loop ()) throw ()                                            \
+      (EV_PX = get_default_loop ()) EV_NOEXCEPT                                         \
         : base<ev_ ## cstem, cppstem> (EV_A)                                            \
       {                                                                                 \
       }
   #else
     #define EV_CONSTRUCT(cppstem,cstem)                                                 \
-      () throw ()                                                                       \
+      () EV_NOEXCEPT                                                                    \
       {                                                                                 \
       }
   #endif
@@ -581,19 +599,19 @@ namespace ev {
                                                                                         \
   struct cppstem : base<ev_ ## cstem, cppstem>                                          \
   {                                                                                     \
-    void start () throw ()                                                              \
+    void start () EV_NOEXCEPT                                                           \
     {                                                                                   \
       ev_ ## cstem ## _start (EV_A_ static_cast<ev_ ## cstem *>(this));                 \
     }                                                                                   \
                                                                                         \
-    void stop () throw ()                                                               \
+    void stop () EV_NOEXCEPT                                                            \
     {                                                                                   \
       ev_ ## cstem ## _stop (EV_A_ static_cast<ev_ ## cstem *>(this));                  \
     }                                                                                   \
                                                                                         \
     cppstem EV_CONSTRUCT(cppstem,cstem)                                                 \
                                                                                         \
-    ~cppstem () throw ()                                                                \
+    ~cppstem () EV_NOEXCEPT                                                             \
     {                                                                                   \
       stop ();                                                                          \
     }                                                                                   \
@@ -612,23 +630,19 @@ namespace ev {
   };
 
   EV_BEGIN_WATCHER (io, io)
-    void set (int fd, int events) throw ()
+    void set (int fd, int events) EV_NOEXCEPT
     {
-      int active = is_active ();
-      if (active) stop ();
+      freeze_guard freeze (this);
       ev_io_set (static_cast<ev_io *>(this), fd, events);
-      if (active) start ();
     }
 
-    void set (int events) throw ()
+    void set (int events) EV_NOEXCEPT
     {
-      int active = is_active ();
-      if (active) stop ();
-      ev_io_set (static_cast<ev_io *>(this), fd, events);
-      if (active) start ();
+      freeze_guard freeze (this);
+      ev_io_modify (static_cast<ev_io *>(this), events);
     }
 
-    void start (int fd, int events) throw ()
+    void start (int fd, int events) EV_NOEXCEPT
     {
       set (fd, events);
       start ();
@@ -636,21 +650,19 @@ namespace ev {
   EV_END_WATCHER (io, io)
 
   EV_BEGIN_WATCHER (timer, timer)
-    void set (ev_tstamp after, ev_tstamp repeat = 0.) throw ()
+    void set (ev_tstamp after, ev_tstamp repeat = 0.) EV_NOEXCEPT
     {
-      int active = is_active ();
-      if (active) stop ();
+      freeze_guard freeze (this);
       ev_timer_set (static_cast<ev_timer *>(this), after, repeat);
-      if (active) start ();
     }
 
-    void start (ev_tstamp after, ev_tstamp repeat = 0.) throw ()
+    void start (ev_tstamp after, ev_tstamp repeat = 0.) EV_NOEXCEPT
     {
       set (after, repeat);
       start ();
     }
 
-    void again () throw ()
+    void again () EV_NOEXCEPT
     {
       ev_timer_again (EV_A_ static_cast<ev_timer *>(this));
     }
@@ -663,21 +675,19 @@ namespace ev {
 
   #if EV_PERIODIC_ENABLE
   EV_BEGIN_WATCHER (periodic, periodic)
-    void set (ev_tstamp at, ev_tstamp interval = 0.) throw ()
+    void set (ev_tstamp at, ev_tstamp interval = 0.) EV_NOEXCEPT
     {
-      int active = is_active ();
-      if (active) stop ();
+      freeze_guard freeze (this);
       ev_periodic_set (static_cast<ev_periodic *>(this), at, interval, 0);
-      if (active) start ();
     }
 
-    void start (ev_tstamp at, ev_tstamp interval = 0.) throw ()
+    void start (ev_tstamp at, ev_tstamp interval = 0.) EV_NOEXCEPT
     {
       set (at, interval);
       start ();
     }
 
-    void again () throw ()
+    void again () EV_NOEXCEPT
     {
       ev_periodic_again (EV_A_ static_cast<ev_periodic *>(this));
     }
@@ -686,15 +696,13 @@ namespace ev {
 
   #if EV_SIGNAL_ENABLE
   EV_BEGIN_WATCHER (sig, signal)
-    void set (int signum) throw ()
+    void set (int signum) EV_NOEXCEPT
     {
-      int active = is_active ();
-      if (active) stop ();
+      freeze_guard freeze (this);
       ev_signal_set (static_cast<ev_signal *>(this), signum);
-      if (active) start ();
     }
 
-    void start (int signum) throw ()
+    void start (int signum) EV_NOEXCEPT
     {
       set (signum);
       start ();
@@ -704,15 +712,13 @@ namespace ev {
 
   #if EV_CHILD_ENABLE
   EV_BEGIN_WATCHER (child, child)
-    void set (int pid, int trace = 0) throw ()
+    void set (int pid, int trace = 0) EV_NOEXCEPT
     {
-      int active = is_active ();
-      if (active) stop ();
+      freeze_guard freeze (this);
       ev_child_set (static_cast<ev_child *>(this), pid, trace);
-      if (active) start ();
     }
 
-    void start (int pid, int trace = 0) throw ()
+    void start (int pid, int trace = 0) EV_NOEXCEPT
     {
       set (pid, trace);
       start ();
@@ -722,22 +728,20 @@ namespace ev {
 
   #if EV_STAT_ENABLE
   EV_BEGIN_WATCHER (stat, stat)
-    void set (const char *path, ev_tstamp interval = 0.) throw ()
+    void set (const char *path, ev_tstamp interval = 0.) EV_NOEXCEPT
     {
-      int active = is_active ();
-      if (active) stop ();
+      freeze_guard freeze (this);
       ev_stat_set (static_cast<ev_stat *>(this), path, interval);
-      if (active) start ();
     }
 
-    void start (const char *path, ev_tstamp interval = 0.) throw ()
+    void start (const char *path, ev_tstamp interval = 0.) EV_NOEXCEPT
     {
       stop ();
       set (path, interval);
       start ();
     }
 
-    void update () throw ()
+    void update () EV_NOEXCEPT
     {
       ev_stat_stat (EV_A_ static_cast<ev_stat *>(this));
     }
@@ -746,33 +750,31 @@ namespace ev {
 
   #if EV_IDLE_ENABLE
   EV_BEGIN_WATCHER (idle, idle)
-    void set () throw () { }
+    void set () EV_NOEXCEPT { }
   EV_END_WATCHER (idle, idle)
   #endif
 
   #if EV_PREPARE_ENABLE
   EV_BEGIN_WATCHER (prepare, prepare)
-    void set () throw () { }
+    void set () EV_NOEXCEPT { }
   EV_END_WATCHER (prepare, prepare)
   #endif
 
   #if EV_CHECK_ENABLE
   EV_BEGIN_WATCHER (check, check)
-    void set () throw () { }
+    void set () EV_NOEXCEPT { }
   EV_END_WATCHER (check, check)
   #endif
 
   #if EV_EMBED_ENABLE
   EV_BEGIN_WATCHER (embed, embed)
-    void set_embed (struct ev_loop *embedded_loop) throw ()
+    void set_embed (struct ev_loop *embedded_loop) EV_NOEXCEPT
     {
-      int active = is_active ();
-      if (active) stop ();
+      freeze_guard freeze (this);
       ev_embed_set (static_cast<ev_embed *>(this), embedded_loop);
-      if (active) start ();
     }
 
-    void start (struct ev_loop *embedded_loop) throw ()
+    void start (struct ev_loop *embedded_loop) EV_NOEXCEPT
     {
       set (embedded_loop);
       start ();
@@ -787,18 +789,18 @@ namespace ev {
 
   #if EV_FORK_ENABLE
   EV_BEGIN_WATCHER (fork, fork)
-    void set () throw () { }
+    void set () EV_NOEXCEPT { }
   EV_END_WATCHER (fork, fork)
   #endif
 
   #if EV_ASYNC_ENABLE
   EV_BEGIN_WATCHER (async, async)
-    void send () throw ()
+    void send () EV_NOEXCEPT
     {
       ev_async_send (EV_A_ static_cast<ev_async *>(this));
     }
 
-    bool async_pending () throw ()
+    bool async_pending () EV_NOEXCEPT
     {
       return ev_async_pending (static_cast<ev_async *>(this));
     }
diff --git a/libev/ev.3 b/libev/ev.3
deleted file mode 100644
index 9d6b203..0000000
--- a/libev/ev.3
+++ /dev/null
@@ -1,5647 +0,0 @@
-.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
-.\"
-.\" Standard preamble:
-.\" ========================================================================
-.de Sp \" Vertical space (when we can't use .PP)
-.if t .sp .5v
-.if n .sp
-..
-.de Vb \" Begin verbatim text
-.ft CW
-.nf
-.ne \\$1
-..
-.de Ve \" End verbatim text
-.ft R
-.fi
-..
-.\" Set up some character translations and predefined strings.  \*(-- will
-.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
-.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
-.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
-.\" nothing in troff, for use with C<>.
-.tr \(*W-
-.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
-.ie n \{\
-.    ds -- \(*W-
-.    ds PI pi
-.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
-.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
-.    ds L" ""
-.    ds R" ""
-.    ds C` ""
-.    ds C' ""
-'br\}
-.el\{\
-.    ds -- \|\(em\|
-.    ds PI \(*p
-.    ds L" ``
-.    ds R" ''
-.    ds C`
-.    ds C'
-'br\}
-.\"
-.\" Escape single quotes in literal strings from groff's Unicode transform.
-.ie \n(.g .ds Aq \(aq
-.el       .ds Aq '
-.\"
-.\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
-.\" entries marked with X<> in POD.  Of course, you'll have to process the
-.\" output yourself in some meaningful fashion.
-.\"
-.\" Avoid warning from groff about undefined register 'F'.
-.de IX
-..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{
-.    if \nF \{
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
-..
-.        if !\nF==2 \{
-.            nr % 0
-.            nr F 2
-.        \}
-.    \}
-.\}
-.rr rF
-.\"
-.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
-.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
-.    \" fudge factors for nroff and troff
-.if n \{\
-.    ds #H 0
-.    ds #V .8m
-.    ds #F .3m
-.    ds #[ \f1
-.    ds #] \fP
-.\}
-.if t \{\
-.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
-.    ds #V .6m
-.    ds #F 0
-.    ds #[ \&
-.    ds #] \&
-.\}
-.    \" simple accents for nroff and troff
-.if n \{\
-.    ds ' \&
-.    ds ` \&
-.    ds ^ \&
-.    ds , \&
-.    ds ~ ~
-.    ds /
-.\}
-.if t \{\
-.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
-.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
-.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
-.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
-.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
-.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
-.\}
-.    \" troff and (daisy-wheel) nroff accents
-.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
-.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
-.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
-.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
-.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
-.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
-.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
-.ds ae a\h'-(\w'a'u*4/10)'e
-.ds Ae A\h'-(\w'A'u*4/10)'E
-.    \" corrections for vroff
-.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
-.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
-.    \" for low resolution devices (crt and lpr)
-.if \n(.H>23 .if \n(.V>19 \
-\{\
-.    ds : e
-.    ds 8 ss
-.    ds o a
-.    ds d- d\h'-1'\(ga
-.    ds D- D\h'-1'\(hy
-.    ds th \o'bp'
-.    ds Th \o'LP'
-.    ds ae ae
-.    ds Ae AE
-.\}
-.rm #[ #] #H #V #F C
-.\" ========================================================================
-.\"
-.IX Title "LIBEV 3"
-.TH LIBEV 3 "2017-06-21" "libev-4.24" "libev - high performance full featured event loop"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.if n .ad l
-.nh
-.SH "NAME"
-libev \- a high performance full\-featured event loop written in C
-.SH "SYNOPSIS"
-.IX Header "SYNOPSIS"
-.Vb 1
-\&   #include <ev.h>
-.Ve
-.SS "\s-1EXAMPLE PROGRAM\s0"
-.IX Subsection "EXAMPLE PROGRAM"
-.Vb 2
-\&   // a single header file is required
-\&   #include <ev.h>
-\&
-\&   #include <stdio.h> // for puts
-\&
-\&   // every watcher type has its own typedef\*(Aqd struct
-\&   // with the name ev_TYPE
-\&   ev_io stdin_watcher;
-\&   ev_timer timeout_watcher;
-\&
-\&   // all watcher callbacks have a similar signature
-\&   // this callback is called when data is readable on stdin
-\&   static void
-\&   stdin_cb (EV_P_ ev_io *w, int revents)
-\&   {
-\&     puts ("stdin ready");
-\&     // for one\-shot events, one must manually stop the watcher
-\&     // with its corresponding stop function.
-\&     ev_io_stop (EV_A_ w);
-\&
-\&     // this causes all nested ev_run\*(Aqs to stop iterating
-\&     ev_break (EV_A_ EVBREAK_ALL);
-\&   }
-\&
-\&   // another callback, this time for a time\-out
-\&   static void
-\&   timeout_cb (EV_P_ ev_timer *w, int revents)
-\&   {
-\&     puts ("timeout");
-\&     // this causes the innermost ev_run to stop iterating
-\&     ev_break (EV_A_ EVBREAK_ONE);
-\&   }
-\&
-\&   int
-\&   main (void)
-\&   {
-\&     // use the default event loop unless you have special needs
-\&     struct ev_loop *loop = EV_DEFAULT;
-\&
-\&     // initialise an io watcher, then start it
-\&     // this one will watch for stdin to become readable
-\&     ev_io_init (&stdin_watcher, stdin_cb, /*STDIN_FILENO*/ 0, EV_READ);
-\&     ev_io_start (loop, &stdin_watcher);
-\&
-\&     // initialise a timer watcher, then start it
-\&     // simple non\-repeating 5.5 second timeout
-\&     ev_timer_init (&timeout_watcher, timeout_cb, 5.5, 0.);
-\&     ev_timer_start (loop, &timeout_watcher);
-\&
-\&     // now wait for events to arrive
-\&     ev_run (loop, 0);
-\&
-\&     // break was called, so exit
-\&     return 0;
-\&   }
-.Ve
-.SH "ABOUT THIS DOCUMENT"
-.IX Header "ABOUT THIS DOCUMENT"
-This document documents the libev software package.
-.PP
-The newest version of this document is also available as an html-formatted
-web page you might find easier to navigate when reading it for the first
-time: <http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod>.
-.PP
-While this document tries to be as complete as possible in documenting
-libev, its usage and the rationale behind its design, it is not a tutorial
-on event-based programming, nor will it introduce event-based programming
-with libev.
-.PP
-Familiarity with event based programming techniques in general is assumed
-throughout this document.
-.SH "WHAT TO READ WHEN IN A HURRY"
-.IX Header "WHAT TO READ WHEN IN A HURRY"
-This manual tries to be very detailed, but unfortunately, this also makes
-it very long. If you just want to know the basics of libev, I suggest
-reading \*(L"\s-1ANATOMY OF A WATCHER\*(R"\s0, then the \*(L"\s-1EXAMPLE PROGRAM\*(R"\s0 above and
-look up the missing functions in \*(L"\s-1GLOBAL FUNCTIONS\*(R"\s0 and the \f(CW\*(C`ev_io\*(C'\fR and
-\&\f(CW\*(C`ev_timer\*(C'\fR sections in \*(L"\s-1WATCHER TYPES\*(R"\s0.
-.SH "ABOUT LIBEV"
-.IX Header "ABOUT LIBEV"
-Libev is an event loop: you register interest in certain events (such as a
-file descriptor being readable or a timeout occurring), and it will manage
-these event sources and provide your program with events.
-.PP
-To do this, it must take more or less complete control over your process
-(or thread) by executing the \fIevent loop\fR handler, and will then
-communicate events via a callback mechanism.
-.PP
-You register interest in certain events by registering so-called \fIevent
-watchers\fR, which are relatively small C structures you initialise with the
-details of the event, and then hand it over to libev by \fIstarting\fR the
-watcher.
-.SS "\s-1FEATURES\s0"
-.IX Subsection "FEATURES"
-Libev supports \f(CW\*(C`select\*(C'\fR, \f(CW\*(C`poll\*(C'\fR, the Linux-specific \f(CW\*(C`epoll\*(C'\fR, the
-BSD-specific \f(CW\*(C`kqueue\*(C'\fR and the Solaris-specific event port mechanisms
-for file descriptor events (\f(CW\*(C`ev_io\*(C'\fR), the Linux \f(CW\*(C`inotify\*(C'\fR interface
-(for \f(CW\*(C`ev_stat\*(C'\fR), Linux eventfd/signalfd (for faster and cleaner
-inter-thread wakeup (\f(CW\*(C`ev_async\*(C'\fR)/signal handling (\f(CW\*(C`ev_signal\*(C'\fR)) relative
-timers (\f(CW\*(C`ev_timer\*(C'\fR), absolute timers with customised rescheduling
-(\f(CW\*(C`ev_periodic\*(C'\fR), synchronous signals (\f(CW\*(C`ev_signal\*(C'\fR), process status
-change events (\f(CW\*(C`ev_child\*(C'\fR), and event watchers dealing with the event
-loop mechanism itself (\f(CW\*(C`ev_idle\*(C'\fR, \f(CW\*(C`ev_embed\*(C'\fR, \f(CW\*(C`ev_prepare\*(C'\fR and
-\&\f(CW\*(C`ev_check\*(C'\fR watchers) as well as file watchers (\f(CW\*(C`ev_stat\*(C'\fR) and even
-limited support for fork events (\f(CW\*(C`ev_fork\*(C'\fR).
-.PP
-It also is quite fast (see this
-benchmark <http://libev.schmorp.de/bench.html> comparing it to libevent
-for example).
-.SS "\s-1CONVENTIONS\s0"
-.IX Subsection "CONVENTIONS"
-Libev is very configurable. In this manual the default (and most common)
-configuration will be described, which supports multiple event loops. For
-more info about various configuration options please have a look at
-\&\fB\s-1EMBED\s0\fR section in this manual. If libev was configured without support
-for multiple event loops, then all functions taking an initial argument of
-name \f(CW\*(C`loop\*(C'\fR (which is always of type \f(CW\*(C`struct ev_loop *\*(C'\fR) will not have
-this argument.
-.SS "\s-1TIME REPRESENTATION\s0"
-.IX Subsection "TIME REPRESENTATION"
-Libev represents time as a single floating point number, representing
-the (fractional) number of seconds since the (\s-1POSIX\s0) epoch (in practice
-somewhere near the beginning of 1970, details are complicated, don't
-ask). This type is called \f(CW\*(C`ev_tstamp\*(C'\fR, which is what you should use
-too. It usually aliases to the \f(CW\*(C`double\*(C'\fR type in C. When you need to do
-any calculations on it, you should treat it as some floating point value.
-.PP
-Unlike the name component \f(CW\*(C`stamp\*(C'\fR might indicate, it is also used for
-time differences (e.g. delays) throughout libev.
-.SH "ERROR HANDLING"
-.IX Header "ERROR HANDLING"
-Libev knows three classes of errors: operating system errors, usage errors
-and internal errors (bugs).
-.PP
-When libev catches an operating system error it cannot handle (for example
-a system call indicating a condition libev cannot fix), it calls the callback
-set via \f(CW\*(C`ev_set_syserr_cb\*(C'\fR, which is supposed to fix the problem or
-abort. The default is to print a diagnostic message and to call \f(CW\*(C`abort
-()\*(C'\fR.
-.PP
-When libev detects a usage error such as a negative timer interval, then
-it will print a diagnostic message and abort (via the \f(CW\*(C`assert\*(C'\fR mechanism,
-so \f(CW\*(C`NDEBUG\*(C'\fR will disable this checking): these are programming errors in
-the libev caller and need to be fixed there.
-.PP
-Libev also has a few internal error-checking \f(CW\*(C`assert\*(C'\fRions, and also has
-extensive consistency checking code. These do not trigger under normal
-circumstances, as they indicate either a bug in libev or worse.
-.SH "GLOBAL FUNCTIONS"
-.IX Header "GLOBAL FUNCTIONS"
-These functions can be called anytime, even before initialising the
-library in any way.
-.IP "ev_tstamp ev_time ()" 4
-.IX Item "ev_tstamp ev_time ()"
-Returns the current time as libev would use it. Please note that the
-\&\f(CW\*(C`ev_now\*(C'\fR function is usually faster and also often returns the timestamp
-you actually want to know. Also interesting is the combination of
-\&\f(CW\*(C`ev_now_update\*(C'\fR and \f(CW\*(C`ev_now\*(C'\fR.
-.IP "ev_sleep (ev_tstamp interval)" 4
-.IX Item "ev_sleep (ev_tstamp interval)"
-Sleep for the given interval: The current thread will be blocked
-until either it is interrupted or the given time interval has
-passed (approximately \- it might return a bit earlier even if not
-interrupted). Returns immediately if \f(CW\*(C`interval <= 0\*(C'\fR.
-.Sp
-Basically this is a sub-second-resolution \f(CW\*(C`sleep ()\*(C'\fR.
-.Sp
-The range of the \f(CW\*(C`interval\*(C'\fR is limited \- libev only guarantees to work
-with sleep times of up to one day (\f(CW\*(C`interval <= 86400\*(C'\fR).
-.IP "int ev_version_major ()" 4
-.IX Item "int ev_version_major ()"
-.PD 0
-.IP "int ev_version_minor ()" 4
-.IX Item "int ev_version_minor ()"
-.PD
-You can find out the major and minor \s-1ABI\s0 version numbers of the library
-you linked against by calling the functions \f(CW\*(C`ev_version_major\*(C'\fR and
-\&\f(CW\*(C`ev_version_minor\*(C'\fR. If you want, you can compare against the global
-symbols \f(CW\*(C`EV_VERSION_MAJOR\*(C'\fR and \f(CW\*(C`EV_VERSION_MINOR\*(C'\fR, which specify the
-version of the library your program was compiled against.
-.Sp
-These version numbers refer to the \s-1ABI\s0 version of the library, not the
-release version.
-.Sp
-Usually, it's a good idea to terminate if the major versions mismatch,
-as this indicates an incompatible change. Minor versions are usually
-compatible to older versions, so a larger minor version alone is usually
-not a problem.
-.Sp
-Example: Make sure we haven't accidentally been linked against the wrong
-version (note, however, that this will not detect other \s-1ABI\s0 mismatches,
-such as \s-1LFS\s0 or reentrancy).
-.Sp
-.Vb 3
-\&   assert (("libev version mismatch",
-\&            ev_version_major () == EV_VERSION_MAJOR
-\&            && ev_version_minor () >= EV_VERSION_MINOR));
-.Ve
-.IP "unsigned int ev_supported_backends ()" 4
-.IX Item "unsigned int ev_supported_backends ()"
-Return the set of all backends (i.e. their corresponding \f(CW\*(C`EV_BACKEND_*\*(C'\fR
-value) compiled into this binary of libev (independent of their
-availability on the system you are running on). See \f(CW\*(C`ev_default_loop\*(C'\fR for
-a description of the set values.
-.Sp
-Example: make sure we have the epoll method, because yeah this is cool and
-a must have and can we have a torrent of it please!!!11
-.Sp
-.Vb 2
-\&   assert (("sorry, no epoll, no sex",
-\&            ev_supported_backends () & EVBACKEND_EPOLL));
-.Ve
-.IP "unsigned int ev_recommended_backends ()" 4
-.IX Item "unsigned int ev_recommended_backends ()"
-Return the set of all backends compiled into this binary of libev and
-also recommended for this platform, meaning it will work for most file
-descriptor types. This set is often smaller than the one returned by
-\&\f(CW\*(C`ev_supported_backends\*(C'\fR, as for example kqueue is broken on most BSDs
-and will not be auto-detected unless you explicitly request it (assuming
-you know what you are doing). This is the set of backends that libev will
-probe for if you specify no backends explicitly.
-.IP "unsigned int ev_embeddable_backends ()" 4
-.IX Item "unsigned int ev_embeddable_backends ()"
-Returns the set of backends that are embeddable in other event loops. This
-value is platform-specific but can include backends not available on the
-current system. To find which embeddable backends might be supported on
-the current system, you would need to look at \f(CW\*(C`ev_embeddable_backends ()
-& ev_supported_backends ()\*(C'\fR, likewise for recommended ones.
-.Sp
-See the description of \f(CW\*(C`ev_embed\*(C'\fR watchers for more info.
-.IP "ev_set_allocator (void *(*cb)(void *ptr, long size) throw ())" 4
-.IX Item "ev_set_allocator (void *(*cb)(void *ptr, long size) throw ())"
-Sets the allocation function to use (the prototype is similar \- the
-semantics are identical to the \f(CW\*(C`realloc\*(C'\fR C89/SuS/POSIX function). It is
-used to allocate and free memory (no surprises here). If it returns zero
-when memory needs to be allocated (\f(CW\*(C`size != 0\*(C'\fR), the library might abort
-or take some potentially destructive action.
-.Sp
-Since some systems (at least OpenBSD and Darwin) fail to implement
-correct \f(CW\*(C`realloc\*(C'\fR semantics, libev will use a wrapper around the system
-\&\f(CW\*(C`realloc\*(C'\fR and \f(CW\*(C`free\*(C'\fR functions by default.
-.Sp
-You could override this function in high-availability programs to, say,
-free some memory if it cannot allocate memory, to use a special allocator,
-or even to sleep a while and retry until some memory is available.
-.Sp
-Example: Replace the libev allocator with one that waits a bit and then
-retries (example requires a standards-compliant \f(CW\*(C`realloc\*(C'\fR).
-.Sp
-.Vb 6
-\&   static void *
-\&   persistent_realloc (void *ptr, size_t size)
-\&   {
-\&     for (;;)
-\&       {
-\&         void *newptr = realloc (ptr, size);
-\&
-\&         if (newptr)
-\&           return newptr;
-\&
-\&         sleep (60);
-\&       }
-\&   }
-\&
-\&   ...
-\&   ev_set_allocator (persistent_realloc);
-.Ve
-.IP "ev_set_syserr_cb (void (*cb)(const char *msg) throw ())" 4
-.IX Item "ev_set_syserr_cb (void (*cb)(const char *msg) throw ())"
-Set the callback function to call on a retryable system call error (such
-as failed select, poll, epoll_wait). The message is a printable string
-indicating the system call or subsystem causing the problem. If this
-callback is set, then libev will expect it to remedy the situation, no
-matter what, when it returns. That is, libev will generally retry the
-requested operation, or, if the condition doesn't go away, do bad stuff
-(such as abort).
-.Sp
-Example: This is basically the same thing that libev does internally, too.
-.Sp
-.Vb 6
-\&   static void
-\&   fatal_error (const char *msg)
-\&   {
-\&     perror (msg);
-\&     abort ();
-\&   }
-\&
-\&   ...
-\&   ev_set_syserr_cb (fatal_error);
-.Ve
-.IP "ev_feed_signal (int signum)" 4
-.IX Item "ev_feed_signal (int signum)"
-This function can be used to \*(L"simulate\*(R" a signal receive. It is completely
-safe to call this function at any time, from any context, including signal
-handlers or random threads.
-.Sp
-Its main use is to customise signal handling in your process, especially
-in the presence of threads. For example, you could block signals
-by default in all threads (and specifying \f(CW\*(C`EVFLAG_NOSIGMASK\*(C'\fR when
-creating any loops), and in one thread, use \f(CW\*(C`sigwait\*(C'\fR or any other
-mechanism to wait for signals, then \*(L"deliver\*(R" them to libev by calling
-\&\f(CW\*(C`ev_feed_signal\*(C'\fR.
-.SH "FUNCTIONS CONTROLLING EVENT LOOPS"
-.IX Header "FUNCTIONS CONTROLLING EVENT LOOPS"
-An event loop is described by a \f(CW\*(C`struct ev_loop *\*(C'\fR (the \f(CW\*(C`struct\*(C'\fR is
-\&\fInot\fR optional in this case unless libev 3 compatibility is disabled, as
-libev 3 had an \f(CW\*(C`ev_loop\*(C'\fR function colliding with the struct name).
-.PP
-The library knows two types of such loops, the \fIdefault\fR loop, which
-supports child process events, and dynamically created event loops which
-do not.
-.IP "struct ev_loop *ev_default_loop (unsigned int flags)" 4
-.IX Item "struct ev_loop *ev_default_loop (unsigned int flags)"
-This returns the \*(L"default\*(R" event loop object, which is what you should
-normally use when you just need \*(L"the event loop\*(R". Event loop objects and
-the \f(CW\*(C`flags\*(C'\fR parameter are described in more detail in the entry for
-\&\f(CW\*(C`ev_loop_new\*(C'\fR.
-.Sp
-If the default loop is already initialised then this function simply
-returns it (and ignores the flags. If that is troubling you, check
-\&\f(CW\*(C`ev_backend ()\*(C'\fR afterwards). Otherwise it will create it with the given
-flags, which should almost always be \f(CW0\fR, unless the caller is also the
-one calling \f(CW\*(C`ev_run\*(C'\fR or otherwise qualifies as \*(L"the main program\*(R".
-.Sp
-If you don't know what event loop to use, use the one returned from this
-function (or via the \f(CW\*(C`EV_DEFAULT\*(C'\fR macro).
-.Sp
-Note that this function is \fInot\fR thread-safe, so if you want to use it
-from multiple threads, you have to employ some kind of mutex (note also
-that this case is unlikely, as loops cannot be shared easily between
-threads anyway).
-.Sp
-The default loop is the only loop that can handle \f(CW\*(C`ev_child\*(C'\fR watchers,
-and to do this, it always registers a handler for \f(CW\*(C`SIGCHLD\*(C'\fR. If this is
-a problem for your application you can either create a dynamic loop with
-\&\f(CW\*(C`ev_loop_new\*(C'\fR which doesn't do that, or you can simply overwrite the
-\&\f(CW\*(C`SIGCHLD\*(C'\fR signal handler \fIafter\fR calling \f(CW\*(C`ev_default_init\*(C'\fR.
-.Sp
-Example: This is the most typical usage.
-.Sp
-.Vb 2
-\&   if (!ev_default_loop (0))
-\&     fatal ("could not initialise libev, bad $LIBEV_FLAGS in environment?");
-.Ve
-.Sp
-Example: Restrict libev to the select and poll backends, and do not allow
-environment settings to be taken into account:
-.Sp
-.Vb 1
-\&   ev_default_loop (EVBACKEND_POLL | EVBACKEND_SELECT | EVFLAG_NOENV);
-.Ve
-.IP "struct ev_loop *ev_loop_new (unsigned int flags)" 4
-.IX Item "struct ev_loop *ev_loop_new (unsigned int flags)"
-This will create and initialise a new event loop object. If the loop
-could not be initialised, returns false.
-.Sp
-This function is thread-safe, and one common way to use libev with
-threads is indeed to create one loop per thread, and using the default
-loop in the \*(L"main\*(R" or \*(L"initial\*(R" thread.
-.Sp
-The flags argument can be used to specify special behaviour or specific
-backends to use, and is usually specified as \f(CW0\fR (or \f(CW\*(C`EVFLAG_AUTO\*(C'\fR).
-.Sp
-The following flags are supported:
-.RS 4
-.ie n .IP """EVFLAG_AUTO""" 4
-.el .IP "\f(CWEVFLAG_AUTO\fR" 4
-.IX Item "EVFLAG_AUTO"
-The default flags value. Use this if you have no clue (it's the right
-thing, believe me).
-.ie n .IP """EVFLAG_NOENV""" 4
-.el .IP "\f(CWEVFLAG_NOENV\fR" 4
-.IX Item "EVFLAG_NOENV"
-If this flag bit is or'ed into the flag value (or the program runs setuid
-or setgid) then libev will \fInot\fR look at the environment variable
-\&\f(CW\*(C`LIBEV_FLAGS\*(C'\fR. Otherwise (the default), this environment variable will
-override the flags completely if it is found in the environment. This is
-useful to try out specific backends to test their performance, to work
-around bugs, or to make libev threadsafe (accessing environment variables
-cannot be done in a threadsafe way, but usually it works if no other
-thread modifies them).
-.ie n .IP """EVFLAG_FORKCHECK""" 4
-.el .IP "\f(CWEVFLAG_FORKCHECK\fR" 4
-.IX Item "EVFLAG_FORKCHECK"
-Instead of calling \f(CW\*(C`ev_loop_fork\*(C'\fR manually after a fork, you can also
-make libev check for a fork in each iteration by enabling this flag.
-.Sp
-This works by calling \f(CW\*(C`getpid ()\*(C'\fR on every iteration of the loop,
-and thus this might slow down your event loop if you do a lot of loop
-iterations and little real work, but is usually not noticeable (on my
-GNU/Linux system for example, \f(CW\*(C`getpid\*(C'\fR is actually a simple 5\-insn sequence
-without a system call and thus \fIvery\fR fast, but my GNU/Linux system also has
-\&\f(CW\*(C`pthread_atfork\*(C'\fR which is even faster).
-.Sp
-The big advantage of this flag is that you can forget about fork (and
-forget about forgetting to tell libev about forking, although you still
-have to ignore \f(CW\*(C`SIGPIPE\*(C'\fR) when you use this flag.
-.Sp
-This flag setting cannot be overridden or specified in the \f(CW\*(C`LIBEV_FLAGS\*(C'\fR
-environment variable.
-.ie n .IP """EVFLAG_NOINOTIFY""" 4
-.el .IP "\f(CWEVFLAG_NOINOTIFY\fR" 4
-.IX Item "EVFLAG_NOINOTIFY"
-When this flag is specified, then libev will not attempt to use the
-\&\fIinotify\fR \s-1API\s0 for its \f(CW\*(C`ev_stat\*(C'\fR watchers. Apart from debugging and
-testing, this flag can be useful to conserve inotify file descriptors, as
-otherwise each loop using \f(CW\*(C`ev_stat\*(C'\fR watchers consumes one inotify handle.
-.ie n .IP """EVFLAG_SIGNALFD""" 4
-.el .IP "\f(CWEVFLAG_SIGNALFD\fR" 4
-.IX Item "EVFLAG_SIGNALFD"
-When this flag is specified, then libev will attempt to use the
-\&\fIsignalfd\fR \s-1API\s0 for its \f(CW\*(C`ev_signal\*(C'\fR (and \f(CW\*(C`ev_child\*(C'\fR) watchers. This \s-1API\s0
-delivers signals synchronously, which makes it both faster and might make
-it possible to get the queued signal data. It can also simplify signal
-handling with threads, as long as you properly block signals in your
-threads that are not interested in handling them.
-.Sp
-Signalfd will not be used by default as this changes your signal mask, and
-there are a lot of shoddy libraries and programs (glib's threadpool for
-example) that can't properly initialise their signal masks.
-.ie n .IP """EVFLAG_NOSIGMASK""" 4
-.el .IP "\f(CWEVFLAG_NOSIGMASK\fR" 4
-.IX Item "EVFLAG_NOSIGMASK"
-When this flag is specified, then libev will avoid to modify the signal
-mask. Specifically, this means you have to make sure signals are unblocked
-when you want to receive them.
-.Sp
-This behaviour is useful when you want to do your own signal handling, or
-want to handle signals only in specific threads and want to avoid libev
-unblocking the signals.
-.Sp
-It's also required by \s-1POSIX\s0 in a threaded program, as libev calls
-\&\f(CW\*(C`sigprocmask\*(C'\fR, whose behaviour is officially unspecified.
-.Sp
-This flag's behaviour will become the default in future versions of libev.
-.ie n .IP """EVBACKEND_SELECT""  (value 1, portable select backend)" 4
-.el .IP "\f(CWEVBACKEND_SELECT\fR  (value 1, portable select backend)" 4
-.IX Item "EVBACKEND_SELECT (value 1, portable select backend)"
-This is your standard \fIselect\fR\|(2) backend. Not \fIcompletely\fR standard, as
-libev tries to roll its own fd_set with no limits on the number of fds,
-but if that fails, expect a fairly low limit on the number of fds when
-using this backend. It doesn't scale too well (O(highest_fd)), but its
-usually the fastest backend for a low number of (low-numbered :) fds.
-.Sp
-To get good performance out of this backend you need a high amount of
-parallelism (most of the file descriptors should be busy). If you are
-writing a server, you should \f(CW\*(C`accept ()\*(C'\fR in a loop to accept as many
-connections as possible during one iteration. You might also want to have
-a look at \f(CW\*(C`ev_set_io_collect_interval ()\*(C'\fR to increase the amount of
-readiness notifications you get per iteration.
-.Sp
-This backend maps \f(CW\*(C`EV_READ\*(C'\fR to the \f(CW\*(C`readfds\*(C'\fR set and \f(CW\*(C`EV_WRITE\*(C'\fR to the
-\&\f(CW\*(C`writefds\*(C'\fR set (and to work around Microsoft Windows bugs, also onto the
-\&\f(CW\*(C`exceptfds\*(C'\fR set on that platform).
-.ie n .IP """EVBACKEND_POLL""    (value 2, poll backend, available everywhere except on windows)" 4
-.el .IP "\f(CWEVBACKEND_POLL\fR    (value 2, poll backend, available everywhere except on windows)" 4
-.IX Item "EVBACKEND_POLL (value 2, poll backend, available everywhere except on windows)"
-And this is your standard \fIpoll\fR\|(2) backend. It's more complicated
-than select, but handles sparse fds better and has no artificial
-limit on the number of fds you can use (except it will slow down
-considerably with a lot of inactive fds). It scales similarly to select,
-i.e. O(total_fds). See the entry for \f(CW\*(C`EVBACKEND_SELECT\*(C'\fR, above, for
-performance tips.
-.Sp
-This backend maps \f(CW\*(C`EV_READ\*(C'\fR to \f(CW\*(C`POLLIN | POLLERR | POLLHUP\*(C'\fR, and
-\&\f(CW\*(C`EV_WRITE\*(C'\fR to \f(CW\*(C`POLLOUT | POLLERR | POLLHUP\*(C'\fR.
-.ie n .IP """EVBACKEND_EPOLL""   (value 4, Linux)" 4
-.el .IP "\f(CWEVBACKEND_EPOLL\fR   (value 4, Linux)" 4
-.IX Item "EVBACKEND_EPOLL (value 4, Linux)"
-Use the linux-specific \fIepoll\fR\|(7) interface (for both pre\- and post\-2.6.9
-kernels).
-.Sp
-For few fds, this backend is a bit little slower than poll and select, but
-it scales phenomenally better. While poll and select usually scale like
-O(total_fds) where total_fds is the total number of fds (or the highest
-fd), epoll scales either O(1) or O(active_fds).
-.Sp
-The epoll mechanism deserves honorable mention as the most misdesigned
-of the more advanced event mechanisms: mere annoyances include silently
-dropping file descriptors, requiring a system call per change per file
-descriptor (and unnecessary guessing of parameters), problems with dup,
-returning before the timeout value, resulting in additional iterations
-(and only giving 5ms accuracy while select on the same platform gives
-0.1ms) and so on. The biggest issue is fork races, however \- if a program
-forks then \fIboth\fR parent and child process have to recreate the epoll
-set, which can take considerable time (one syscall per file descriptor)
-and is of course hard to detect.
-.Sp
-Epoll is also notoriously buggy \- embedding epoll fds \fIshould\fR work,
-but of course \fIdoesn't\fR, and epoll just loves to report events for
-totally \fIdifferent\fR file descriptors (even already closed ones, so
-one cannot even remove them from the set) than registered in the set
-(especially on \s-1SMP\s0 systems). Libev tries to counter these spurious
-notifications by employing an additional generation counter and comparing
-that against the events to filter out spurious ones, recreating the set
-when required. Epoll also erroneously rounds down timeouts, but gives you
-no way to know when and by how much, so sometimes you have to busy-wait
-because epoll returns immediately despite a nonzero timeout. And last
-not least, it also refuses to work with some file descriptors which work
-perfectly fine with \f(CW\*(C`select\*(C'\fR (files, many character devices...).
-.Sp
-Epoll is truly the train wreck among event poll mechanisms, a frankenpoll,
-cobbled together in a hurry, no thought to design or interaction with
-others. Oh, the pain, will it ever stop...
-.Sp
-While stopping, setting and starting an I/O watcher in the same iteration
-will result in some caching, there is still a system call per such
-incident (because the same \fIfile descriptor\fR could point to a different
-\&\fIfile description\fR now), so its best to avoid that. Also, \f(CW\*(C`dup ()\*(C'\fR'ed
-file descriptors might not work very well if you register events for both
-file descriptors.
-.Sp
-Best performance from this backend is achieved by not unregistering all
-watchers for a file descriptor until it has been closed, if possible,
-i.e. keep at least one watcher active per fd at all times. Stopping and
-starting a watcher (without re-setting it) also usually doesn't cause
-extra overhead. A fork can both result in spurious notifications as well
-as in libev having to destroy and recreate the epoll object, which can
-take considerable time and thus should be avoided.
-.Sp
-All this means that, in practice, \f(CW\*(C`EVBACKEND_SELECT\*(C'\fR can be as fast or
-faster than epoll for maybe up to a hundred file descriptors, depending on
-the usage. So sad.
-.Sp
-While nominally embeddable in other event loops, this feature is broken in
-all kernel versions tested so far.
-.Sp
-This backend maps \f(CW\*(C`EV_READ\*(C'\fR and \f(CW\*(C`EV_WRITE\*(C'\fR in the same way as
-\&\f(CW\*(C`EVBACKEND_POLL\*(C'\fR.
-.ie n .IP """EVBACKEND_KQUEUE""  (value 8, most \s-1BSD\s0 clones)" 4
-.el .IP "\f(CWEVBACKEND_KQUEUE\fR  (value 8, most \s-1BSD\s0 clones)" 4
-.IX Item "EVBACKEND_KQUEUE (value 8, most BSD clones)"
-Kqueue deserves special mention, as at the time of this writing, it
-was broken on all BSDs except NetBSD (usually it doesn't work reliably
-with anything but sockets and pipes, except on Darwin, where of course
-it's completely useless). Unlike epoll, however, whose brokenness
-is by design, these kqueue bugs can (and eventually will) be fixed
-without \s-1API\s0 changes to existing programs. For this reason it's not being
-\&\*(L"auto-detected\*(R" unless you explicitly specify it in the flags (i.e. using
-\&\f(CW\*(C`EVBACKEND_KQUEUE\*(C'\fR) or libev was compiled on a known-to-be-good (\-enough)
-system like NetBSD.
-.Sp
-You still can embed kqueue into a normal poll or select backend and use it
-only for sockets (after having made sure that sockets work with kqueue on
-the target platform). See \f(CW\*(C`ev_embed\*(C'\fR watchers for more info.
-.Sp
-It scales in the same way as the epoll backend, but the interface to the
-kernel is more efficient (which says nothing about its actual speed, of
-course). While stopping, setting and starting an I/O watcher does never
-cause an extra system call as with \f(CW\*(C`EVBACKEND_EPOLL\*(C'\fR, it still adds up to
-two event changes per incident. Support for \f(CW\*(C`fork ()\*(C'\fR is very bad (you
-might have to leak fd's on fork, but it's more sane than epoll) and it
-drops fds silently in similarly hard-to-detect cases.
-.Sp
-This backend usually performs well under most conditions.
-.Sp
-While nominally embeddable in other event loops, this doesn't work
-everywhere, so you might need to test for this. And since it is broken
-almost everywhere, you should only use it when you have a lot of sockets
-(for which it usually works), by embedding it into another event loop
-(e.g. \f(CW\*(C`EVBACKEND_SELECT\*(C'\fR or \f(CW\*(C`EVBACKEND_POLL\*(C'\fR (but \f(CW\*(C`poll\*(C'\fR is of course
-also broken on \s-1OS X\s0)) and, did I mention it, using it only for sockets.
-.Sp
-This backend maps \f(CW\*(C`EV_READ\*(C'\fR into an \f(CW\*(C`EVFILT_READ\*(C'\fR kevent with
-\&\f(CW\*(C`NOTE_EOF\*(C'\fR, and \f(CW\*(C`EV_WRITE\*(C'\fR into an \f(CW\*(C`EVFILT_WRITE\*(C'\fR kevent with
-\&\f(CW\*(C`NOTE_EOF\*(C'\fR.
-.ie n .IP """EVBACKEND_DEVPOLL"" (value 16, Solaris 8)" 4
-.el .IP "\f(CWEVBACKEND_DEVPOLL\fR (value 16, Solaris 8)" 4
-.IX Item "EVBACKEND_DEVPOLL (value 16, Solaris 8)"
-This is not implemented yet (and might never be, unless you send me an
-implementation). According to reports, \f(CW\*(C`/dev/poll\*(C'\fR only supports sockets
-and is not embeddable, which would limit the usefulness of this backend
-immensely.
-.ie n .IP """EVBACKEND_PORT""    (value 32, Solaris 10)" 4
-.el .IP "\f(CWEVBACKEND_PORT\fR    (value 32, Solaris 10)" 4
-.IX Item "EVBACKEND_PORT (value 32, Solaris 10)"
-This uses the Solaris 10 event port mechanism. As with everything on Solaris,
-it's really slow, but it still scales very well (O(active_fds)).
-.Sp
-While this backend scales well, it requires one system call per active
-file descriptor per loop iteration. For small and medium numbers of file
-descriptors a \*(L"slow\*(R" \f(CW\*(C`EVBACKEND_SELECT\*(C'\fR or \f(CW\*(C`EVBACKEND_POLL\*(C'\fR backend
-might perform better.
-.Sp
-On the positive side, this backend actually performed fully to
-specification in all tests and is fully embeddable, which is a rare feat
-among the OS-specific backends (I vastly prefer correctness over speed
-hacks).
-.Sp
-On the negative side, the interface is \fIbizarre\fR \- so bizarre that
-even sun itself gets it wrong in their code examples: The event polling
-function sometimes returns events to the caller even though an error
-occurred, but with no indication whether it has done so or not (yes, it's
-even documented that way) \- deadly for edge-triggered interfaces where you
-absolutely have to know whether an event occurred or not because you have
-to re-arm the watcher.
-.Sp
-Fortunately libev seems to be able to work around these idiocies.
-.Sp
-This backend maps \f(CW\*(C`EV_READ\*(C'\fR and \f(CW\*(C`EV_WRITE\*(C'\fR in the same way as
-\&\f(CW\*(C`EVBACKEND_POLL\*(C'\fR.
-.ie n .IP """EVBACKEND_ALL""" 4
-.el .IP "\f(CWEVBACKEND_ALL\fR" 4
-.IX Item "EVBACKEND_ALL"
-Try all backends (even potentially broken ones that wouldn't be tried
-with \f(CW\*(C`EVFLAG_AUTO\*(C'\fR). Since this is a mask, you can do stuff such as
-\&\f(CW\*(C`EVBACKEND_ALL & ~EVBACKEND_KQUEUE\*(C'\fR.
-.Sp
-It is definitely not recommended to use this flag, use whatever
-\&\f(CW\*(C`ev_recommended_backends ()\*(C'\fR returns, or simply do not specify a backend
-at all.
-.ie n .IP """EVBACKEND_MASK""" 4
-.el .IP "\f(CWEVBACKEND_MASK\fR" 4
-.IX Item "EVBACKEND_MASK"
-Not a backend at all, but a mask to select all backend bits from a
-\&\f(CW\*(C`flags\*(C'\fR value, in case you want to mask out any backends from a flags
-value (e.g. when modifying the \f(CW\*(C`LIBEV_FLAGS\*(C'\fR environment variable).
-.RE
-.RS 4
-.Sp
-If one or more of the backend flags are or'ed into the flags value,
-then only these backends will be tried (in the reverse order as listed
-here). If none are specified, all backends in \f(CW\*(C`ev_recommended_backends
-()\*(C'\fR will be tried.
-.Sp
-Example: Try to create a event loop that uses epoll and nothing else.
-.Sp
-.Vb 3
-\&   struct ev_loop *epoller = ev_loop_new (EVBACKEND_EPOLL | EVFLAG_NOENV);
-\&   if (!epoller)
-\&     fatal ("no epoll found here, maybe it hides under your chair");
-.Ve
-.Sp
-Example: Use whatever libev has to offer, but make sure that kqueue is
-used if available.
-.Sp
-.Vb 1
-\&   struct ev_loop *loop = ev_loop_new (ev_recommended_backends () | EVBACKEND_KQUEUE);
-.Ve
-.RE
-.IP "ev_loop_destroy (loop)" 4
-.IX Item "ev_loop_destroy (loop)"
-Destroys an event loop object (frees all memory and kernel state
-etc.). None of the active event watchers will be stopped in the normal
-sense, so e.g. \f(CW\*(C`ev_is_active\*(C'\fR might still return true. It is your
-responsibility to either stop all watchers cleanly yourself \fIbefore\fR
-calling this function, or cope with the fact afterwards (which is usually
-the easiest thing, you can just ignore the watchers and/or \f(CW\*(C`free ()\*(C'\fR them
-for example).
-.Sp
-Note that certain global state, such as signal state (and installed signal
-handlers), will not be freed by this function, and related watchers (such
-as signal and child watchers) would need to be stopped manually.
-.Sp
-This function is normally used on loop objects allocated by
-\&\f(CW\*(C`ev_loop_new\*(C'\fR, but it can also be used on the default loop returned by
-\&\f(CW\*(C`ev_default_loop\*(C'\fR, in which case it is not thread-safe.
-.Sp
-Note that it is not advisable to call this function on the default loop
-except in the rare occasion where you really need to free its resources.
-If you need dynamically allocated loops it is better to use \f(CW\*(C`ev_loop_new\*(C'\fR
-and \f(CW\*(C`ev_loop_destroy\*(C'\fR.
-.IP "ev_loop_fork (loop)" 4
-.IX Item "ev_loop_fork (loop)"
-This function sets a flag that causes subsequent \f(CW\*(C`ev_run\*(C'\fR iterations
-to reinitialise the kernel state for backends that have one. Despite
-the name, you can call it anytime you are allowed to start or stop
-watchers (except inside an \f(CW\*(C`ev_prepare\*(C'\fR callback), but it makes most
-sense after forking, in the child process. You \fImust\fR call it (or use
-\&\f(CW\*(C`EVFLAG_FORKCHECK\*(C'\fR) in the child before resuming or calling \f(CW\*(C`ev_run\*(C'\fR.
-.Sp
-In addition, if you want to reuse a loop (via this function or
-\&\f(CW\*(C`EVFLAG_FORKCHECK\*(C'\fR), you \fIalso\fR have to ignore \f(CW\*(C`SIGPIPE\*(C'\fR.
-.Sp
-Again, you \fIhave\fR to call it on \fIany\fR loop that you want to re-use after
-a fork, \fIeven if you do not plan to use the loop in the parent\fR. This is
-because some kernel interfaces *cough* \fIkqueue\fR *cough* do funny things
-during fork.
-.Sp
-On the other hand, you only need to call this function in the child
-process if and only if you want to use the event loop in the child. If
-you just fork+exec or create a new loop in the child, you don't have to
-call it at all (in fact, \f(CW\*(C`epoll\*(C'\fR is so badly broken that it makes a
-difference, but libev will usually detect this case on its own and do a
-costly reset of the backend).
-.Sp
-The function itself is quite fast and it's usually not a problem to call
-it just in case after a fork.
-.Sp
-Example: Automate calling \f(CW\*(C`ev_loop_fork\*(C'\fR on the default loop when
-using pthreads.
-.Sp
-.Vb 5
-\&   static void
-\&   post_fork_child (void)
-\&   {
-\&     ev_loop_fork (EV_DEFAULT);
-\&   }
-\&
-\&   ...
-\&   pthread_atfork (0, 0, post_fork_child);
-.Ve
-.IP "int ev_is_default_loop (loop)" 4
-.IX Item "int ev_is_default_loop (loop)"
-Returns true when the given loop is, in fact, the default loop, and false
-otherwise.
-.IP "unsigned int ev_iteration (loop)" 4
-.IX Item "unsigned int ev_iteration (loop)"
-Returns the current iteration count for the event loop, which is identical
-to the number of times libev did poll for new events. It starts at \f(CW0\fR
-and happily wraps around with enough iterations.
-.Sp
-This value can sometimes be useful as a generation counter of sorts (it
-\&\*(L"ticks\*(R" the number of loop iterations), as it roughly corresponds with
-\&\f(CW\*(C`ev_prepare\*(C'\fR and \f(CW\*(C`ev_check\*(C'\fR calls \- and is incremented between the
-prepare and check phases.
-.IP "unsigned int ev_depth (loop)" 4
-.IX Item "unsigned int ev_depth (loop)"
-Returns the number of times \f(CW\*(C`ev_run\*(C'\fR was entered minus the number of
-times \f(CW\*(C`ev_run\*(C'\fR was exited normally, in other words, the recursion depth.
-.Sp
-Outside \f(CW\*(C`ev_run\*(C'\fR, this number is zero. In a callback, this number is
-\&\f(CW1\fR, unless \f(CW\*(C`ev_run\*(C'\fR was invoked recursively (or from another thread),
-in which case it is higher.
-.Sp
-Leaving \f(CW\*(C`ev_run\*(C'\fR abnormally (setjmp/longjmp, cancelling the thread,
-throwing an exception etc.), doesn't count as \*(L"exit\*(R" \- consider this
-as a hint to avoid such ungentleman-like behaviour unless it's really
-convenient, in which case it is fully supported.
-.IP "unsigned int ev_backend (loop)" 4
-.IX Item "unsigned int ev_backend (loop)"
-Returns one of the \f(CW\*(C`EVBACKEND_*\*(C'\fR flags indicating the event backend in
-use.
-.IP "ev_tstamp ev_now (loop)" 4
-.IX Item "ev_tstamp ev_now (loop)"
-Returns the current \*(L"event loop time\*(R", which is the time the event loop
-received events and started processing them. This timestamp does not
-change as long as callbacks are being processed, and this is also the base
-time used for relative timers. You can treat it as the timestamp of the
-event occurring (or more correctly, libev finding out about it).
-.IP "ev_now_update (loop)" 4
-.IX Item "ev_now_update (loop)"
-Establishes the current time by querying the kernel, updating the time
-returned by \f(CW\*(C`ev_now ()\*(C'\fR in the progress. This is a costly operation and
-is usually done automatically within \f(CW\*(C`ev_run ()\*(C'\fR.
-.Sp
-This function is rarely useful, but when some event callback runs for a
-very long time without entering the event loop, updating libev's idea of
-the current time is a good idea.
-.Sp
-See also \*(L"The special problem of time updates\*(R" in the \f(CW\*(C`ev_timer\*(C'\fR section.
-.IP "ev_suspend (loop)" 4
-.IX Item "ev_suspend (loop)"
-.PD 0
-.IP "ev_resume (loop)" 4
-.IX Item "ev_resume (loop)"
-.PD
-These two functions suspend and resume an event loop, for use when the
-loop is not used for a while and timeouts should not be processed.
-.Sp
-A typical use case would be an interactive program such as a game:  When
-the user presses \f(CW\*(C`^Z\*(C'\fR to suspend the game and resumes it an hour later it
-would be best to handle timeouts as if no time had actually passed while
-the program was suspended. This can be achieved by calling \f(CW\*(C`ev_suspend\*(C'\fR
-in your \f(CW\*(C`SIGTSTP\*(C'\fR handler, sending yourself a \f(CW\*(C`SIGSTOP\*(C'\fR and calling
-\&\f(CW\*(C`ev_resume\*(C'\fR directly afterwards to resume timer processing.
-.Sp
-Effectively, all \f(CW\*(C`ev_timer\*(C'\fR watchers will be delayed by the time spend
-between \f(CW\*(C`ev_suspend\*(C'\fR and \f(CW\*(C`ev_resume\*(C'\fR, and all \f(CW\*(C`ev_periodic\*(C'\fR watchers
-will be rescheduled (that is, they will lose any events that would have
-occurred while suspended).
-.Sp
-After calling \f(CW\*(C`ev_suspend\*(C'\fR you \fBmust not\fR call \fIany\fR function on the
-given loop other than \f(CW\*(C`ev_resume\*(C'\fR, and you \fBmust not\fR call \f(CW\*(C`ev_resume\*(C'\fR
-without a previous call to \f(CW\*(C`ev_suspend\*(C'\fR.
-.Sp
-Calling \f(CW\*(C`ev_suspend\*(C'\fR/\f(CW\*(C`ev_resume\*(C'\fR has the side effect of updating the
-event loop time (see \f(CW\*(C`ev_now_update\*(C'\fR).
-.IP "bool ev_run (loop, int flags)" 4
-.IX Item "bool ev_run (loop, int flags)"
-Finally, this is it, the event handler. This function usually is called
-after you have initialised all your watchers and you want to start
-handling events. It will ask the operating system for any new events, call
-the watcher callbacks, and then repeat the whole process indefinitely: This
-is why event loops are called \fIloops\fR.
-.Sp
-If the flags argument is specified as \f(CW0\fR, it will keep handling events
-until either no event watchers are active anymore or \f(CW\*(C`ev_break\*(C'\fR was
-called.
-.Sp
-The return value is false if there are no more active watchers (which
-usually means \*(L"all jobs done\*(R" or \*(L"deadlock\*(R"), and true in all other cases
-(which usually means " you should call \f(CW\*(C`ev_run\*(C'\fR again").
-.Sp
-Please note that an explicit \f(CW\*(C`ev_break\*(C'\fR is usually better than
-relying on all watchers to be stopped when deciding when a program has
-finished (especially in interactive programs), but having a program
-that automatically loops as long as it has to and no longer by virtue
-of relying on its watchers stopping correctly, that is truly a thing of
-beauty.
-.Sp
-This function is \fImostly\fR exception-safe \- you can break out of a
-\&\f(CW\*(C`ev_run\*(C'\fR call by calling \f(CW\*(C`longjmp\*(C'\fR in a callback, throwing a \*(C+
-exception and so on. This does not decrement the \f(CW\*(C`ev_depth\*(C'\fR value, nor
-will it clear any outstanding \f(CW\*(C`EVBREAK_ONE\*(C'\fR breaks.
-.Sp
-A flags value of \f(CW\*(C`EVRUN_NOWAIT\*(C'\fR will look for new events, will handle
-those events and any already outstanding ones, but will not wait and
-block your process in case there are no events and will return after one
-iteration of the loop. This is sometimes useful to poll and handle new
-events while doing lengthy calculations, to keep the program responsive.
-.Sp
-A flags value of \f(CW\*(C`EVRUN_ONCE\*(C'\fR will look for new events (waiting if
-necessary) and will handle those and any already outstanding ones. It
-will block your process until at least one new event arrives (which could
-be an event internal to libev itself, so there is no guarantee that a
-user-registered callback will be called), and will return after one
-iteration of the loop.
-.Sp
-This is useful if you are waiting for some external event in conjunction
-with something not expressible using other libev watchers (i.e. "roll your
-own \f(CW\*(C`ev_run\*(C'\fR"). However, a pair of \f(CW\*(C`ev_prepare\*(C'\fR/\f(CW\*(C`ev_check\*(C'\fR watchers is
-usually a better approach for this kind of thing.
-.Sp
-Here are the gory details of what \f(CW\*(C`ev_run\*(C'\fR does (this is for your
-understanding, not a guarantee that things will work exactly like this in
-future versions):
-.Sp
-.Vb 10
-\&   \- Increment loop depth.
-\&   \- Reset the ev_break status.
-\&   \- Before the first iteration, call any pending watchers.
-\&   LOOP:
-\&   \- If EVFLAG_FORKCHECK was used, check for a fork.
-\&   \- If a fork was detected (by any means), queue and call all fork watchers.
-\&   \- Queue and call all prepare watchers.
-\&   \- If ev_break was called, goto FINISH.
-\&   \- If we have been forked, detach and recreate the kernel state
-\&     as to not disturb the other process.
-\&   \- Update the kernel state with all outstanding changes.
-\&   \- Update the "event loop time" (ev_now ()).
-\&   \- Calculate for how long to sleep or block, if at all
-\&     (active idle watchers, EVRUN_NOWAIT or not having
-\&     any active watchers at all will result in not sleeping).
-\&   \- Sleep if the I/O and timer collect interval say so.
-\&   \- Increment loop iteration counter.
-\&   \- Block the process, waiting for any events.
-\&   \- Queue all outstanding I/O (fd) events.
-\&   \- Update the "event loop time" (ev_now ()), and do time jump adjustments.
-\&   \- Queue all expired timers.
-\&   \- Queue all expired periodics.
-\&   \- Queue all idle watchers with priority higher than that of pending events.
-\&   \- Queue all check watchers.
-\&   \- Call all queued watchers in reverse order (i.e. check watchers first).
-\&     Signals and child watchers are implemented as I/O watchers, and will
-\&     be handled here by queueing them when their watcher gets executed.
-\&   \- If ev_break has been called, or EVRUN_ONCE or EVRUN_NOWAIT
-\&     were used, or there are no active watchers, goto FINISH, otherwise
-\&     continue with step LOOP.
-\&   FINISH:
-\&   \- Reset the ev_break status iff it was EVBREAK_ONE.
-\&   \- Decrement the loop depth.
-\&   \- Return.
-.Ve
-.Sp
-Example: Queue some jobs and then loop until no events are outstanding
-anymore.
-.Sp
-.Vb 4
-\&   ... queue jobs here, make sure they register event watchers as long
-\&   ... as they still have work to do (even an idle watcher will do..)
-\&   ev_run (my_loop, 0);
-\&   ... jobs done or somebody called break. yeah!
-.Ve
-.IP "ev_break (loop, how)" 4
-.IX Item "ev_break (loop, how)"
-Can be used to make a call to \f(CW\*(C`ev_run\*(C'\fR return early (but only after it
-has processed all outstanding events). The \f(CW\*(C`how\*(C'\fR argument must be either
-\&\f(CW\*(C`EVBREAK_ONE\*(C'\fR, which will make the innermost \f(CW\*(C`ev_run\*(C'\fR call return, or
-\&\f(CW\*(C`EVBREAK_ALL\*(C'\fR, which will make all nested \f(CW\*(C`ev_run\*(C'\fR calls return.
-.Sp
-This \*(L"break state\*(R" will be cleared on the next call to \f(CW\*(C`ev_run\*(C'\fR.
-.Sp
-It is safe to call \f(CW\*(C`ev_break\*(C'\fR from outside any \f(CW\*(C`ev_run\*(C'\fR calls, too, in
-which case it will have no effect.
-.IP "ev_ref (loop)" 4
-.IX Item "ev_ref (loop)"
-.PD 0
-.IP "ev_unref (loop)" 4
-.IX Item "ev_unref (loop)"
-.PD
-Ref/unref can be used to add or remove a reference count on the event
-loop: Every watcher keeps one reference, and as long as the reference
-count is nonzero, \f(CW\*(C`ev_run\*(C'\fR will not return on its own.
-.Sp
-This is useful when you have a watcher that you never intend to
-unregister, but that nevertheless should not keep \f(CW\*(C`ev_run\*(C'\fR from
-returning. In such a case, call \f(CW\*(C`ev_unref\*(C'\fR after starting, and \f(CW\*(C`ev_ref\*(C'\fR
-before stopping it.
-.Sp
-As an example, libev itself uses this for its internal signal pipe: It
-is not visible to the libev user and should not keep \f(CW\*(C`ev_run\*(C'\fR from
-exiting if no event watchers registered by it are active. It is also an
-excellent way to do this for generic recurring timers or from within
-third-party libraries. Just remember to \fIunref after start\fR and \fIref
-before stop\fR (but only if the watcher wasn't active before, or was active
-before, respectively. Note also that libev might stop watchers itself
-(e.g. non-repeating timers) in which case you have to \f(CW\*(C`ev_ref\*(C'\fR
-in the callback).
-.Sp
-Example: Create a signal watcher, but keep it from keeping \f(CW\*(C`ev_run\*(C'\fR
-running when nothing else is active.
-.Sp
-.Vb 4
-\&   ev_signal exitsig;
-\&   ev_signal_init (&exitsig, sig_cb, SIGINT);
-\&   ev_signal_start (loop, &exitsig);
-\&   ev_unref (loop);
-.Ve
-.Sp
-Example: For some weird reason, unregister the above signal handler again.
-.Sp
-.Vb 2
-\&   ev_ref (loop);
-\&   ev_signal_stop (loop, &exitsig);
-.Ve
-.IP "ev_set_io_collect_interval (loop, ev_tstamp interval)" 4
-.IX Item "ev_set_io_collect_interval (loop, ev_tstamp interval)"
-.PD 0
-.IP "ev_set_timeout_collect_interval (loop, ev_tstamp interval)" 4
-.IX Item "ev_set_timeout_collect_interval (loop, ev_tstamp interval)"
-.PD
-These advanced functions influence the time that libev will spend waiting
-for events. Both time intervals are by default \f(CW0\fR, meaning that libev
-will try to invoke timer/periodic callbacks and I/O callbacks with minimum
-latency.
-.Sp
-Setting these to a higher value (the \f(CW\*(C`interval\*(C'\fR \fImust\fR be >= \f(CW0\fR)
-allows libev to delay invocation of I/O and timer/periodic callbacks
-to increase efficiency of loop iterations (or to increase power-saving
-opportunities).
-.Sp
-The idea is that sometimes your program runs just fast enough to handle
-one (or very few) event(s) per loop iteration. While this makes the
-program responsive, it also wastes a lot of \s-1CPU\s0 time to poll for new
-events, especially with backends like \f(CW\*(C`select ()\*(C'\fR which have a high
-overhead for the actual polling but can deliver many events at once.
-.Sp
-By setting a higher \fIio collect interval\fR you allow libev to spend more
-time collecting I/O events, so you can handle more events per iteration,
-at the cost of increasing latency. Timeouts (both \f(CW\*(C`ev_periodic\*(C'\fR and
-\&\f(CW\*(C`ev_timer\*(C'\fR) will not be affected. Setting this to a non-null value will
-introduce an additional \f(CW\*(C`ev_sleep ()\*(C'\fR call into most loop iterations. The
-sleep time ensures that libev will not poll for I/O events more often then
-once per this interval, on average (as long as the host time resolution is
-good enough).
-.Sp
-Likewise, by setting a higher \fItimeout collect interval\fR you allow libev
-to spend more time collecting timeouts, at the expense of increased
-latency/jitter/inexactness (the watcher callback will be called
-later). \f(CW\*(C`ev_io\*(C'\fR watchers will not be affected. Setting this to a non-null
-value will not introduce any overhead in libev.
-.Sp
-Many (busy) programs can usually benefit by setting the I/O collect
-interval to a value near \f(CW0.1\fR or so, which is often enough for
-interactive servers (of course not for games), likewise for timeouts. It
-usually doesn't make much sense to set it to a lower value than \f(CW0.01\fR,
-as this approaches the timing granularity of most systems. Note that if
-you do transactions with the outside world and you can't increase the
-parallelity, then this setting will limit your transaction rate (if you
-need to poll once per transaction and the I/O collect interval is 0.01,
-then you can't do more than 100 transactions per second).
-.Sp
-Setting the \fItimeout collect interval\fR can improve the opportunity for
-saving power, as the program will \*(L"bundle\*(R" timer callback invocations that
-are \*(L"near\*(R" in time together, by delaying some, thus reducing the number of
-times the process sleeps and wakes up again. Another useful technique to
-reduce iterations/wake\-ups is to use \f(CW\*(C`ev_periodic\*(C'\fR watchers and make sure
-they fire on, say, one-second boundaries only.
-.Sp
-Example: we only need 0.1s timeout granularity, and we wish not to poll
-more often than 100 times per second:
-.Sp
-.Vb 2
-\&   ev_set_timeout_collect_interval (EV_DEFAULT_UC_ 0.1);
-\&   ev_set_io_collect_interval (EV_DEFAULT_UC_ 0.01);
-.Ve
-.IP "ev_invoke_pending (loop)" 4
-.IX Item "ev_invoke_pending (loop)"
-This call will simply invoke all pending watchers while resetting their
-pending state. Normally, \f(CW\*(C`ev_run\*(C'\fR does this automatically when required,
-but when overriding the invoke callback this call comes handy. This
-function can be invoked from a watcher \- this can be useful for example
-when you want to do some lengthy calculation and want to pass further
-event handling to another thread (you still have to make sure only one
-thread executes within \f(CW\*(C`ev_invoke_pending\*(C'\fR or \f(CW\*(C`ev_run\*(C'\fR of course).
-.IP "int ev_pending_count (loop)" 4
-.IX Item "int ev_pending_count (loop)"
-Returns the number of pending watchers \- zero indicates that no watchers
-are pending.
-.IP "ev_set_invoke_pending_cb (loop, void (*invoke_pending_cb)(\s-1EV_P\s0))" 4
-.IX Item "ev_set_invoke_pending_cb (loop, void (*invoke_pending_cb)(EV_P))"
-This overrides the invoke pending functionality of the loop: Instead of
-invoking all pending watchers when there are any, \f(CW\*(C`ev_run\*(C'\fR will call
-this callback instead. This is useful, for example, when you want to
-invoke the actual watchers inside another context (another thread etc.).
-.Sp
-If you want to reset the callback, use \f(CW\*(C`ev_invoke_pending\*(C'\fR as new
-callback.
-.IP "ev_set_loop_release_cb (loop, void (*release)(\s-1EV_P\s0) throw (), void (*acquire)(\s-1EV_P\s0) throw ())" 4
-.IX Item "ev_set_loop_release_cb (loop, void (*release)(EV_P) throw (), void (*acquire)(EV_P) throw ())"
-Sometimes you want to share the same loop between multiple threads. This
-can be done relatively simply by putting mutex_lock/unlock calls around
-each call to a libev function.
-.Sp
-However, \f(CW\*(C`ev_run\*(C'\fR can run an indefinite time, so it is not feasible
-to wait for it to return. One way around this is to wake up the event
-loop via \f(CW\*(C`ev_break\*(C'\fR and \f(CW\*(C`ev_async_send\*(C'\fR, another way is to set these
-\&\fIrelease\fR and \fIacquire\fR callbacks on the loop.
-.Sp
-When set, then \f(CW\*(C`release\*(C'\fR will be called just before the thread is
-suspended waiting for new events, and \f(CW\*(C`acquire\*(C'\fR is called just
-afterwards.
-.Sp
-Ideally, \f(CW\*(C`release\*(C'\fR will just call your mutex_unlock function, and
-\&\f(CW\*(C`acquire\*(C'\fR will just call the mutex_lock function again.
-.Sp
-While event loop modifications are allowed between invocations of
-\&\f(CW\*(C`release\*(C'\fR and \f(CW\*(C`acquire\*(C'\fR (that's their only purpose after all), no
-modifications done will affect the event loop, i.e. adding watchers will
-have no effect on the set of file descriptors being watched, or the time
-waited. Use an \f(CW\*(C`ev_async\*(C'\fR watcher to wake up \f(CW\*(C`ev_run\*(C'\fR when you want it
-to take note of any changes you made.
-.Sp
-In theory, threads executing \f(CW\*(C`ev_run\*(C'\fR will be async-cancel safe between
-invocations of \f(CW\*(C`release\*(C'\fR and \f(CW\*(C`acquire\*(C'\fR.
-.Sp
-See also the locking example in the \f(CW\*(C`THREADS\*(C'\fR section later in this
-document.
-.IP "ev_set_userdata (loop, void *data)" 4
-.IX Item "ev_set_userdata (loop, void *data)"
-.PD 0
-.IP "void *ev_userdata (loop)" 4
-.IX Item "void *ev_userdata (loop)"
-.PD
-Set and retrieve a single \f(CW\*(C`void *\*(C'\fR associated with a loop. When
-\&\f(CW\*(C`ev_set_userdata\*(C'\fR has never been called, then \f(CW\*(C`ev_userdata\*(C'\fR returns
-\&\f(CW0\fR.
-.Sp
-These two functions can be used to associate arbitrary data with a loop,
-and are intended solely for the \f(CW\*(C`invoke_pending_cb\*(C'\fR, \f(CW\*(C`release\*(C'\fR and
-\&\f(CW\*(C`acquire\*(C'\fR callbacks described above, but of course can be (ab\-)used for
-any other purpose as well.
-.IP "ev_verify (loop)" 4
-.IX Item "ev_verify (loop)"
-This function only does something when \f(CW\*(C`EV_VERIFY\*(C'\fR support has been
-compiled in, which is the default for non-minimal builds. It tries to go
-through all internal structures and checks them for validity. If anything
-is found to be inconsistent, it will print an error message to standard
-error and call \f(CW\*(C`abort ()\*(C'\fR.
-.Sp
-This can be used to catch bugs inside libev itself: under normal
-circumstances, this function will never abort as of course libev keeps its
-data structures consistent.
-.SH "ANATOMY OF A WATCHER"
-.IX Header "ANATOMY OF A WATCHER"
-In the following description, uppercase \f(CW\*(C`TYPE\*(C'\fR in names stands for the
-watcher type, e.g. \f(CW\*(C`ev_TYPE_start\*(C'\fR can mean \f(CW\*(C`ev_timer_start\*(C'\fR for timer
-watchers and \f(CW\*(C`ev_io_start\*(C'\fR for I/O watchers.
-.PP
-A watcher is an opaque structure that you allocate and register to record
-your interest in some event. To make a concrete example, imagine you want
-to wait for \s-1STDIN\s0 to become readable, you would create an \f(CW\*(C`ev_io\*(C'\fR watcher
-for that:
-.PP
-.Vb 5
-\&   static void my_cb (struct ev_loop *loop, ev_io *w, int revents)
-\&   {
-\&     ev_io_stop (w);
-\&     ev_break (loop, EVBREAK_ALL);
-\&   }
-\&
-\&   struct ev_loop *loop = ev_default_loop (0);
-\&
-\&   ev_io stdin_watcher;
-\&
-\&   ev_init (&stdin_watcher, my_cb);
-\&   ev_io_set (&stdin_watcher, STDIN_FILENO, EV_READ);
-\&   ev_io_start (loop, &stdin_watcher);
-\&
-\&   ev_run (loop, 0);
-.Ve
-.PP
-As you can see, you are responsible for allocating the memory for your
-watcher structures (and it is \fIusually\fR a bad idea to do this on the
-stack).
-.PP
-Each watcher has an associated watcher structure (called \f(CW\*(C`struct ev_TYPE\*(C'\fR
-or simply \f(CW\*(C`ev_TYPE\*(C'\fR, as typedefs are provided for all watcher structs).
-.PP
-Each watcher structure must be initialised by a call to \f(CW\*(C`ev_init (watcher
-*, callback)\*(C'\fR, which expects a callback to be provided. This callback is
-invoked each time the event occurs (or, in the case of I/O watchers, each
-time the event loop detects that the file descriptor given is readable
-and/or writable).
-.PP
-Each watcher type further has its own \f(CW\*(C`ev_TYPE_set (watcher *, ...)\*(C'\fR
-macro to configure it, with arguments specific to the watcher type. There
-is also a macro to combine initialisation and setting in one call: \f(CW\*(C`ev_TYPE_init (watcher *, callback, ...)\*(C'\fR.
-.PP
-To make the watcher actually watch out for events, you have to start it
-with a watcher-specific start function (\f(CW\*(C`ev_TYPE_start (loop, watcher
-*)\*(C'\fR), and you can stop watching for events at any time by calling the
-corresponding stop function (\f(CW\*(C`ev_TYPE_stop (loop, watcher *)\*(C'\fR.
-.PP
-As long as your watcher is active (has been started but not stopped) you
-must not touch the values stored in it. Most specifically you must never
-reinitialise it or call its \f(CW\*(C`ev_TYPE_set\*(C'\fR macro.
-.PP
-Each and every callback receives the event loop pointer as first, the
-registered watcher structure as second, and a bitset of received events as
-third argument.
-.PP
-The received events usually include a single bit per event type received
-(you can receive multiple events at the same time). The possible bit masks
-are:
-.ie n .IP """EV_READ""" 4
-.el .IP "\f(CWEV_READ\fR" 4
-.IX Item "EV_READ"
-.PD 0
-.ie n .IP """EV_WRITE""" 4
-.el .IP "\f(CWEV_WRITE\fR" 4
-.IX Item "EV_WRITE"
-.PD
-The file descriptor in the \f(CW\*(C`ev_io\*(C'\fR watcher has become readable and/or
-writable.
-.ie n .IP """EV_TIMER""" 4
-.el .IP "\f(CWEV_TIMER\fR" 4
-.IX Item "EV_TIMER"
-The \f(CW\*(C`ev_timer\*(C'\fR watcher has timed out.
-.ie n .IP """EV_PERIODIC""" 4
-.el .IP "\f(CWEV_PERIODIC\fR" 4
-.IX Item "EV_PERIODIC"
-The \f(CW\*(C`ev_periodic\*(C'\fR watcher has timed out.
-.ie n .IP """EV_SIGNAL""" 4
-.el .IP "\f(CWEV_SIGNAL\fR" 4
-.IX Item "EV_SIGNAL"
-The signal specified in the \f(CW\*(C`ev_signal\*(C'\fR watcher has been received by a thread.
-.ie n .IP """EV_CHILD""" 4
-.el .IP "\f(CWEV_CHILD\fR" 4
-.IX Item "EV_CHILD"
-The pid specified in the \f(CW\*(C`ev_child\*(C'\fR watcher has received a status change.
-.ie n .IP """EV_STAT""" 4
-.el .IP "\f(CWEV_STAT\fR" 4
-.IX Item "EV_STAT"
-The path specified in the \f(CW\*(C`ev_stat\*(C'\fR watcher changed its attributes somehow.
-.ie n .IP """EV_IDLE""" 4
-.el .IP "\f(CWEV_IDLE\fR" 4
-.IX Item "EV_IDLE"
-The \f(CW\*(C`ev_idle\*(C'\fR watcher has determined that you have nothing better to do.
-.ie n .IP """EV_PREPARE""" 4
-.el .IP "\f(CWEV_PREPARE\fR" 4
-.IX Item "EV_PREPARE"
-.PD 0
-.ie n .IP """EV_CHECK""" 4
-.el .IP "\f(CWEV_CHECK\fR" 4
-.IX Item "EV_CHECK"
-.PD
-All \f(CW\*(C`ev_prepare\*(C'\fR watchers are invoked just \fIbefore\fR \f(CW\*(C`ev_run\*(C'\fR starts to
-gather new events, and all \f(CW\*(C`ev_check\*(C'\fR watchers are queued (not invoked)
-just after \f(CW\*(C`ev_run\*(C'\fR has gathered them, but before it queues any callbacks
-for any received events. That means \f(CW\*(C`ev_prepare\*(C'\fR watchers are the last
-watchers invoked before the event loop sleeps or polls for new events, and
-\&\f(CW\*(C`ev_check\*(C'\fR watchers will be invoked before any other watchers of the same
-or lower priority within an event loop iteration.
-.Sp
-Callbacks of both watcher types can start and stop as many watchers as
-they want, and all of them will be taken into account (for example, a
-\&\f(CW\*(C`ev_prepare\*(C'\fR watcher might start an idle watcher to keep \f(CW\*(C`ev_run\*(C'\fR from
-blocking).
-.ie n .IP """EV_EMBED""" 4
-.el .IP "\f(CWEV_EMBED\fR" 4
-.IX Item "EV_EMBED"
-The embedded event loop specified in the \f(CW\*(C`ev_embed\*(C'\fR watcher needs attention.
-.ie n .IP """EV_FORK""" 4
-.el .IP "\f(CWEV_FORK\fR" 4
-.IX Item "EV_FORK"
-The event loop has been resumed in the child process after fork (see
-\&\f(CW\*(C`ev_fork\*(C'\fR).
-.ie n .IP """EV_CLEANUP""" 4
-.el .IP "\f(CWEV_CLEANUP\fR" 4
-.IX Item "EV_CLEANUP"
-The event loop is about to be destroyed (see \f(CW\*(C`ev_cleanup\*(C'\fR).
-.ie n .IP """EV_ASYNC""" 4
-.el .IP "\f(CWEV_ASYNC\fR" 4
-.IX Item "EV_ASYNC"
-The given async watcher has been asynchronously notified (see \f(CW\*(C`ev_async\*(C'\fR).
-.ie n .IP """EV_CUSTOM""" 4
-.el .IP "\f(CWEV_CUSTOM\fR" 4
-.IX Item "EV_CUSTOM"
-Not ever sent (or otherwise used) by libev itself, but can be freely used
-by libev users to signal watchers (e.g. via \f(CW\*(C`ev_feed_event\*(C'\fR).
-.ie n .IP """EV_ERROR""" 4
-.el .IP "\f(CWEV_ERROR\fR" 4
-.IX Item "EV_ERROR"
-An unspecified error has occurred, the watcher has been stopped. This might
-happen because the watcher could not be properly started because libev
-ran out of memory, a file descriptor was found to be closed or any other
-problem. Libev considers these application bugs.
-.Sp
-You best act on it by reporting the problem and somehow coping with the
-watcher being stopped. Note that well-written programs should not receive
-an error ever, so when your watcher receives it, this usually indicates a
-bug in your program.
-.Sp
-Libev will usually signal a few \*(L"dummy\*(R" events together with an error, for
-example it might indicate that a fd is readable or writable, and if your
-callbacks is well-written it can just attempt the operation and cope with
-the error from \fIread()\fR or \fIwrite()\fR. This will not work in multi-threaded
-programs, though, as the fd could already be closed and reused for another
-thing, so beware.
-.SS "\s-1GENERIC WATCHER FUNCTIONS\s0"
-.IX Subsection "GENERIC WATCHER FUNCTIONS"
-.ie n .IP """ev_init"" (ev_TYPE *watcher, callback)" 4
-.el .IP "\f(CWev_init\fR (ev_TYPE *watcher, callback)" 4
-.IX Item "ev_init (ev_TYPE *watcher, callback)"
-This macro initialises the generic portion of a watcher. The contents
-of the watcher object can be arbitrary (so \f(CW\*(C`malloc\*(C'\fR will do). Only
-the generic parts of the watcher are initialised, you \fIneed\fR to call
-the type-specific \f(CW\*(C`ev_TYPE_set\*(C'\fR macro afterwards to initialise the
-type-specific parts. For each type there is also a \f(CW\*(C`ev_TYPE_init\*(C'\fR macro
-which rolls both calls into one.
-.Sp
-You can reinitialise a watcher at any time as long as it has been stopped
-(or never started) and there are no pending events outstanding.
-.Sp
-The callback is always of type \f(CW\*(C`void (*)(struct ev_loop *loop, ev_TYPE *watcher,
-int revents)\*(C'\fR.
-.Sp
-Example: Initialise an \f(CW\*(C`ev_io\*(C'\fR watcher in two steps.
-.Sp
-.Vb 3
-\&   ev_io w;
-\&   ev_init (&w, my_cb);
-\&   ev_io_set (&w, STDIN_FILENO, EV_READ);
-.Ve
-.ie n .IP """ev_TYPE_set"" (ev_TYPE *watcher, [args])" 4
-.el .IP "\f(CWev_TYPE_set\fR (ev_TYPE *watcher, [args])" 4
-.IX Item "ev_TYPE_set (ev_TYPE *watcher, [args])"
-This macro initialises the type-specific parts of a watcher. You need to
-call \f(CW\*(C`ev_init\*(C'\fR at least once before you call this macro, but you can
-call \f(CW\*(C`ev_TYPE_set\*(C'\fR any number of times. You must not, however, call this
-macro on a watcher that is active (it can be pending, however, which is a
-difference to the \f(CW\*(C`ev_init\*(C'\fR macro).
-.Sp
-Although some watcher types do not have type-specific arguments
-(e.g. \f(CW\*(C`ev_prepare\*(C'\fR) you still need to call its \f(CW\*(C`set\*(C'\fR macro.
-.Sp
-See \f(CW\*(C`ev_init\*(C'\fR, above, for an example.
-.ie n .IP """ev_TYPE_init"" (ev_TYPE *watcher, callback, [args])" 4
-.el .IP "\f(CWev_TYPE_init\fR (ev_TYPE *watcher, callback, [args])" 4
-.IX Item "ev_TYPE_init (ev_TYPE *watcher, callback, [args])"
-This convenience macro rolls both \f(CW\*(C`ev_init\*(C'\fR and \f(CW\*(C`ev_TYPE_set\*(C'\fR macro
-calls into a single call. This is the most convenient method to initialise
-a watcher. The same limitations apply, of course.
-.Sp
-Example: Initialise and set an \f(CW\*(C`ev_io\*(C'\fR watcher in one step.
-.Sp
-.Vb 1
-\&   ev_io_init (&w, my_cb, STDIN_FILENO, EV_READ);
-.Ve
-.ie n .IP """ev_TYPE_start"" (loop, ev_TYPE *watcher)" 4
-.el .IP "\f(CWev_TYPE_start\fR (loop, ev_TYPE *watcher)" 4
-.IX Item "ev_TYPE_start (loop, ev_TYPE *watcher)"
-Starts (activates) the given watcher. Only active watchers will receive
-events. If the watcher is already active nothing will happen.
-.Sp
-Example: Start the \f(CW\*(C`ev_io\*(C'\fR watcher that is being abused as example in this
-whole section.
-.Sp
-.Vb 1
-\&   ev_io_start (EV_DEFAULT_UC, &w);
-.Ve
-.ie n .IP """ev_TYPE_stop"" (loop, ev_TYPE *watcher)" 4
-.el .IP "\f(CWev_TYPE_stop\fR (loop, ev_TYPE *watcher)" 4
-.IX Item "ev_TYPE_stop (loop, ev_TYPE *watcher)"
-Stops the given watcher if active, and clears the pending status (whether
-the watcher was active or not).
-.Sp
-It is possible that stopped watchers are pending \- for example,
-non-repeating timers are being stopped when they become pending \- but
-calling \f(CW\*(C`ev_TYPE_stop\*(C'\fR ensures that the watcher is neither active nor
-pending. If you want to free or reuse the memory used by the watcher it is
-therefore a good idea to always call its \f(CW\*(C`ev_TYPE_stop\*(C'\fR function.
-.IP "bool ev_is_active (ev_TYPE *watcher)" 4
-.IX Item "bool ev_is_active (ev_TYPE *watcher)"
-Returns a true value iff the watcher is active (i.e. it has been started
-and not yet been stopped). As long as a watcher is active you must not modify
-it.
-.IP "bool ev_is_pending (ev_TYPE *watcher)" 4
-.IX Item "bool ev_is_pending (ev_TYPE *watcher)"
-Returns a true value iff the watcher is pending, (i.e. it has outstanding
-events but its callback has not yet been invoked). As long as a watcher
-is pending (but not active) you must not call an init function on it (but
-\&\f(CW\*(C`ev_TYPE_set\*(C'\fR is safe), you must not change its priority, and you must
-make sure the watcher is available to libev (e.g. you cannot \f(CW\*(C`free ()\*(C'\fR
-it).
-.IP "callback ev_cb (ev_TYPE *watcher)" 4
-.IX Item "callback ev_cb (ev_TYPE *watcher)"
-Returns the callback currently set on the watcher.
-.IP "ev_set_cb (ev_TYPE *watcher, callback)" 4
-.IX Item "ev_set_cb (ev_TYPE *watcher, callback)"
-Change the callback. You can change the callback at virtually any time
-(modulo threads).
-.IP "ev_set_priority (ev_TYPE *watcher, int priority)" 4
-.IX Item "ev_set_priority (ev_TYPE *watcher, int priority)"
-.PD 0
-.IP "int ev_priority (ev_TYPE *watcher)" 4
-.IX Item "int ev_priority (ev_TYPE *watcher)"
-.PD
-Set and query the priority of the watcher. The priority is a small
-integer between \f(CW\*(C`EV_MAXPRI\*(C'\fR (default: \f(CW2\fR) and \f(CW\*(C`EV_MINPRI\*(C'\fR
-(default: \f(CW\*(C`\-2\*(C'\fR). Pending watchers with higher priority will be invoked
-before watchers with lower priority, but priority will not keep watchers
-from being executed (except for \f(CW\*(C`ev_idle\*(C'\fR watchers).
-.Sp
-If you need to suppress invocation when higher priority events are pending
-you need to look at \f(CW\*(C`ev_idle\*(C'\fR watchers, which provide this functionality.
-.Sp
-You \fImust not\fR change the priority of a watcher as long as it is active or
-pending.
-.Sp
-Setting a priority outside the range of \f(CW\*(C`EV_MINPRI\*(C'\fR to \f(CW\*(C`EV_MAXPRI\*(C'\fR is
-fine, as long as you do not mind that the priority value you query might
-or might not have been clamped to the valid range.
-.Sp
-The default priority used by watchers when no priority has been set is
-always \f(CW0\fR, which is supposed to not be too high and not be too low :).
-.Sp
-See \*(L"\s-1WATCHER PRIORITY MODELS\*(R"\s0, below, for a more thorough treatment of
-priorities.
-.IP "ev_invoke (loop, ev_TYPE *watcher, int revents)" 4
-.IX Item "ev_invoke (loop, ev_TYPE *watcher, int revents)"
-Invoke the \f(CW\*(C`watcher\*(C'\fR with the given \f(CW\*(C`loop\*(C'\fR and \f(CW\*(C`revents\*(C'\fR. Neither
-\&\f(CW\*(C`loop\*(C'\fR nor \f(CW\*(C`revents\*(C'\fR need to be valid as long as the watcher callback
-can deal with that fact, as both are simply passed through to the
-callback.
-.IP "int ev_clear_pending (loop, ev_TYPE *watcher)" 4
-.IX Item "int ev_clear_pending (loop, ev_TYPE *watcher)"
-If the watcher is pending, this function clears its pending status and
-returns its \f(CW\*(C`revents\*(C'\fR bitset (as if its callback was invoked). If the
-watcher isn't pending it does nothing and returns \f(CW0\fR.
-.Sp
-Sometimes it can be useful to \*(L"poll\*(R" a watcher instead of waiting for its
-callback to be invoked, which can be accomplished with this function.
-.IP "ev_feed_event (loop, ev_TYPE *watcher, int revents)" 4
-.IX Item "ev_feed_event (loop, ev_TYPE *watcher, int revents)"
-Feeds the given event set into the event loop, as if the specified event
-had happened for the specified watcher (which must be a pointer to an
-initialised but not necessarily started event watcher). Obviously you must
-not free the watcher as long as it has pending events.
-.Sp
-Stopping the watcher, letting libev invoke it, or calling
-\&\f(CW\*(C`ev_clear_pending\*(C'\fR will clear the pending event, even if the watcher was
-not started in the first place.
-.Sp
-See also \f(CW\*(C`ev_feed_fd_event\*(C'\fR and \f(CW\*(C`ev_feed_signal_event\*(C'\fR for related
-functions that do not need a watcher.
-.PP
-See also the \*(L"\s-1ASSOCIATING CUSTOM DATA WITH A WATCHER\*(R"\s0 and \*(L"\s-1BUILDING YOUR
-OWN COMPOSITE WATCHERS\*(R"\s0 idioms.
-.SS "\s-1WATCHER STATES\s0"
-.IX Subsection "WATCHER STATES"
-There are various watcher states mentioned throughout this manual \-
-active, pending and so on. In this section these states and the rules to
-transition between them will be described in more detail \- and while these
-rules might look complicated, they usually do \*(L"the right thing\*(R".
-.IP "initialised" 4
-.IX Item "initialised"
-Before a watcher can be registered with the event loop it has to be
-initialised. This can be done with a call to \f(CW\*(C`ev_TYPE_init\*(C'\fR, or calls to
-\&\f(CW\*(C`ev_init\*(C'\fR followed by the watcher-specific \f(CW\*(C`ev_TYPE_set\*(C'\fR function.
-.Sp
-In this state it is simply some block of memory that is suitable for
-use in an event loop. It can be moved around, freed, reused etc. at
-will \- as long as you either keep the memory contents intact, or call
-\&\f(CW\*(C`ev_TYPE_init\*(C'\fR again.
-.IP "started/running/active" 4
-.IX Item "started/running/active"
-Once a watcher has been started with a call to \f(CW\*(C`ev_TYPE_start\*(C'\fR it becomes
-property of the event loop, and is actively waiting for events. While in
-this state it cannot be accessed (except in a few documented ways), moved,
-freed or anything else \- the only legal thing is to keep a pointer to it,
-and call libev functions on it that are documented to work on active watchers.
-.IP "pending" 4
-.IX Item "pending"
-If a watcher is active and libev determines that an event it is interested
-in has occurred (such as a timer expiring), it will become pending. It will
-stay in this pending state until either it is stopped or its callback is
-about to be invoked, so it is not normally pending inside the watcher
-callback.
-.Sp
-The watcher might or might not be active while it is pending (for example,
-an expired non-repeating timer can be pending but no longer active). If it
-is stopped, it can be freely accessed (e.g. by calling \f(CW\*(C`ev_TYPE_set\*(C'\fR),
-but it is still property of the event loop at this time, so cannot be
-moved, freed or reused. And if it is active the rules described in the
-previous item still apply.
-.Sp
-It is also possible to feed an event on a watcher that is not active (e.g.
-via \f(CW\*(C`ev_feed_event\*(C'\fR), in which case it becomes pending without being
-active.
-.IP "stopped" 4
-.IX Item "stopped"
-A watcher can be stopped implicitly by libev (in which case it might still
-be pending), or explicitly by calling its \f(CW\*(C`ev_TYPE_stop\*(C'\fR function. The
-latter will clear any pending state the watcher might be in, regardless
-of whether it was active or not, so stopping a watcher explicitly before
-freeing it is often a good idea.
-.Sp
-While stopped (and not pending) the watcher is essentially in the
-initialised state, that is, it can be reused, moved, modified in any way
-you wish (but when you trash the memory block, you need to \f(CW\*(C`ev_TYPE_init\*(C'\fR
-it again).
-.SS "\s-1WATCHER PRIORITY MODELS\s0"
-.IX Subsection "WATCHER PRIORITY MODELS"
-Many event loops support \fIwatcher priorities\fR, which are usually small
-integers that influence the ordering of event callback invocation
-between watchers in some way, all else being equal.
-.PP
-In libev, Watcher priorities can be set using \f(CW\*(C`ev_set_priority\*(C'\fR. See its
-description for the more technical details such as the actual priority
-range.
-.PP
-There are two common ways how these these priorities are being interpreted
-by event loops:
-.PP
-In the more common lock-out model, higher priorities \*(L"lock out\*(R" invocation
-of lower priority watchers, which means as long as higher priority
-watchers receive events, lower priority watchers are not being invoked.
-.PP
-The less common only-for-ordering model uses priorities solely to order
-callback invocation within a single event loop iteration: Higher priority
-watchers are invoked before lower priority ones, but they all get invoked
-before polling for new events.
-.PP
-Libev uses the second (only-for-ordering) model for all its watchers
-except for idle watchers (which use the lock-out model).
-.PP
-The rationale behind this is that implementing the lock-out model for
-watchers is not well supported by most kernel interfaces, and most event
-libraries will just poll for the same events again and again as long as
-their callbacks have not been executed, which is very inefficient in the
-common case of one high-priority watcher locking out a mass of lower
-priority ones.
-.PP
-Static (ordering) priorities are most useful when you have two or more
-watchers handling the same resource: a typical usage example is having an
-\&\f(CW\*(C`ev_io\*(C'\fR watcher to receive data, and an associated \f(CW\*(C`ev_timer\*(C'\fR to handle
-timeouts. Under load, data might be received while the program handles
-other jobs, but since timers normally get invoked first, the timeout
-handler will be executed before checking for data. In that case, giving
-the timer a lower priority than the I/O watcher ensures that I/O will be
-handled first even under adverse conditions (which is usually, but not
-always, what you want).
-.PP
-Since idle watchers use the \*(L"lock-out\*(R" model, meaning that idle watchers
-will only be executed when no same or higher priority watchers have
-received events, they can be used to implement the \*(L"lock-out\*(R" model when
-required.
-.PP
-For example, to emulate how many other event libraries handle priorities,
-you can associate an \f(CW\*(C`ev_idle\*(C'\fR watcher to each such watcher, and in
-the normal watcher callback, you just start the idle watcher. The real
-processing is done in the idle watcher callback. This causes libev to
-continuously poll and process kernel event data for the watcher, but when
-the lock-out case is known to be rare (which in turn is rare :), this is
-workable.
-.PP
-Usually, however, the lock-out model implemented that way will perform
-miserably under the type of load it was designed to handle. In that case,
-it might be preferable to stop the real watcher before starting the
-idle watcher, so the kernel will not have to process the event in case
-the actual processing will be delayed for considerable time.
-.PP
-Here is an example of an I/O watcher that should run at a strictly lower
-priority than the default, and which should only process data when no
-other events are pending:
-.PP
-.Vb 2
-\&   ev_idle idle; // actual processing watcher
-\&   ev_io io;     // actual event watcher
-\&
-\&   static void
-\&   io_cb (EV_P_ ev_io *w, int revents)
-\&   {
-\&     // stop the I/O watcher, we received the event, but
-\&     // are not yet ready to handle it.
-\&     ev_io_stop (EV_A_ w);
-\&
-\&     // start the idle watcher to handle the actual event.
-\&     // it will not be executed as long as other watchers
-\&     // with the default priority are receiving events.
-\&     ev_idle_start (EV_A_ &idle);
-\&   }
-\&
-\&   static void
-\&   idle_cb (EV_P_ ev_idle *w, int revents)
-\&   {
-\&     // actual processing
-\&     read (STDIN_FILENO, ...);
-\&
-\&     // have to start the I/O watcher again, as
-\&     // we have handled the event
-\&     ev_io_start (EV_P_ &io);
-\&   }
-\&
-\&   // initialisation
-\&   ev_idle_init (&idle, idle_cb);
-\&   ev_io_init (&io, io_cb, STDIN_FILENO, EV_READ);
-\&   ev_io_start (EV_DEFAULT_ &io);
-.Ve
-.PP
-In the \*(L"real\*(R" world, it might also be beneficial to start a timer, so that
-low-priority connections can not be locked out forever under load. This
-enables your program to keep a lower latency for important connections
-during short periods of high load, while not completely locking out less
-important ones.
-.SH "WATCHER TYPES"
-.IX Header "WATCHER TYPES"
-This section describes each watcher in detail, but will not repeat
-information given in the last section. Any initialisation/set macros,
-functions and members specific to the watcher type are explained.
-.PP
-Members are additionally marked with either \fI[read\-only]\fR, meaning that,
-while the watcher is active, you can look at the member and expect some
-sensible content, but you must not modify it (you can modify it while the
-watcher is stopped to your hearts content), or \fI[read\-write]\fR, which
-means you can expect it to have some sensible content while the watcher
-is active, but you can also modify it. Modifying it may not do something
-sensible or take immediate effect (or do anything at all), but libev will
-not crash or malfunction in any way.
-.ie n .SS """ev_io"" \- is this file descriptor readable or writable?"
-.el .SS "\f(CWev_io\fP \- is this file descriptor readable or writable?"
-.IX Subsection "ev_io - is this file descriptor readable or writable?"
-I/O watchers check whether a file descriptor is readable or writable
-in each iteration of the event loop, or, more precisely, when reading
-would not block the process and writing would at least be able to write
-some data. This behaviour is called level-triggering because you keep
-receiving events as long as the condition persists. Remember you can stop
-the watcher if you don't want to act on the event and neither want to
-receive future events.
-.PP
-In general you can register as many read and/or write event watchers per
-fd as you want (as long as you don't confuse yourself). Setting all file
-descriptors to non-blocking mode is also usually a good idea (but not
-required if you know what you are doing).
-.PP
-Another thing you have to watch out for is that it is quite easy to
-receive \*(L"spurious\*(R" readiness notifications, that is, your callback might
-be called with \f(CW\*(C`EV_READ\*(C'\fR but a subsequent \f(CW\*(C`read\*(C'\fR(2) will actually block
-because there is no data. It is very easy to get into this situation even
-with a relatively standard program structure. Thus it is best to always
-use non-blocking I/O: An extra \f(CW\*(C`read\*(C'\fR(2) returning \f(CW\*(C`EAGAIN\*(C'\fR is far
-preferable to a program hanging until some data arrives.
-.PP
-If you cannot run the fd in non-blocking mode (for example you should
-not play around with an Xlib connection), then you have to separately
-re-test whether a file descriptor is really ready with a known-to-be good
-interface such as poll (fortunately in the case of Xlib, it already does
-this on its own, so its quite safe to use). Some people additionally
-use \f(CW\*(C`SIGALRM\*(C'\fR and an interval timer, just to be sure you won't block
-indefinitely.
-.PP
-But really, best use non-blocking mode.
-.PP
-\fIThe special problem of disappearing file descriptors\fR
-.IX Subsection "The special problem of disappearing file descriptors"
-.PP
-Some backends (e.g. kqueue, epoll) need to be told about closing a file
-descriptor (either due to calling \f(CW\*(C`close\*(C'\fR explicitly or any other means,
-such as \f(CW\*(C`dup2\*(C'\fR). The reason is that you register interest in some file
-descriptor, but when it goes away, the operating system will silently drop
-this interest. If another file descriptor with the same number then is
-registered with libev, there is no efficient way to see that this is, in
-fact, a different file descriptor.
-.PP
-To avoid having to explicitly tell libev about such cases, libev follows
-the following policy:  Each time \f(CW\*(C`ev_io_set\*(C'\fR is being called, libev
-will assume that this is potentially a new file descriptor, otherwise
-it is assumed that the file descriptor stays the same. That means that
-you \fIhave\fR to call \f(CW\*(C`ev_io_set\*(C'\fR (or \f(CW\*(C`ev_io_init\*(C'\fR) when you change the
-descriptor even if the file descriptor number itself did not change.
-.PP
-This is how one would do it normally anyway, the important point is that
-the libev application should not optimise around libev but should leave
-optimisations to libev.
-.PP
-\fIThe special problem of dup'ed file descriptors\fR
-.IX Subsection "The special problem of dup'ed file descriptors"
-.PP
-Some backends (e.g. epoll), cannot register events for file descriptors,
-but only events for the underlying file descriptions. That means when you
-have \f(CW\*(C`dup ()\*(C'\fR'ed file descriptors or weirder constellations, and register
-events for them, only one file descriptor might actually receive events.
-.PP
-There is no workaround possible except not registering events
-for potentially \f(CW\*(C`dup ()\*(C'\fR'ed file descriptors, or to resort to
-\&\f(CW\*(C`EVBACKEND_SELECT\*(C'\fR or \f(CW\*(C`EVBACKEND_POLL\*(C'\fR.
-.PP
-\fIThe special problem of files\fR
-.IX Subsection "The special problem of files"
-.PP
-Many people try to use \f(CW\*(C`select\*(C'\fR (or libev) on file descriptors
-representing files, and expect it to become ready when their program
-doesn't block on disk accesses (which can take a long time on their own).
-.PP
-However, this cannot ever work in the \*(L"expected\*(R" way \- you get a readiness
-notification as soon as the kernel knows whether and how much data is
-there, and in the case of open files, that's always the case, so you
-always get a readiness notification instantly, and your read (or possibly
-write) will still block on the disk I/O.
-.PP
-Another way to view it is that in the case of sockets, pipes, character
-devices and so on, there is another party (the sender) that delivers data
-on its own, but in the case of files, there is no such thing: the disk
-will not send data on its own, simply because it doesn't know what you
-wish to read \- you would first have to request some data.
-.PP
-Since files are typically not-so-well supported by advanced notification
-mechanism, libev tries hard to emulate \s-1POSIX\s0 behaviour with respect
-to files, even though you should not use it. The reason for this is
-convenience: sometimes you want to watch \s-1STDIN\s0 or \s-1STDOUT,\s0 which is
-usually a tty, often a pipe, but also sometimes files or special devices
-(for example, \f(CW\*(C`epoll\*(C'\fR on Linux works with \fI/dev/random\fR but not with
-\&\fI/dev/urandom\fR), and even though the file might better be served with
-asynchronous I/O instead of with non-blocking I/O, it is still useful when
-it \*(L"just works\*(R" instead of freezing.
-.PP
-So avoid file descriptors pointing to files when you know it (e.g. use
-libeio), but use them when it is convenient, e.g. for \s-1STDIN/STDOUT,\s0 or
-when you rarely read from a file instead of from a socket, and want to
-reuse the same code path.
-.PP
-\fIThe special problem of fork\fR
-.IX Subsection "The special problem of fork"
-.PP
-Some backends (epoll, kqueue) do not support \f(CW\*(C`fork ()\*(C'\fR at all or exhibit
-useless behaviour. Libev fully supports fork, but needs to be told about
-it in the child if you want to continue to use it in the child.
-.PP
-To support fork in your child processes, you have to call \f(CW\*(C`ev_loop_fork
-()\*(C'\fR after a fork in the child, enable \f(CW\*(C`EVFLAG_FORKCHECK\*(C'\fR, or resort to
-\&\f(CW\*(C`EVBACKEND_SELECT\*(C'\fR or \f(CW\*(C`EVBACKEND_POLL\*(C'\fR.
-.PP
-\fIThe special problem of \s-1SIGPIPE\s0\fR
-.IX Subsection "The special problem of SIGPIPE"
-.PP
-While not really specific to libev, it is easy to forget about \f(CW\*(C`SIGPIPE\*(C'\fR:
-when writing to a pipe whose other end has been closed, your program gets
-sent a \s-1SIGPIPE,\s0 which, by default, aborts your program. For most programs
-this is sensible behaviour, for daemons, this is usually undesirable.
-.PP
-So when you encounter spurious, unexplained daemon exits, make sure you
-ignore \s-1SIGPIPE \s0(and maybe make sure you log the exit status of your daemon
-somewhere, as that would have given you a big clue).
-.PP
-\fIThe special problem of \fIaccept()\fIing when you can't\fR
-.IX Subsection "The special problem of accept()ing when you can't"
-.PP
-Many implementations of the \s-1POSIX \s0\f(CW\*(C`accept\*(C'\fR function (for example,
-found in post\-2004 Linux) have the peculiar behaviour of not removing a
-connection from the pending queue in all error cases.
-.PP
-For example, larger servers often run out of file descriptors (because
-of resource limits), causing \f(CW\*(C`accept\*(C'\fR to fail with \f(CW\*(C`ENFILE\*(C'\fR but not
-rejecting the connection, leading to libev signalling readiness on
-the next iteration again (the connection still exists after all), and
-typically causing the program to loop at 100% \s-1CPU\s0 usage.
-.PP
-Unfortunately, the set of errors that cause this issue differs between
-operating systems, there is usually little the app can do to remedy the
-situation, and no known thread-safe method of removing the connection to
-cope with overload is known (to me).
-.PP
-One of the easiest ways to handle this situation is to just ignore it
-\&\- when the program encounters an overload, it will just loop until the
-situation is over. While this is a form of busy waiting, no \s-1OS\s0 offers an
-event-based way to handle this situation, so it's the best one can do.
-.PP
-A better way to handle the situation is to log any errors other than
-\&\f(CW\*(C`EAGAIN\*(C'\fR and \f(CW\*(C`EWOULDBLOCK\*(C'\fR, making sure not to flood the log with such
-messages, and continue as usual, which at least gives the user an idea of
-what could be wrong (\*(L"raise the ulimit!\*(R"). For extra points one could stop
-the \f(CW\*(C`ev_io\*(C'\fR watcher on the listening fd \*(L"for a while\*(R", which reduces \s-1CPU\s0
-usage.
-.PP
-If your program is single-threaded, then you could also keep a dummy file
-descriptor for overload situations (e.g. by opening \fI/dev/null\fR), and
-when you run into \f(CW\*(C`ENFILE\*(C'\fR or \f(CW\*(C`EMFILE\*(C'\fR, close it, run \f(CW\*(C`accept\*(C'\fR,
-close that fd, and create a new dummy fd. This will gracefully refuse
-clients under typical overload conditions.
-.PP
-The last way to handle it is to simply log the error and \f(CW\*(C`exit\*(C'\fR, as
-is often done with \f(CW\*(C`malloc\*(C'\fR failures, but this results in an easy
-opportunity for a DoS attack.
-.PP
-\fIWatcher-Specific Functions\fR
-.IX Subsection "Watcher-Specific Functions"
-.IP "ev_io_init (ev_io *, callback, int fd, int events)" 4
-.IX Item "ev_io_init (ev_io *, callback, int fd, int events)"
-.PD 0
-.IP "ev_io_set (ev_io *, int fd, int events)" 4
-.IX Item "ev_io_set (ev_io *, int fd, int events)"
-.PD
-Configures an \f(CW\*(C`ev_io\*(C'\fR watcher. The \f(CW\*(C`fd\*(C'\fR is the file descriptor to
-receive events for and \f(CW\*(C`events\*(C'\fR is either \f(CW\*(C`EV_READ\*(C'\fR, \f(CW\*(C`EV_WRITE\*(C'\fR or
-\&\f(CW\*(C`EV_READ | EV_WRITE\*(C'\fR, to express the desire to receive the given events.
-.IP "int fd [read\-only]" 4
-.IX Item "int fd [read-only]"
-The file descriptor being watched.
-.IP "int events [read\-only]" 4
-.IX Item "int events [read-only]"
-The events being watched.
-.PP
-\fIExamples\fR
-.IX Subsection "Examples"
-.PP
-Example: Call \f(CW\*(C`stdin_readable_cb\*(C'\fR when \s-1STDIN_FILENO\s0 has become, well
-readable, but only once. Since it is likely line-buffered, you could
-attempt to read a whole line in the callback.
-.PP
-.Vb 6
-\&   static void
-\&   stdin_readable_cb (struct ev_loop *loop, ev_io *w, int revents)
-\&   {
-\&      ev_io_stop (loop, w);
-\&     .. read from stdin here (or from w\->fd) and handle any I/O errors
-\&   }
-\&
-\&   ...
-\&   struct ev_loop *loop = ev_default_init (0);
-\&   ev_io stdin_readable;
-\&   ev_io_init (&stdin_readable, stdin_readable_cb, STDIN_FILENO, EV_READ);
-\&   ev_io_start (loop, &stdin_readable);
-\&   ev_run (loop, 0);
-.Ve
-.ie n .SS """ev_timer"" \- relative and optionally repeating timeouts"
-.el .SS "\f(CWev_timer\fP \- relative and optionally repeating timeouts"
-.IX Subsection "ev_timer - relative and optionally repeating timeouts"
-Timer watchers are simple relative timers that generate an event after a
-given time, and optionally repeating in regular intervals after that.
-.PP
-The timers are based on real time, that is, if you register an event that
-times out after an hour and you reset your system clock to January last
-year, it will still time out after (roughly) one hour. \*(L"Roughly\*(R" because
-detecting time jumps is hard, and some inaccuracies are unavoidable (the
-monotonic clock option helps a lot here).
-.PP
-The callback is guaranteed to be invoked only \fIafter\fR its timeout has
-passed (not \fIat\fR, so on systems with very low-resolution clocks this
-might introduce a small delay, see \*(L"the special problem of being too
-early\*(R", below). If multiple timers become ready during the same loop
-iteration then the ones with earlier time-out values are invoked before
-ones of the same priority with later time-out values (but this is no
-longer true when a callback calls \f(CW\*(C`ev_run\*(C'\fR recursively).
-.PP
-\fIBe smart about timeouts\fR
-.IX Subsection "Be smart about timeouts"
-.PP
-Many real-world problems involve some kind of timeout, usually for error
-recovery. A typical example is an \s-1HTTP\s0 request \- if the other side hangs,
-you want to raise some error after a while.
-.PP
-What follows are some ways to handle this problem, from obvious and
-inefficient to smart and efficient.
-.PP
-In the following, a 60 second activity timeout is assumed \- a timeout that
-gets reset to 60 seconds each time there is activity (e.g. each time some
-data or other life sign was received).
-.IP "1. Use a timer and stop, reinitialise and start it on activity." 4
-.IX Item "1. Use a timer and stop, reinitialise and start it on activity."
-This is the most obvious, but not the most simple way: In the beginning,
-start the watcher:
-.Sp
-.Vb 2
-\&   ev_timer_init (timer, callback, 60., 0.);
-\&   ev_timer_start (loop, timer);
-.Ve
-.Sp
-Then, each time there is some activity, \f(CW\*(C`ev_timer_stop\*(C'\fR it, initialise it
-and start it again:
-.Sp
-.Vb 3
-\&   ev_timer_stop (loop, timer);
-\&   ev_timer_set (timer, 60., 0.);
-\&   ev_timer_start (loop, timer);
-.Ve
-.Sp
-This is relatively simple to implement, but means that each time there is
-some activity, libev will first have to remove the timer from its internal
-data structure and then add it again. Libev tries to be fast, but it's
-still not a constant-time operation.
-.ie n .IP "2. Use a timer and re-start it with ""ev_timer_again"" inactivity." 4
-.el .IP "2. Use a timer and re-start it with \f(CWev_timer_again\fR inactivity." 4
-.IX Item "2. Use a timer and re-start it with ev_timer_again inactivity."
-This is the easiest way, and involves using \f(CW\*(C`ev_timer_again\*(C'\fR instead of
-\&\f(CW\*(C`ev_timer_start\*(C'\fR.
-.Sp
-To implement this, configure an \f(CW\*(C`ev_timer\*(C'\fR with a \f(CW\*(C`repeat\*(C'\fR value
-of \f(CW60\fR and then call \f(CW\*(C`ev_timer_again\*(C'\fR at start and each time you
-successfully read or write some data. If you go into an idle state where
-you do not expect data to travel on the socket, you can \f(CW\*(C`ev_timer_stop\*(C'\fR
-the timer, and \f(CW\*(C`ev_timer_again\*(C'\fR will automatically restart it if need be.
-.Sp
-That means you can ignore both the \f(CW\*(C`ev_timer_start\*(C'\fR function and the
-\&\f(CW\*(C`after\*(C'\fR argument to \f(CW\*(C`ev_timer_set\*(C'\fR, and only ever use the \f(CW\*(C`repeat\*(C'\fR
-member and \f(CW\*(C`ev_timer_again\*(C'\fR.
-.Sp
-At start:
-.Sp
-.Vb 3
-\&   ev_init (timer, callback);
-\&   timer\->repeat = 60.;
-\&   ev_timer_again (loop, timer);
-.Ve
-.Sp
-Each time there is some activity:
-.Sp
-.Vb 1
-\&   ev_timer_again (loop, timer);
-.Ve
-.Sp
-It is even possible to change the time-out on the fly, regardless of
-whether the watcher is active or not:
-.Sp
-.Vb 2
-\&   timer\->repeat = 30.;
-\&   ev_timer_again (loop, timer);
-.Ve
-.Sp
-This is slightly more efficient then stopping/starting the timer each time
-you want to modify its timeout value, as libev does not have to completely
-remove and re-insert the timer from/into its internal data structure.
-.Sp
-It is, however, even simpler than the \*(L"obvious\*(R" way to do it.
-.IP "3. Let the timer time out, but then re-arm it as required." 4
-.IX Item "3. Let the timer time out, but then re-arm it as required."
-This method is more tricky, but usually most efficient: Most timeouts are
-relatively long compared to the intervals between other activity \- in
-our example, within 60 seconds, there are usually many I/O events with
-associated activity resets.
-.Sp
-In this case, it would be more efficient to leave the \f(CW\*(C`ev_timer\*(C'\fR alone,
-but remember the time of last activity, and check for a real timeout only
-within the callback:
-.Sp
-.Vb 3
-\&   ev_tstamp timeout = 60.;
-\&   ev_tstamp last_activity; // time of last activity
-\&   ev_timer timer;
-\&
-\&   static void
-\&   callback (EV_P_ ev_timer *w, int revents)
-\&   {
-\&     // calculate when the timeout would happen
-\&     ev_tstamp after = last_activity \- ev_now (EV_A) + timeout;
-\&
-\&     // if negative, it means we the timeout already occurred
-\&     if (after < 0.)
-\&       {
-\&         // timeout occurred, take action
-\&       }
-\&     else
-\&       {
-\&         // callback was invoked, but there was some recent 
-\&         // activity. simply restart the timer to time out
-\&         // after "after" seconds, which is the earliest time
-\&         // the timeout can occur.
-\&         ev_timer_set (w, after, 0.);
-\&         ev_timer_start (EV_A_ w);
-\&       }
-\&   }
-.Ve
-.Sp
-To summarise the callback: first calculate in how many seconds the
-timeout will occur (by calculating the absolute time when it would occur,
-\&\f(CW\*(C`last_activity + timeout\*(C'\fR, and subtracting the current time, \f(CW\*(C`ev_now
-(EV_A)\*(C'\fR from that).
-.Sp
-If this value is negative, then we are already past the timeout, i.e. we
-timed out, and need to do whatever is needed in this case.
-.Sp
-Otherwise, we now the earliest time at which the timeout would trigger,
-and simply start the timer with this timeout value.
-.Sp
-In other words, each time the callback is invoked it will check whether
-the timeout occurred. If not, it will simply reschedule itself to check
-again at the earliest time it could time out. Rinse. Repeat.
-.Sp
-This scheme causes more callback invocations (about one every 60 seconds
-minus half the average time between activity), but virtually no calls to
-libev to change the timeout.
-.Sp
-To start the machinery, simply initialise the watcher and set
-\&\f(CW\*(C`last_activity\*(C'\fR to the current time (meaning there was some activity just
-now), then call the callback, which will \*(L"do the right thing\*(R" and start
-the timer:
-.Sp
-.Vb 3
-\&   last_activity = ev_now (EV_A);
-\&   ev_init (&timer, callback);
-\&   callback (EV_A_ &timer, 0);
-.Ve
-.Sp
-When there is some activity, simply store the current time in
-\&\f(CW\*(C`last_activity\*(C'\fR, no libev calls at all:
-.Sp
-.Vb 2
-\&   if (activity detected)
-\&     last_activity = ev_now (EV_A);
-.Ve
-.Sp
-When your timeout value changes, then the timeout can be changed by simply
-providing a new value, stopping the timer and calling the callback, which
-will again do the right thing (for example, time out immediately :).
-.Sp
-.Vb 3
-\&   timeout = new_value;
-\&   ev_timer_stop (EV_A_ &timer);
-\&   callback (EV_A_ &timer, 0);
-.Ve
-.Sp
-This technique is slightly more complex, but in most cases where the
-time-out is unlikely to be triggered, much more efficient.
-.IP "4. Wee, just use a double-linked list for your timeouts." 4
-.IX Item "4. Wee, just use a double-linked list for your timeouts."
-If there is not one request, but many thousands (millions...), all
-employing some kind of timeout with the same timeout value, then one can
-do even better:
-.Sp
-When starting the timeout, calculate the timeout value and put the timeout
-at the \fIend\fR of the list.
-.Sp
-Then use an \f(CW\*(C`ev_timer\*(C'\fR to fire when the timeout at the \fIbeginning\fR of
-the list is expected to fire (for example, using the technique #3).
-.Sp
-When there is some activity, remove the timer from the list, recalculate
-the timeout, append it to the end of the list again, and make sure to
-update the \f(CW\*(C`ev_timer\*(C'\fR if it was taken from the beginning of the list.
-.Sp
-This way, one can manage an unlimited number of timeouts in O(1) time for
-starting, stopping and updating the timers, at the expense of a major
-complication, and having to use a constant timeout. The constant timeout
-ensures that the list stays sorted.
-.PP
-So which method the best?
-.PP
-Method #2 is a simple no-brain-required solution that is adequate in most
-situations. Method #3 requires a bit more thinking, but handles many cases
-better, and isn't very complicated either. In most case, choosing either
-one is fine, with #3 being better in typical situations.
-.PP
-Method #1 is almost always a bad idea, and buys you nothing. Method #4 is
-rather complicated, but extremely efficient, something that really pays
-off after the first million or so of active timers, i.e. it's usually
-overkill :)
-.PP
-\fIThe special problem of being too early\fR
-.IX Subsection "The special problem of being too early"
-.PP
-If you ask a timer to call your callback after three seconds, then
-you expect it to be invoked after three seconds \- but of course, this
-cannot be guaranteed to infinite precision. Less obviously, it cannot be
-guaranteed to any precision by libev \- imagine somebody suspending the
-process with a \s-1STOP\s0 signal for a few hours for example.
-.PP
-So, libev tries to invoke your callback as soon as possible \fIafter\fR the
-delay has occurred, but cannot guarantee this.
-.PP
-A less obvious failure mode is calling your callback too early: many event
-loops compare timestamps with a \*(L"elapsed delay >= requested delay\*(R", but
-this can cause your callback to be invoked much earlier than you would
-expect.
-.PP
-To see why, imagine a system with a clock that only offers full second
-resolution (think windows if you can't come up with a broken enough \s-1OS\s0
-yourself). If you schedule a one-second timer at the time 500.9, then the
-event loop will schedule your timeout to elapse at a system time of 500
-(500.9 truncated to the resolution) + 1, or 501.
-.PP
-If an event library looks at the timeout 0.1s later, it will see \*(L"501 >=
-501\*(R" and invoke the callback 0.1s after it was started, even though a
-one-second delay was requested \- this is being \*(L"too early\*(R", despite best
-intentions.
-.PP
-This is the reason why libev will never invoke the callback if the elapsed
-delay equals the requested delay, but only when the elapsed delay is
-larger than the requested delay. In the example above, libev would only invoke
-the callback at system time 502, or 1.1s after the timer was started.
-.PP
-So, while libev cannot guarantee that your callback will be invoked
-exactly when requested, it \fIcan\fR and \fIdoes\fR guarantee that the requested
-delay has actually elapsed, or in other words, it always errs on the \*(L"too
-late\*(R" side of things.
-.PP
-\fIThe special problem of time updates\fR
-.IX Subsection "The special problem of time updates"
-.PP
-Establishing the current time is a costly operation (it usually takes
-at least one system call): \s-1EV\s0 therefore updates its idea of the current
-time only before and after \f(CW\*(C`ev_run\*(C'\fR collects new events, which causes a
-growing difference between \f(CW\*(C`ev_now ()\*(C'\fR and \f(CW\*(C`ev_time ()\*(C'\fR when handling
-lots of events in one iteration.
-.PP
-The relative timeouts are calculated relative to the \f(CW\*(C`ev_now ()\*(C'\fR
-time. This is usually the right thing as this timestamp refers to the time
-of the event triggering whatever timeout you are modifying/starting. If
-you suspect event processing to be delayed and you \fIneed\fR to base the
-timeout on the current time, use something like the following to adjust
-for it:
-.PP
-.Vb 1
-\&   ev_timer_set (&timer, after + (ev_time () \- ev_now ()), 0.);
-.Ve
-.PP
-If the event loop is suspended for a long time, you can also force an
-update of the time returned by \f(CW\*(C`ev_now ()\*(C'\fR by calling \f(CW\*(C`ev_now_update
-()\*(C'\fR, although that will push the event time of all outstanding events
-further into the future.
-.PP
-\fIThe special problem of unsynchronised clocks\fR
-.IX Subsection "The special problem of unsynchronised clocks"
-.PP
-Modern systems have a variety of clocks \- libev itself uses the normal
-\&\*(L"wall clock\*(R" clock and, if available, the monotonic clock (to avoid time
-jumps).
-.PP
-Neither of these clocks is synchronised with each other or any other clock
-on the system, so \f(CW\*(C`ev_time ()\*(C'\fR might return a considerably different time
-than \f(CW\*(C`gettimeofday ()\*(C'\fR or \f(CW\*(C`time ()\*(C'\fR. On a GNU/Linux system, for example,
-a call to \f(CW\*(C`gettimeofday\*(C'\fR might return a second count that is one higher
-than a directly following call to \f(CW\*(C`time\*(C'\fR.
-.PP
-The moral of this is to only compare libev-related timestamps with
-\&\f(CW\*(C`ev_time ()\*(C'\fR and \f(CW\*(C`ev_now ()\*(C'\fR, at least if you want better precision than
-a second or so.
-.PP
-One more problem arises due to this lack of synchronisation: if libev uses
-the system monotonic clock and you compare timestamps from \f(CW\*(C`ev_time\*(C'\fR
-or \f(CW\*(C`ev_now\*(C'\fR from when you started your timer and when your callback is
-invoked, you will find that sometimes the callback is a bit \*(L"early\*(R".
-.PP
-This is because \f(CW\*(C`ev_timer\*(C'\fRs work in real time, not wall clock time, so
-libev makes sure your callback is not invoked before the delay happened,
-\&\fImeasured according to the real time\fR, not the system clock.
-.PP
-If your timeouts are based on a physical timescale (e.g. \*(L"time out this
-connection after 100 seconds\*(R") then this shouldn't bother you as it is
-exactly the right behaviour.
-.PP
-If you want to compare wall clock/system timestamps to your timers, then
-you need to use \f(CW\*(C`ev_periodic\*(C'\fRs, as these are based on the wall clock
-time, where your comparisons will always generate correct results.
-.PP
-\fIThe special problems of suspended animation\fR
-.IX Subsection "The special problems of suspended animation"
-.PP
-When you leave the server world it is quite customary to hit machines that
-can suspend/hibernate \- what happens to the clocks during such a suspend?
-.PP
-Some quick tests made with a Linux 2.6.28 indicate that a suspend freezes
-all processes, while the clocks (\f(CW\*(C`times\*(C'\fR, \f(CW\*(C`CLOCK_MONOTONIC\*(C'\fR) continue
-to run until the system is suspended, but they will not advance while the
-system is suspended. That means, on resume, it will be as if the program
-was frozen for a few seconds, but the suspend time will not be counted
-towards \f(CW\*(C`ev_timer\*(C'\fR when a monotonic clock source is used. The real time
-clock advanced as expected, but if it is used as sole clocksource, then a
-long suspend would be detected as a time jump by libev, and timers would
-be adjusted accordingly.
-.PP
-I would not be surprised to see different behaviour in different between
-operating systems, \s-1OS\s0 versions or even different hardware.
-.PP
-The other form of suspend (job control, or sending a \s-1SIGSTOP\s0) will see a
-time jump in the monotonic clocks and the realtime clock. If the program
-is suspended for a very long time, and monotonic clock sources are in use,
-then you can expect \f(CW\*(C`ev_timer\*(C'\fRs to expire as the full suspension time
-will be counted towards the timers. When no monotonic clock source is in
-use, then libev will again assume a timejump and adjust accordingly.
-.PP
-It might be beneficial for this latter case to call \f(CW\*(C`ev_suspend\*(C'\fR
-and \f(CW\*(C`ev_resume\*(C'\fR in code that handles \f(CW\*(C`SIGTSTP\*(C'\fR, to at least get
-deterministic behaviour in this case (you can do nothing against
-\&\f(CW\*(C`SIGSTOP\*(C'\fR).
-.PP
-\fIWatcher-Specific Functions and Data Members\fR
-.IX Subsection "Watcher-Specific Functions and Data Members"
-.IP "ev_timer_init (ev_timer *, callback, ev_tstamp after, ev_tstamp repeat)" 4
-.IX Item "ev_timer_init (ev_timer *, callback, ev_tstamp after, ev_tstamp repeat)"
-.PD 0
-.IP "ev_timer_set (ev_timer *, ev_tstamp after, ev_tstamp repeat)" 4
-.IX Item "ev_timer_set (ev_timer *, ev_tstamp after, ev_tstamp repeat)"
-.PD
-Configure the timer to trigger after \f(CW\*(C`after\*(C'\fR seconds. If \f(CW\*(C`repeat\*(C'\fR
-is \f(CW0.\fR, then it will automatically be stopped once the timeout is
-reached. If it is positive, then the timer will automatically be
-configured to trigger again \f(CW\*(C`repeat\*(C'\fR seconds later, again, and again,
-until stopped manually.
-.Sp
-The timer itself will do a best-effort at avoiding drift, that is, if
-you configure a timer to trigger every 10 seconds, then it will normally
-trigger at exactly 10 second intervals. If, however, your program cannot
-keep up with the timer (because it takes longer than those 10 seconds to
-do stuff) the timer will not fire more than once per event loop iteration.
-.IP "ev_timer_again (loop, ev_timer *)" 4
-.IX Item "ev_timer_again (loop, ev_timer *)"
-This will act as if the timer timed out, and restarts it again if it is
-repeating. It basically works like calling \f(CW\*(C`ev_timer_stop\*(C'\fR, updating the
-timeout to the \f(CW\*(C`repeat\*(C'\fR value and calling \f(CW\*(C`ev_timer_start\*(C'\fR.
-.Sp
-The exact semantics are as in the following rules, all of which will be
-applied to the watcher:
-.RS 4
-.IP "If the timer is pending, the pending status is always cleared." 4
-.IX Item "If the timer is pending, the pending status is always cleared."
-.PD 0
-.IP "If the timer is started but non-repeating, stop it (as if it timed out, without invoking it)." 4
-.IX Item "If the timer is started but non-repeating, stop it (as if it timed out, without invoking it)."
-.ie n .IP "If the timer is repeating, make the ""repeat"" value the new timeout and start the timer, if necessary." 4
-.el .IP "If the timer is repeating, make the \f(CWrepeat\fR value the new timeout and start the timer, if necessary." 4
-.IX Item "If the timer is repeating, make the repeat value the new timeout and start the timer, if necessary."
-.RE
-.RS 4
-.PD
-.Sp
-This sounds a bit complicated, see \*(L"Be smart about timeouts\*(R", above, for a
-usage example.
-.RE
-.IP "ev_tstamp ev_timer_remaining (loop, ev_timer *)" 4
-.IX Item "ev_tstamp ev_timer_remaining (loop, ev_timer *)"
-Returns the remaining time until a timer fires. If the timer is active,
-then this time is relative to the current event loop time, otherwise it's
-the timeout value currently configured.
-.Sp
-That is, after an \f(CW\*(C`ev_timer_set (w, 5, 7)\*(C'\fR, \f(CW\*(C`ev_timer_remaining\*(C'\fR returns
-\&\f(CW5\fR. When the timer is started and one second passes, \f(CW\*(C`ev_timer_remaining\*(C'\fR
-will return \f(CW4\fR. When the timer expires and is restarted, it will return
-roughly \f(CW7\fR (likely slightly less as callback invocation takes some time,
-too), and so on.
-.IP "ev_tstamp repeat [read\-write]" 4
-.IX Item "ev_tstamp repeat [read-write]"
-The current \f(CW\*(C`repeat\*(C'\fR value. Will be used each time the watcher times out
-or \f(CW\*(C`ev_timer_again\*(C'\fR is called, and determines the next timeout (if any),
-which is also when any modifications are taken into account.
-.PP
-\fIExamples\fR
-.IX Subsection "Examples"
-.PP
-Example: Create a timer that fires after 60 seconds.
-.PP
-.Vb 5
-\&   static void
-\&   one_minute_cb (struct ev_loop *loop, ev_timer *w, int revents)
-\&   {
-\&     .. one minute over, w is actually stopped right here
-\&   }
-\&
-\&   ev_timer mytimer;
-\&   ev_timer_init (&mytimer, one_minute_cb, 60., 0.);
-\&   ev_timer_start (loop, &mytimer);
-.Ve
-.PP
-Example: Create a timeout timer that times out after 10 seconds of
-inactivity.
-.PP
-.Vb 5
-\&   static void
-\&   timeout_cb (struct ev_loop *loop, ev_timer *w, int revents)
-\&   {
-\&     .. ten seconds without any activity
-\&   }
-\&
-\&   ev_timer mytimer;
-\&   ev_timer_init (&mytimer, timeout_cb, 0., 10.); /* note, only repeat used */
-\&   ev_timer_again (&mytimer); /* start timer */
-\&   ev_run (loop, 0);
-\&
-\&   // and in some piece of code that gets executed on any "activity":
-\&   // reset the timeout to start ticking again at 10 seconds
-\&   ev_timer_again (&mytimer);
-.Ve
-.ie n .SS """ev_periodic"" \- to cron or not to cron?"
-.el .SS "\f(CWev_periodic\fP \- to cron or not to cron?"
-.IX Subsection "ev_periodic - to cron or not to cron?"
-Periodic watchers are also timers of a kind, but they are very versatile
-(and unfortunately a bit complex).
-.PP
-Unlike \f(CW\*(C`ev_timer\*(C'\fR, periodic watchers are not based on real time (or
-relative time, the physical time that passes) but on wall clock time
-(absolute time, the thing you can read on your calendar or clock). The
-difference is that wall clock time can run faster or slower than real
-time, and time jumps are not uncommon (e.g. when you adjust your
-wrist-watch).
-.PP
-You can tell a periodic watcher to trigger after some specific point
-in time: for example, if you tell a periodic watcher to trigger \*(L"in 10
-seconds\*(R" (by specifying e.g. \f(CW\*(C`ev_now () + 10.\*(C'\fR, that is, an absolute time
-not a delay) and then reset your system clock to January of the previous
-year, then it will take a year or more to trigger the event (unlike an
-\&\f(CW\*(C`ev_timer\*(C'\fR, which would still trigger roughly 10 seconds after starting
-it, as it uses a relative timeout).
-.PP
-\&\f(CW\*(C`ev_periodic\*(C'\fR watchers can also be used to implement vastly more complex
-timers, such as triggering an event on each \*(L"midnight, local time\*(R", or
-other complicated rules. This cannot be done with \f(CW\*(C`ev_timer\*(C'\fR watchers, as
-those cannot react to time jumps.
-.PP
-As with timers, the callback is guaranteed to be invoked only when the
-point in time where it is supposed to trigger has passed. If multiple
-timers become ready during the same loop iteration then the ones with
-earlier time-out values are invoked before ones with later time-out values
-(but this is no longer true when a callback calls \f(CW\*(C`ev_run\*(C'\fR recursively).
-.PP
-\fIWatcher-Specific Functions and Data Members\fR
-.IX Subsection "Watcher-Specific Functions and Data Members"
-.IP "ev_periodic_init (ev_periodic *, callback, ev_tstamp offset, ev_tstamp interval, reschedule_cb)" 4
-.IX Item "ev_periodic_init (ev_periodic *, callback, ev_tstamp offset, ev_tstamp interval, reschedule_cb)"
-.PD 0
-.IP "ev_periodic_set (ev_periodic *, ev_tstamp offset, ev_tstamp interval, reschedule_cb)" 4
-.IX Item "ev_periodic_set (ev_periodic *, ev_tstamp offset, ev_tstamp interval, reschedule_cb)"
-.PD
-Lots of arguments, let's sort it out... There are basically three modes of
-operation, and we will explain them from simplest to most complex:
-.RS 4
-.IP "\(bu" 4
-absolute timer (offset = absolute time, interval = 0, reschedule_cb = 0)
-.Sp
-In this configuration the watcher triggers an event after the wall clock
-time \f(CW\*(C`offset\*(C'\fR has passed. It will not repeat and will not adjust when a
-time jump occurs, that is, if it is to be run at January 1st 2011 then it
-will be stopped and invoked when the system clock reaches or surpasses
-this point in time.
-.IP "\(bu" 4
-repeating interval timer (offset = offset within interval, interval > 0, reschedule_cb = 0)
-.Sp
-In this mode the watcher will always be scheduled to time out at the next
-\&\f(CW\*(C`offset + N * interval\*(C'\fR time (for some integer N, which can also be
-negative) and then repeat, regardless of any time jumps. The \f(CW\*(C`offset\*(C'\fR
-argument is merely an offset into the \f(CW\*(C`interval\*(C'\fR periods.
-.Sp
-This can be used to create timers that do not drift with respect to the
-system clock, for example, here is an \f(CW\*(C`ev_periodic\*(C'\fR that triggers each
-hour, on the hour (with respect to \s-1UTC\s0):
-.Sp
-.Vb 1
-\&   ev_periodic_set (&periodic, 0., 3600., 0);
-.Ve
-.Sp
-This doesn't mean there will always be 3600 seconds in between triggers,
-but only that the callback will be called when the system time shows a
-full hour (\s-1UTC\s0), or more correctly, when the system time is evenly divisible
-by 3600.
-.Sp
-Another way to think about it (for the mathematically inclined) is that
-\&\f(CW\*(C`ev_periodic\*(C'\fR will try to run the callback in this mode at the next possible
-time where \f(CW\*(C`time = offset (mod interval)\*(C'\fR, regardless of any time jumps.
-.Sp
-The \f(CW\*(C`interval\*(C'\fR \fI\s-1MUST\s0\fR be positive, and for numerical stability, the
-interval value should be higher than \f(CW\*(C`1/8192\*(C'\fR (which is around 100
-microseconds) and \f(CW\*(C`offset\*(C'\fR should be higher than \f(CW0\fR and should have
-at most a similar magnitude as the current time (say, within a factor of
-ten). Typical values for offset are, in fact, \f(CW0\fR or something between
-\&\f(CW0\fR and \f(CW\*(C`interval\*(C'\fR, which is also the recommended range.
-.Sp
-Note also that there is an upper limit to how often a timer can fire (\s-1CPU\s0
-speed for example), so if \f(CW\*(C`interval\*(C'\fR is very small then timing stability
-will of course deteriorate. Libev itself tries to be exact to be about one
-millisecond (if the \s-1OS\s0 supports it and the machine is fast enough).
-.IP "\(bu" 4
-manual reschedule mode (offset ignored, interval ignored, reschedule_cb = callback)
-.Sp
-In this mode the values for \f(CW\*(C`interval\*(C'\fR and \f(CW\*(C`offset\*(C'\fR are both being
-ignored. Instead, each time the periodic watcher gets scheduled, the
-reschedule callback will be called with the watcher as first, and the
-current time as second argument.
-.Sp
-\&\s-1NOTE: \s0\fIThis callback \s-1MUST NOT\s0 stop or destroy any periodic watcher, ever,
-or make \s-1ANY\s0 other event loop modifications whatsoever, unless explicitly
-allowed by documentation here\fR.
-.Sp
-If you need to stop it, return \f(CW\*(C`now + 1e30\*(C'\fR (or so, fudge fudge) and stop
-it afterwards (e.g. by starting an \f(CW\*(C`ev_prepare\*(C'\fR watcher, which is the
-only event loop modification you are allowed to do).
-.Sp
-The callback prototype is \f(CW\*(C`ev_tstamp (*reschedule_cb)(ev_periodic
-*w, ev_tstamp now)\*(C'\fR, e.g.:
-.Sp
-.Vb 5
-\&   static ev_tstamp
-\&   my_rescheduler (ev_periodic *w, ev_tstamp now)
-\&   {
-\&     return now + 60.;
-\&   }
-.Ve
-.Sp
-It must return the next time to trigger, based on the passed time value
-(that is, the lowest time value larger than to the second argument). It
-will usually be called just before the callback will be triggered, but
-might be called at other times, too.
-.Sp
-\&\s-1NOTE: \s0\fIThis callback must always return a time that is higher than or
-equal to the passed \f(CI\*(C`now\*(C'\fI value\fR.
-.Sp
-This can be used to create very complex timers, such as a timer that
-triggers on \*(L"next midnight, local time\*(R". To do this, you would calculate the
-next midnight after \f(CW\*(C`now\*(C'\fR and return the timestamp value for this. How
-you do this is, again, up to you (but it is not trivial, which is the main
-reason I omitted it as an example).
-.RE
-.RS 4
-.RE
-.IP "ev_periodic_again (loop, ev_periodic *)" 4
-.IX Item "ev_periodic_again (loop, ev_periodic *)"
-Simply stops and restarts the periodic watcher again. This is only useful
-when you changed some parameters or the reschedule callback would return
-a different time than the last time it was called (e.g. in a crond like
-program when the crontabs have changed).
-.IP "ev_tstamp ev_periodic_at (ev_periodic *)" 4
-.IX Item "ev_tstamp ev_periodic_at (ev_periodic *)"
-When active, returns the absolute time that the watcher is supposed
-to trigger next. This is not the same as the \f(CW\*(C`offset\*(C'\fR argument to
-\&\f(CW\*(C`ev_periodic_set\*(C'\fR, but indeed works even in interval and manual
-rescheduling modes.
-.IP "ev_tstamp offset [read\-write]" 4
-.IX Item "ev_tstamp offset [read-write]"
-When repeating, this contains the offset value, otherwise this is the
-absolute point in time (the \f(CW\*(C`offset\*(C'\fR value passed to \f(CW\*(C`ev_periodic_set\*(C'\fR,
-although libev might modify this value for better numerical stability).
-.Sp
-Can be modified any time, but changes only take effect when the periodic
-timer fires or \f(CW\*(C`ev_periodic_again\*(C'\fR is being called.
-.IP "ev_tstamp interval [read\-write]" 4
-.IX Item "ev_tstamp interval [read-write]"
-The current interval value. Can be modified any time, but changes only
-take effect when the periodic timer fires or \f(CW\*(C`ev_periodic_again\*(C'\fR is being
-called.
-.IP "ev_tstamp (*reschedule_cb)(ev_periodic *w, ev_tstamp now) [read\-write]" 4
-.IX Item "ev_tstamp (*reschedule_cb)(ev_periodic *w, ev_tstamp now) [read-write]"
-The current reschedule callback, or \f(CW0\fR, if this functionality is
-switched off. Can be changed any time, but changes only take effect when
-the periodic timer fires or \f(CW\*(C`ev_periodic_again\*(C'\fR is being called.
-.PP
-\fIExamples\fR
-.IX Subsection "Examples"
-.PP
-Example: Call a callback every hour, or, more precisely, whenever the
-system time is divisible by 3600. The callback invocation times have
-potentially a lot of jitter, but good long-term stability.
-.PP
-.Vb 5
-\&   static void
-\&   clock_cb (struct ev_loop *loop, ev_periodic *w, int revents)
-\&   {
-\&     ... its now a full hour (UTC, or TAI or whatever your clock follows)
-\&   }
-\&
-\&   ev_periodic hourly_tick;
-\&   ev_periodic_init (&hourly_tick, clock_cb, 0., 3600., 0);
-\&   ev_periodic_start (loop, &hourly_tick);
-.Ve
-.PP
-Example: The same as above, but use a reschedule callback to do it:
-.PP
-.Vb 1
-\&   #include <math.h>
-\&
-\&   static ev_tstamp
-\&   my_scheduler_cb (ev_periodic *w, ev_tstamp now)
-\&   {
-\&     return now + (3600. \- fmod (now, 3600.));
-\&   }
-\&
-\&   ev_periodic_init (&hourly_tick, clock_cb, 0., 0., my_scheduler_cb);
-.Ve
-.PP
-Example: Call a callback every hour, starting now:
-.PP
-.Vb 4
-\&   ev_periodic hourly_tick;
-\&   ev_periodic_init (&hourly_tick, clock_cb,
-\&                     fmod (ev_now (loop), 3600.), 3600., 0);
-\&   ev_periodic_start (loop, &hourly_tick);
-.Ve
-.ie n .SS """ev_signal"" \- signal me when a signal gets signalled!"
-.el .SS "\f(CWev_signal\fP \- signal me when a signal gets signalled!"
-.IX Subsection "ev_signal - signal me when a signal gets signalled!"
-Signal watchers will trigger an event when the process receives a specific
-signal one or more times. Even though signals are very asynchronous, libev
-will try its best to deliver signals synchronously, i.e. as part of the
-normal event processing, like any other event.
-.PP
-If you want signals to be delivered truly asynchronously, just use
-\&\f(CW\*(C`sigaction\*(C'\fR as you would do without libev and forget about sharing
-the signal. You can even use \f(CW\*(C`ev_async\*(C'\fR from a signal handler to
-synchronously wake up an event loop.
-.PP
-You can configure as many watchers as you like for the same signal, but
-only within the same loop, i.e. you can watch for \f(CW\*(C`SIGINT\*(C'\fR in your
-default loop and for \f(CW\*(C`SIGIO\*(C'\fR in another loop, but you cannot watch for
-\&\f(CW\*(C`SIGINT\*(C'\fR in both the default loop and another loop at the same time. At
-the moment, \f(CW\*(C`SIGCHLD\*(C'\fR is permanently tied to the default loop.
-.PP
-Only after the first watcher for a signal is started will libev actually
-register something with the kernel. It thus coexists with your own signal
-handlers as long as you don't register any with libev for the same signal.
-.PP
-If possible and supported, libev will install its handlers with
-\&\f(CW\*(C`SA_RESTART\*(C'\fR (or equivalent) behaviour enabled, so system calls should
-not be unduly interrupted. If you have a problem with system calls getting
-interrupted by signals you can block all signals in an \f(CW\*(C`ev_check\*(C'\fR watcher
-and unblock them in an \f(CW\*(C`ev_prepare\*(C'\fR watcher.
-.PP
-\fIThe special problem of inheritance over fork/execve/pthread_create\fR
-.IX Subsection "The special problem of inheritance over fork/execve/pthread_create"
-.PP
-Both the signal mask (\f(CW\*(C`sigprocmask\*(C'\fR) and the signal disposition
-(\f(CW\*(C`sigaction\*(C'\fR) are unspecified after starting a signal watcher (and after
-stopping it again), that is, libev might or might not block the signal,
-and might or might not set or restore the installed signal handler (but
-see \f(CW\*(C`EVFLAG_NOSIGMASK\*(C'\fR).
-.PP
-While this does not matter for the signal disposition (libev never
-sets signals to \f(CW\*(C`SIG_IGN\*(C'\fR, so handlers will be reset to \f(CW\*(C`SIG_DFL\*(C'\fR on
-\&\f(CW\*(C`execve\*(C'\fR), this matters for the signal mask: many programs do not expect
-certain signals to be blocked.
-.PP
-This means that before calling \f(CW\*(C`exec\*(C'\fR (from the child) you should reset
-the signal mask to whatever \*(L"default\*(R" you expect (all clear is a good
-choice usually).
-.PP
-The simplest way to ensure that the signal mask is reset in the child is
-to install a fork handler with \f(CW\*(C`pthread_atfork\*(C'\fR that resets it. That will
-catch fork calls done by libraries (such as the libc) as well.
-.PP
-In current versions of libev, the signal will not be blocked indefinitely
-unless you use the \f(CW\*(C`signalfd\*(C'\fR \s-1API \s0(\f(CW\*(C`EV_SIGNALFD\*(C'\fR). While this reduces
-the window of opportunity for problems, it will not go away, as libev
-\&\fIhas\fR to modify the signal mask, at least temporarily.
-.PP
-So I can't stress this enough: \fIIf you do not reset your signal mask when
-you expect it to be empty, you have a race condition in your code\fR. This
-is not a libev-specific thing, this is true for most event libraries.
-.PP
-\fIThe special problem of threads signal handling\fR
-.IX Subsection "The special problem of threads signal handling"
-.PP
-\&\s-1POSIX\s0 threads has problematic signal handling semantics, specifically,
-a lot of functionality (sigfd, sigwait etc.) only really works if all
-threads in a process block signals, which is hard to achieve.
-.PP
-When you want to use sigwait (or mix libev signal handling with your own
-for the same signals), you can tackle this problem by globally blocking
-all signals before creating any threads (or creating them with a fully set
-sigprocmask) and also specifying the \f(CW\*(C`EVFLAG_NOSIGMASK\*(C'\fR when creating
-loops. Then designate one thread as \*(L"signal receiver thread\*(R" which handles
-these signals. You can pass on any signals that libev might be interested
-in by calling \f(CW\*(C`ev_feed_signal\*(C'\fR.
-.PP
-\fIWatcher-Specific Functions and Data Members\fR
-.IX Subsection "Watcher-Specific Functions and Data Members"
-.IP "ev_signal_init (ev_signal *, callback, int signum)" 4
-.IX Item "ev_signal_init (ev_signal *, callback, int signum)"
-.PD 0
-.IP "ev_signal_set (ev_signal *, int signum)" 4
-.IX Item "ev_signal_set (ev_signal *, int signum)"
-.PD
-Configures the watcher to trigger on the given signal number (usually one
-of the \f(CW\*(C`SIGxxx\*(C'\fR constants).
-.IP "int signum [read\-only]" 4
-.IX Item "int signum [read-only]"
-The signal the watcher watches out for.
-.PP
-\fIExamples\fR
-.IX Subsection "Examples"
-.PP
-Example: Try to exit cleanly on \s-1SIGINT.\s0
-.PP
-.Vb 5
-\&   static void
-\&   sigint_cb (struct ev_loop *loop, ev_signal *w, int revents)
-\&   {
-\&     ev_break (loop, EVBREAK_ALL);
-\&   }
-\&
-\&   ev_signal signal_watcher;
-\&   ev_signal_init (&signal_watcher, sigint_cb, SIGINT);
-\&   ev_signal_start (loop, &signal_watcher);
-.Ve
-.ie n .SS """ev_child"" \- watch out for process status changes"
-.el .SS "\f(CWev_child\fP \- watch out for process status changes"
-.IX Subsection "ev_child - watch out for process status changes"
-Child watchers trigger when your process receives a \s-1SIGCHLD\s0 in response to
-some child status changes (most typically when a child of yours dies or
-exits). It is permissible to install a child watcher \fIafter\fR the child
-has been forked (which implies it might have already exited), as long
-as the event loop isn't entered (or is continued from a watcher), i.e.,
-forking and then immediately registering a watcher for the child is fine,
-but forking and registering a watcher a few event loop iterations later or
-in the next callback invocation is not.
-.PP
-Only the default event loop is capable of handling signals, and therefore
-you can only register child watchers in the default event loop.
-.PP
-Due to some design glitches inside libev, child watchers will always be
-handled at maximum priority (their priority is set to \f(CW\*(C`EV_MAXPRI\*(C'\fR by
-libev)
-.PP
-\fIProcess Interaction\fR
-.IX Subsection "Process Interaction"
-.PP
-Libev grabs \f(CW\*(C`SIGCHLD\*(C'\fR as soon as the default event loop is
-initialised. This is necessary to guarantee proper behaviour even if the
-first child watcher is started after the child exits. The occurrence
-of \f(CW\*(C`SIGCHLD\*(C'\fR is recorded asynchronously, but child reaping is done
-synchronously as part of the event loop processing. Libev always reaps all
-children, even ones not watched.
-.PP
-\fIOverriding the Built-In Processing\fR
-.IX Subsection "Overriding the Built-In Processing"
-.PP
-Libev offers no special support for overriding the built-in child
-processing, but if your application collides with libev's default child
-handler, you can override it easily by installing your own handler for
-\&\f(CW\*(C`SIGCHLD\*(C'\fR after initialising the default loop, and making sure the
-default loop never gets destroyed. You are encouraged, however, to use an
-event-based approach to child reaping and thus use libev's support for
-that, so other libev users can use \f(CW\*(C`ev_child\*(C'\fR watchers freely.
-.PP
-\fIStopping the Child Watcher\fR
-.IX Subsection "Stopping the Child Watcher"
-.PP
-Currently, the child watcher never gets stopped, even when the
-child terminates, so normally one needs to stop the watcher in the
-callback. Future versions of libev might stop the watcher automatically
-when a child exit is detected (calling \f(CW\*(C`ev_child_stop\*(C'\fR twice is not a
-problem).
-.PP
-\fIWatcher-Specific Functions and Data Members\fR
-.IX Subsection "Watcher-Specific Functions and Data Members"
-.IP "ev_child_init (ev_child *, callback, int pid, int trace)" 4
-.IX Item "ev_child_init (ev_child *, callback, int pid, int trace)"
-.PD 0
-.IP "ev_child_set (ev_child *, int pid, int trace)" 4
-.IX Item "ev_child_set (ev_child *, int pid, int trace)"
-.PD
-Configures the watcher to wait for status changes of process \f(CW\*(C`pid\*(C'\fR (or
-\&\fIany\fR process if \f(CW\*(C`pid\*(C'\fR is specified as \f(CW0\fR). The callback can look
-at the \f(CW\*(C`rstatus\*(C'\fR member of the \f(CW\*(C`ev_child\*(C'\fR watcher structure to see
-the status word (use the macros from \f(CW\*(C`sys/wait.h\*(C'\fR and see your systems
-\&\f(CW\*(C`waitpid\*(C'\fR documentation). The \f(CW\*(C`rpid\*(C'\fR member contains the pid of the
-process causing the status change. \f(CW\*(C`trace\*(C'\fR must be either \f(CW0\fR (only
-activate the watcher when the process terminates) or \f(CW1\fR (additionally
-activate the watcher when the process is stopped or continued).
-.IP "int pid [read\-only]" 4
-.IX Item "int pid [read-only]"
-The process id this watcher watches out for, or \f(CW0\fR, meaning any process id.
-.IP "int rpid [read\-write]" 4
-.IX Item "int rpid [read-write]"
-The process id that detected a status change.
-.IP "int rstatus [read\-write]" 4
-.IX Item "int rstatus [read-write]"
-The process exit/trace status caused by \f(CW\*(C`rpid\*(C'\fR (see your systems
-\&\f(CW\*(C`waitpid\*(C'\fR and \f(CW\*(C`sys/wait.h\*(C'\fR documentation for details).
-.PP
-\fIExamples\fR
-.IX Subsection "Examples"
-.PP
-Example: \f(CW\*(C`fork()\*(C'\fR a new process and install a child handler to wait for
-its completion.
-.PP
-.Vb 1
-\&   ev_child cw;
-\&
-\&   static void
-\&   child_cb (EV_P_ ev_child *w, int revents)
-\&   {
-\&     ev_child_stop (EV_A_ w);
-\&     printf ("process %d exited with status %x\en", w\->rpid, w\->rstatus);
-\&   }
-\&
-\&   pid_t pid = fork ();
-\&
-\&   if (pid < 0)
-\&     // error
-\&   else if (pid == 0)
-\&     {
-\&       // the forked child executes here
-\&       exit (1);
-\&     }
-\&   else
-\&     {
-\&       ev_child_init (&cw, child_cb, pid, 0);
-\&       ev_child_start (EV_DEFAULT_ &cw);
-\&     }
-.Ve
-.ie n .SS """ev_stat"" \- did the file attributes just change?"
-.el .SS "\f(CWev_stat\fP \- did the file attributes just change?"
-.IX Subsection "ev_stat - did the file attributes just change?"
-This watches a file system path for attribute changes. That is, it calls
-\&\f(CW\*(C`stat\*(C'\fR on that path in regular intervals (or when the \s-1OS\s0 says it changed)
-and sees if it changed compared to the last time, invoking the callback
-if it did. Starting the watcher \f(CW\*(C`stat\*(C'\fR's the file, so only changes that
-happen after the watcher has been started will be reported.
-.PP
-The path does not need to exist: changing from \*(L"path exists\*(R" to \*(L"path does
-not exist\*(R" is a status change like any other. The condition \*(L"path does not
-exist\*(R" (or more correctly \*(L"path cannot be stat'ed\*(R") is signified by the
-\&\f(CW\*(C`st_nlink\*(C'\fR field being zero (which is otherwise always forced to be at
-least one) and all the other fields of the stat buffer having unspecified
-contents.
-.PP
-The path \fImust not\fR end in a slash or contain special components such as
-\&\f(CW\*(C`.\*(C'\fR or \f(CW\*(C`..\*(C'\fR. The path \fIshould\fR be absolute: If it is relative and
-your working directory changes, then the behaviour is undefined.
-.PP
-Since there is no portable change notification interface available, the
-portable implementation simply calls \f(CWstat(2)\fR regularly on the path
-to see if it changed somehow. You can specify a recommended polling
-interval for this case. If you specify a polling interval of \f(CW0\fR (highly
-recommended!) then a \fIsuitable, unspecified default\fR value will be used
-(which you can expect to be around five seconds, although this might
-change dynamically). Libev will also impose a minimum interval which is
-currently around \f(CW0.1\fR, but that's usually overkill.
-.PP
-This watcher type is not meant for massive numbers of stat watchers,
-as even with OS-supported change notifications, this can be
-resource-intensive.
-.PP
-At the time of this writing, the only OS-specific interface implemented
-is the Linux inotify interface (implementing kqueue support is left as an
-exercise for the reader. Note, however, that the author sees no way of
-implementing \f(CW\*(C`ev_stat\*(C'\fR semantics with kqueue, except as a hint).
-.PP
-\fI\s-1ABI\s0 Issues (Largefile Support)\fR
-.IX Subsection "ABI Issues (Largefile Support)"
-.PP
-Libev by default (unless the user overrides this) uses the default
-compilation environment, which means that on systems with large file
-support disabled by default, you get the 32 bit version of the stat
-structure. When using the library from programs that change the \s-1ABI\s0 to
-use 64 bit file offsets the programs will fail. In that case you have to
-compile libev with the same flags to get binary compatibility. This is
-obviously the case with any flags that change the \s-1ABI,\s0 but the problem is
-most noticeably displayed with ev_stat and large file support.
-.PP
-The solution for this is to lobby your distribution maker to make large
-file interfaces available by default (as e.g. FreeBSD does) and not
-optional. Libev cannot simply switch on large file support because it has
-to exchange stat structures with application programs compiled using the
-default compilation environment.
-.PP
-\fIInotify and Kqueue\fR
-.IX Subsection "Inotify and Kqueue"
-.PP
-When \f(CW\*(C`inotify (7)\*(C'\fR support has been compiled into libev and present at
-runtime, it will be used to speed up change detection where possible. The
-inotify descriptor will be created lazily when the first \f(CW\*(C`ev_stat\*(C'\fR
-watcher is being started.
-.PP
-Inotify presence does not change the semantics of \f(CW\*(C`ev_stat\*(C'\fR watchers
-except that changes might be detected earlier, and in some cases, to avoid
-making regular \f(CW\*(C`stat\*(C'\fR calls. Even in the presence of inotify support
-there are many cases where libev has to resort to regular \f(CW\*(C`stat\*(C'\fR polling,
-but as long as kernel 2.6.25 or newer is used (2.6.24 and older have too
-many bugs), the path exists (i.e. stat succeeds), and the path resides on
-a local filesystem (libev currently assumes only ext2/3, jfs, reiserfs and
-xfs are fully working) libev usually gets away without polling.
-.PP
-There is no support for kqueue, as apparently it cannot be used to
-implement this functionality, due to the requirement of having a file
-descriptor open on the object at all times, and detecting renames, unlinks
-etc. is difficult.
-.PP
-\fI\f(CI\*(C`stat ()\*(C'\fI is a synchronous operation\fR
-.IX Subsection "stat () is a synchronous operation"
-.PP
-Libev doesn't normally do any kind of I/O itself, and so is not blocking
-the process. The exception are \f(CW\*(C`ev_stat\*(C'\fR watchers \- those call \f(CW\*(C`stat
-()\*(C'\fR, which is a synchronous operation.
-.PP
-For local paths, this usually doesn't matter: unless the system is very
-busy or the intervals between stat's are large, a stat call will be fast,
-as the path data is usually in memory already (except when starting the
-watcher).
-.PP
-For networked file systems, calling \f(CW\*(C`stat ()\*(C'\fR can block an indefinite
-time due to network issues, and even under good conditions, a stat call
-often takes multiple milliseconds.
-.PP
-Therefore, it is best to avoid using \f(CW\*(C`ev_stat\*(C'\fR watchers on networked
-paths, although this is fully supported by libev.
-.PP
-\fIThe special problem of stat time resolution\fR
-.IX Subsection "The special problem of stat time resolution"
-.PP
-The \f(CW\*(C`stat ()\*(C'\fR system call only supports full-second resolution portably,
-and even on systems where the resolution is higher, most file systems
-still only support whole seconds.
-.PP
-That means that, if the time is the only thing that changes, you can
-easily miss updates: on the first update, \f(CW\*(C`ev_stat\*(C'\fR detects a change and
-calls your callback, which does something. When there is another update
-within the same second, \f(CW\*(C`ev_stat\*(C'\fR will be unable to detect unless the
-stat data does change in other ways (e.g. file size).
-.PP
-The solution to this is to delay acting on a change for slightly more
-than a second (or till slightly after the next full second boundary), using
-a roughly one-second-delay \f(CW\*(C`ev_timer\*(C'\fR (e.g. \f(CW\*(C`ev_timer_set (w, 0., 1.02);
-ev_timer_again (loop, w)\*(C'\fR).
-.PP
-The \f(CW.02\fR offset is added to work around small timing inconsistencies
-of some operating systems (where the second counter of the current time
-might be be delayed. One such system is the Linux kernel, where a call to
-\&\f(CW\*(C`gettimeofday\*(C'\fR might return a timestamp with a full second later than
-a subsequent \f(CW\*(C`time\*(C'\fR call \- if the equivalent of \f(CW\*(C`time ()\*(C'\fR is used to
-update file times then there will be a small window where the kernel uses
-the previous second to update file times but libev might already execute
-the timer callback).
-.PP
-\fIWatcher-Specific Functions and Data Members\fR
-.IX Subsection "Watcher-Specific Functions and Data Members"
-.IP "ev_stat_init (ev_stat *, callback, const char *path, ev_tstamp interval)" 4
-.IX Item "ev_stat_init (ev_stat *, callback, const char *path, ev_tstamp interval)"
-.PD 0
-.IP "ev_stat_set (ev_stat *, const char *path, ev_tstamp interval)" 4
-.IX Item "ev_stat_set (ev_stat *, const char *path, ev_tstamp interval)"
-.PD
-Configures the watcher to wait for status changes of the given
-\&\f(CW\*(C`path\*(C'\fR. The \f(CW\*(C`interval\*(C'\fR is a hint on how quickly a change is expected to
-be detected and should normally be specified as \f(CW0\fR to let libev choose
-a suitable value. The memory pointed to by \f(CW\*(C`path\*(C'\fR must point to the same
-path for as long as the watcher is active.
-.Sp
-The callback will receive an \f(CW\*(C`EV_STAT\*(C'\fR event when a change was detected,
-relative to the attributes at the time the watcher was started (or the
-last change was detected).
-.IP "ev_stat_stat (loop, ev_stat *)" 4
-.IX Item "ev_stat_stat (loop, ev_stat *)"
-Updates the stat buffer immediately with new values. If you change the
-watched path in your callback, you could call this function to avoid
-detecting this change (while introducing a race condition if you are not
-the only one changing the path). Can also be useful simply to find out the
-new values.
-.IP "ev_statdata attr [read\-only]" 4
-.IX Item "ev_statdata attr [read-only]"
-The most-recently detected attributes of the file. Although the type is
-\&\f(CW\*(C`ev_statdata\*(C'\fR, this is usually the (or one of the) \f(CW\*(C`struct stat\*(C'\fR types
-suitable for your system, but you can only rely on the POSIX-standardised
-members to be present. If the \f(CW\*(C`st_nlink\*(C'\fR member is \f(CW0\fR, then there was
-some error while \f(CW\*(C`stat\*(C'\fRing the file.
-.IP "ev_statdata prev [read\-only]" 4
-.IX Item "ev_statdata prev [read-only]"
-The previous attributes of the file. The callback gets invoked whenever
-\&\f(CW\*(C`prev\*(C'\fR != \f(CW\*(C`attr\*(C'\fR, or, more precisely, one or more of these members
-differ: \f(CW\*(C`st_dev\*(C'\fR, \f(CW\*(C`st_ino\*(C'\fR, \f(CW\*(C`st_mode\*(C'\fR, \f(CW\*(C`st_nlink\*(C'\fR, \f(CW\*(C`st_uid\*(C'\fR,
-\&\f(CW\*(C`st_gid\*(C'\fR, \f(CW\*(C`st_rdev\*(C'\fR, \f(CW\*(C`st_size\*(C'\fR, \f(CW\*(C`st_atime\*(C'\fR, \f(CW\*(C`st_mtime\*(C'\fR, \f(CW\*(C`st_ctime\*(C'\fR.
-.IP "ev_tstamp interval [read\-only]" 4
-.IX Item "ev_tstamp interval [read-only]"
-The specified interval.
-.IP "const char *path [read\-only]" 4
-.IX Item "const char *path [read-only]"
-The file system path that is being watched.
-.PP
-\fIExamples\fR
-.IX Subsection "Examples"
-.PP
-Example: Watch \f(CW\*(C`/etc/passwd\*(C'\fR for attribute changes.
-.PP
-.Vb 10
-\&   static void
-\&   passwd_cb (struct ev_loop *loop, ev_stat *w, int revents)
-\&   {
-\&     /* /etc/passwd changed in some way */
-\&     if (w\->attr.st_nlink)
-\&       {
-\&         printf ("passwd current size  %ld\en", (long)w\->attr.st_size);
-\&         printf ("passwd current atime %ld\en", (long)w\->attr.st_mtime);
-\&         printf ("passwd current mtime %ld\en", (long)w\->attr.st_mtime);
-\&       }
-\&     else
-\&       /* you shalt not abuse printf for puts */
-\&       puts ("wow, /etc/passwd is not there, expect problems. "
-\&             "if this is windows, they already arrived\en");
-\&   }
-\&
-\&   ...
-\&   ev_stat passwd;
-\&
-\&   ev_stat_init (&passwd, passwd_cb, "/etc/passwd", 0.);
-\&   ev_stat_start (loop, &passwd);
-.Ve
-.PP
-Example: Like above, but additionally use a one-second delay so we do not
-miss updates (however, frequent updates will delay processing, too, so
-one might do the work both on \f(CW\*(C`ev_stat\*(C'\fR callback invocation \fIand\fR on
-\&\f(CW\*(C`ev_timer\*(C'\fR callback invocation).
-.PP
-.Vb 2
-\&   static ev_stat passwd;
-\&   static ev_timer timer;
-\&
-\&   static void
-\&   timer_cb (EV_P_ ev_timer *w, int revents)
-\&   {
-\&     ev_timer_stop (EV_A_ w);
-\&
-\&     /* now it\*(Aqs one second after the most recent passwd change */
-\&   }
-\&
-\&   static void
-\&   stat_cb (EV_P_ ev_stat *w, int revents)
-\&   {
-\&     /* reset the one\-second timer */
-\&     ev_timer_again (EV_A_ &timer);
-\&   }
-\&
-\&   ...
-\&   ev_stat_init (&passwd, stat_cb, "/etc/passwd", 0.);
-\&   ev_stat_start (loop, &passwd);
-\&   ev_timer_init (&timer, timer_cb, 0., 1.02);
-.Ve
-.ie n .SS """ev_idle"" \- when you've got nothing better to do..."
-.el .SS "\f(CWev_idle\fP \- when you've got nothing better to do..."
-.IX Subsection "ev_idle - when you've got nothing better to do..."
-Idle watchers trigger events when no other events of the same or higher
-priority are pending (prepare, check and other idle watchers do not count
-as receiving \*(L"events\*(R").
-.PP
-That is, as long as your process is busy handling sockets or timeouts
-(or even signals, imagine) of the same or higher priority it will not be
-triggered. But when your process is idle (or only lower-priority watchers
-are pending), the idle watchers are being called once per event loop
-iteration \- until stopped, that is, or your process receives more events
-and becomes busy again with higher priority stuff.
-.PP
-The most noteworthy effect is that as long as any idle watchers are
-active, the process will not block when waiting for new events.
-.PP
-Apart from keeping your process non-blocking (which is a useful
-effect on its own sometimes), idle watchers are a good place to do
-\&\*(L"pseudo-background processing\*(R", or delay processing stuff to after the
-event loop has handled all outstanding events.
-.PP
-\fIAbusing an \f(CI\*(C`ev_idle\*(C'\fI watcher for its side-effect\fR
-.IX Subsection "Abusing an ev_idle watcher for its side-effect"
-.PP
-As long as there is at least one active idle watcher, libev will never
-sleep unnecessarily. Or in other words, it will loop as fast as possible.
-For this to work, the idle watcher doesn't need to be invoked at all \- the
-lowest priority will do.
-.PP
-This mode of operation can be useful together with an \f(CW\*(C`ev_check\*(C'\fR watcher,
-to do something on each event loop iteration \- for example to balance load
-between different connections.
-.PP
-See \*(L"Abusing an ev_check watcher for its side-effect\*(R" for a longer
-example.
-.PP
-\fIWatcher-Specific Functions and Data Members\fR
-.IX Subsection "Watcher-Specific Functions and Data Members"
-.IP "ev_idle_init (ev_idle *, callback)" 4
-.IX Item "ev_idle_init (ev_idle *, callback)"
-Initialises and configures the idle watcher \- it has no parameters of any
-kind. There is a \f(CW\*(C`ev_idle_set\*(C'\fR macro, but using it is utterly pointless,
-believe me.
-.PP
-\fIExamples\fR
-.IX Subsection "Examples"
-.PP
-Example: Dynamically allocate an \f(CW\*(C`ev_idle\*(C'\fR watcher, start it, and in the
-callback, free it. Also, use no error checking, as usual.
-.PP
-.Vb 5
-\&   static void
-\&   idle_cb (struct ev_loop *loop, ev_idle *w, int revents)
-\&   {
-\&     // stop the watcher
-\&     ev_idle_stop (loop, w);
-\&
-\&     // now we can free it
-\&     free (w);
-\&
-\&     // now do something you wanted to do when the program has
-\&     // no longer anything immediate to do.
-\&   }
-\&
-\&   ev_idle *idle_watcher = malloc (sizeof (ev_idle));
-\&   ev_idle_init (idle_watcher, idle_cb);
-\&   ev_idle_start (loop, idle_watcher);
-.Ve
-.ie n .SS """ev_prepare"" and ""ev_check"" \- customise your event loop!"
-.el .SS "\f(CWev_prepare\fP and \f(CWev_check\fP \- customise your event loop!"
-.IX Subsection "ev_prepare and ev_check - customise your event loop!"
-Prepare and check watchers are often (but not always) used in pairs:
-prepare watchers get invoked before the process blocks and check watchers
-afterwards.
-.PP
-You \fImust not\fR call \f(CW\*(C`ev_run\*(C'\fR (or similar functions that enter the
-current event loop) or \f(CW\*(C`ev_loop_fork\*(C'\fR from either \f(CW\*(C`ev_prepare\*(C'\fR or
-\&\f(CW\*(C`ev_check\*(C'\fR watchers. Other loops than the current one are fine,
-however. The rationale behind this is that you do not need to check
-for recursion in those watchers, i.e. the sequence will always be
-\&\f(CW\*(C`ev_prepare\*(C'\fR, blocking, \f(CW\*(C`ev_check\*(C'\fR so if you have one watcher of each
-kind they will always be called in pairs bracketing the blocking call.
-.PP
-Their main purpose is to integrate other event mechanisms into libev and
-their use is somewhat advanced. They could be used, for example, to track
-variable changes, implement your own watchers, integrate net-snmp or a
-coroutine library and lots more. They are also occasionally useful if
-you cache some data and want to flush it before blocking (for example,
-in X programs you might want to do an \f(CW\*(C`XFlush ()\*(C'\fR in an \f(CW\*(C`ev_prepare\*(C'\fR
-watcher).
-.PP
-This is done by examining in each prepare call which file descriptors
-need to be watched by the other library, registering \f(CW\*(C`ev_io\*(C'\fR watchers
-for them and starting an \f(CW\*(C`ev_timer\*(C'\fR watcher for any timeouts (many
-libraries provide exactly this functionality). Then, in the check watcher,
-you check for any events that occurred (by checking the pending status
-of all watchers and stopping them) and call back into the library. The
-I/O and timer callbacks will never actually be called (but must be valid
-nevertheless, because you never know, you know?).
-.PP
-As another example, the Perl Coro module uses these hooks to integrate
-coroutines into libev programs, by yielding to other active coroutines
-during each prepare and only letting the process block if no coroutines
-are ready to run (it's actually more complicated: it only runs coroutines
-with priority higher than or equal to the event loop and one coroutine
-of lower priority, but only once, using idle watchers to keep the event
-loop from blocking if lower-priority coroutines are active, thus mapping
-low-priority coroutines to idle/background tasks).
-.PP
-When used for this purpose, it is recommended to give \f(CW\*(C`ev_check\*(C'\fR watchers
-highest (\f(CW\*(C`EV_MAXPRI\*(C'\fR) priority, to ensure that they are being run before
-any other watchers after the poll (this doesn't matter for \f(CW\*(C`ev_prepare\*(C'\fR
-watchers).
-.PP
-Also, \f(CW\*(C`ev_check\*(C'\fR watchers (and \f(CW\*(C`ev_prepare\*(C'\fR watchers, too) should not
-activate (\*(L"feed\*(R") events into libev. While libev fully supports this, they
-might get executed before other \f(CW\*(C`ev_check\*(C'\fR watchers did their job. As
-\&\f(CW\*(C`ev_check\*(C'\fR watchers are often used to embed other (non-libev) event
-loops those other event loops might be in an unusable state until their
-\&\f(CW\*(C`ev_check\*(C'\fR watcher ran (always remind yourself to coexist peacefully with
-others).
-.PP
-\fIAbusing an \f(CI\*(C`ev_check\*(C'\fI watcher for its side-effect\fR
-.IX Subsection "Abusing an ev_check watcher for its side-effect"
-.PP
-\&\f(CW\*(C`ev_check\*(C'\fR (and less often also \f(CW\*(C`ev_prepare\*(C'\fR) watchers can also be
-useful because they are called once per event loop iteration. For
-example, if you want to handle a large number of connections fairly, you
-normally only do a bit of work for each active connection, and if there
-is more work to do, you wait for the next event loop iteration, so other
-connections have a chance of making progress.
-.PP
-Using an \f(CW\*(C`ev_check\*(C'\fR watcher is almost enough: it will be called on the
-next event loop iteration. However, that isn't as soon as possible \-
-without external events, your \f(CW\*(C`ev_check\*(C'\fR watcher will not be invoked.
-.PP
-This is where \f(CW\*(C`ev_idle\*(C'\fR watchers come in handy \- all you need is a
-single global idle watcher that is active as long as you have one active
-\&\f(CW\*(C`ev_check\*(C'\fR watcher. The \f(CW\*(C`ev_idle\*(C'\fR watcher makes sure the event loop
-will not sleep, and the \f(CW\*(C`ev_check\*(C'\fR watcher makes sure a callback gets
-invoked. Neither watcher alone can do that.
-.PP
-\fIWatcher-Specific Functions and Data Members\fR
-.IX Subsection "Watcher-Specific Functions and Data Members"
-.IP "ev_prepare_init (ev_prepare *, callback)" 4
-.IX Item "ev_prepare_init (ev_prepare *, callback)"
-.PD 0
-.IP "ev_check_init (ev_check *, callback)" 4
-.IX Item "ev_check_init (ev_check *, callback)"
-.PD
-Initialises and configures the prepare or check watcher \- they have no
-parameters of any kind. There are \f(CW\*(C`ev_prepare_set\*(C'\fR and \f(CW\*(C`ev_check_set\*(C'\fR
-macros, but using them is utterly, utterly, utterly and completely
-pointless.
-.PP
-\fIExamples\fR
-.IX Subsection "Examples"
-.PP
-There are a number of principal ways to embed other event loops or modules
-into libev. Here are some ideas on how to include libadns into libev
-(there is a Perl module named \f(CW\*(C`EV::ADNS\*(C'\fR that does this, which you could
-use as a working example. Another Perl module named \f(CW\*(C`EV::Glib\*(C'\fR embeds a
-Glib main context into libev, and finally, \f(CW\*(C`Glib::EV\*(C'\fR embeds \s-1EV\s0 into the
-Glib event loop).
-.PP
-Method 1: Add \s-1IO\s0 watchers and a timeout watcher in a prepare handler,
-and in a check watcher, destroy them and call into libadns. What follows
-is pseudo-code only of course. This requires you to either use a low
-priority for the check watcher or use \f(CW\*(C`ev_clear_pending\*(C'\fR explicitly, as
-the callbacks for the IO/timeout watchers might not have been called yet.
-.PP
-.Vb 2
-\&   static ev_io iow [nfd];
-\&   static ev_timer tw;
-\&
-\&   static void
-\&   io_cb (struct ev_loop *loop, ev_io *w, int revents)
-\&   {
-\&   }
-\&
-\&   // create io watchers for each fd and a timer before blocking
-\&   static void
-\&   adns_prepare_cb (struct ev_loop *loop, ev_prepare *w, int revents)
-\&   {
-\&     int timeout = 3600000;
-\&     struct pollfd fds [nfd];
-\&     // actual code will need to loop here and realloc etc.
-\&     adns_beforepoll (ads, fds, &nfd, &timeout, timeval_from (ev_time ()));
-\&
-\&     /* the callback is illegal, but won\*(Aqt be called as we stop during check */
-\&     ev_timer_init (&tw, 0, timeout * 1e\-3, 0.);
-\&     ev_timer_start (loop, &tw);
-\&
-\&     // create one ev_io per pollfd
-\&     for (int i = 0; i < nfd; ++i)
-\&       {
-\&         ev_io_init (iow + i, io_cb, fds [i].fd,
-\&           ((fds [i].events & POLLIN ? EV_READ : 0)
-\&            | (fds [i].events & POLLOUT ? EV_WRITE : 0)));
-\&
-\&         fds [i].revents = 0;
-\&         ev_io_start (loop, iow + i);
-\&       }
-\&   }
-\&
-\&   // stop all watchers after blocking
-\&   static void
-\&   adns_check_cb (struct ev_loop *loop, ev_check *w, int revents)
-\&   {
-\&     ev_timer_stop (loop, &tw);
-\&
-\&     for (int i = 0; i < nfd; ++i)
-\&       {
-\&         // set the relevant poll flags
-\&         // could also call adns_processreadable etc. here
-\&         struct pollfd *fd = fds + i;
-\&         int revents = ev_clear_pending (iow + i);
-\&         if (revents & EV_READ ) fd\->revents |= fd\->events & POLLIN;
-\&         if (revents & EV_WRITE) fd\->revents |= fd\->events & POLLOUT;
-\&
-\&         // now stop the watcher
-\&         ev_io_stop (loop, iow + i);
-\&       }
-\&
-\&     adns_afterpoll (adns, fds, nfd, timeval_from (ev_now (loop));
-\&   }
-.Ve
-.PP
-Method 2: This would be just like method 1, but you run \f(CW\*(C`adns_afterpoll\*(C'\fR
-in the prepare watcher and would dispose of the check watcher.
-.PP
-Method 3: If the module to be embedded supports explicit event
-notification (libadns does), you can also make use of the actual watcher
-callbacks, and only destroy/create the watchers in the prepare watcher.
-.PP
-.Vb 5
-\&   static void
-\&   timer_cb (EV_P_ ev_timer *w, int revents)
-\&   {
-\&     adns_state ads = (adns_state)w\->data;
-\&     update_now (EV_A);
-\&
-\&     adns_processtimeouts (ads, &tv_now);
-\&   }
-\&
-\&   static void
-\&   io_cb (EV_P_ ev_io *w, int revents)
-\&   {
-\&     adns_state ads = (adns_state)w\->data;
-\&     update_now (EV_A);
-\&
-\&     if (revents & EV_READ ) adns_processreadable  (ads, w\->fd, &tv_now);
-\&     if (revents & EV_WRITE) adns_processwriteable (ads, w\->fd, &tv_now);
-\&   }
-\&
-\&   // do not ever call adns_afterpoll
-.Ve
-.PP
-Method 4: Do not use a prepare or check watcher because the module you
-want to embed is not flexible enough to support it. Instead, you can
-override their poll function. The drawback with this solution is that the
-main loop is now no longer controllable by \s-1EV.\s0 The \f(CW\*(C`Glib::EV\*(C'\fR module uses
-this approach, effectively embedding \s-1EV\s0 as a client into the horrible
-libglib event loop.
-.PP
-.Vb 4
-\&   static gint
-\&   event_poll_func (GPollFD *fds, guint nfds, gint timeout)
-\&   {
-\&     int got_events = 0;
-\&
-\&     for (n = 0; n < nfds; ++n)
-\&       // create/start io watcher that sets the relevant bits in fds[n] and increment got_events
-\&
-\&     if (timeout >= 0)
-\&       // create/start timer
-\&
-\&     // poll
-\&     ev_run (EV_A_ 0);
-\&
-\&     // stop timer again
-\&     if (timeout >= 0)
-\&       ev_timer_stop (EV_A_ &to);
-\&
-\&     // stop io watchers again \- their callbacks should have set
-\&     for (n = 0; n < nfds; ++n)
-\&       ev_io_stop (EV_A_ iow [n]);
-\&
-\&     return got_events;
-\&   }
-.Ve
-.ie n .SS """ev_embed"" \- when one backend isn't enough..."
-.el .SS "\f(CWev_embed\fP \- when one backend isn't enough..."
-.IX Subsection "ev_embed - when one backend isn't enough..."
-This is a rather advanced watcher type that lets you embed one event loop
-into another (currently only \f(CW\*(C`ev_io\*(C'\fR events are supported in the embedded
-loop, other types of watchers might be handled in a delayed or incorrect
-fashion and must not be used).
-.PP
-There are primarily two reasons you would want that: work around bugs and
-prioritise I/O.
-.PP
-As an example for a bug workaround, the kqueue backend might only support
-sockets on some platform, so it is unusable as generic backend, but you
-still want to make use of it because you have many sockets and it scales
-so nicely. In this case, you would create a kqueue-based loop and embed
-it into your default loop (which might use e.g. poll). Overall operation
-will be a bit slower because first libev has to call \f(CW\*(C`poll\*(C'\fR and then
-\&\f(CW\*(C`kevent\*(C'\fR, but at least you can use both mechanisms for what they are
-best: \f(CW\*(C`kqueue\*(C'\fR for scalable sockets and \f(CW\*(C`poll\*(C'\fR if you want it to work :)
-.PP
-As for prioritising I/O: under rare circumstances you have the case where
-some fds have to be watched and handled very quickly (with low latency),
-and even priorities and idle watchers might have too much overhead. In
-this case you would put all the high priority stuff in one loop and all
-the rest in a second one, and embed the second one in the first.
-.PP
-As long as the watcher is active, the callback will be invoked every
-time there might be events pending in the embedded loop. The callback
-must then call \f(CW\*(C`ev_embed_sweep (mainloop, watcher)\*(C'\fR to make a single
-sweep and invoke their callbacks (the callback doesn't need to invoke the
-\&\f(CW\*(C`ev_embed_sweep\*(C'\fR function directly, it could also start an idle watcher
-to give the embedded loop strictly lower priority for example).
-.PP
-You can also set the callback to \f(CW0\fR, in which case the embed watcher
-will automatically execute the embedded loop sweep whenever necessary.
-.PP
-Fork detection will be handled transparently while the \f(CW\*(C`ev_embed\*(C'\fR watcher
-is active, i.e., the embedded loop will automatically be forked when the
-embedding loop forks. In other cases, the user is responsible for calling
-\&\f(CW\*(C`ev_loop_fork\*(C'\fR on the embedded loop.
-.PP
-Unfortunately, not all backends are embeddable: only the ones returned by
-\&\f(CW\*(C`ev_embeddable_backends\*(C'\fR are, which, unfortunately, does not include any
-portable one.
-.PP
-So when you want to use this feature you will always have to be prepared
-that you cannot get an embeddable loop. The recommended way to get around
-this is to have a separate variables for your embeddable loop, try to
-create it, and if that fails, use the normal loop for everything.
-.PP
-\fI\f(CI\*(C`ev_embed\*(C'\fI and fork\fR
-.IX Subsection "ev_embed and fork"
-.PP
-While the \f(CW\*(C`ev_embed\*(C'\fR watcher is running, forks in the embedding loop will
-automatically be applied to the embedded loop as well, so no special
-fork handling is required in that case. When the watcher is not running,
-however, it is still the task of the libev user to call \f(CW\*(C`ev_loop_fork ()\*(C'\fR
-as applicable.
-.PP
-\fIWatcher-Specific Functions and Data Members\fR
-.IX Subsection "Watcher-Specific Functions and Data Members"
-.IP "ev_embed_init (ev_embed *, callback, struct ev_loop *embedded_loop)" 4
-.IX Item "ev_embed_init (ev_embed *, callback, struct ev_loop *embedded_loop)"
-.PD 0
-.IP "ev_embed_set (ev_embed *, struct ev_loop *embedded_loop)" 4
-.IX Item "ev_embed_set (ev_embed *, struct ev_loop *embedded_loop)"
-.PD
-Configures the watcher to embed the given loop, which must be
-embeddable. If the callback is \f(CW0\fR, then \f(CW\*(C`ev_embed_sweep\*(C'\fR will be
-invoked automatically, otherwise it is the responsibility of the callback
-to invoke it (it will continue to be called until the sweep has been done,
-if you do not want that, you need to temporarily stop the embed watcher).
-.IP "ev_embed_sweep (loop, ev_embed *)" 4
-.IX Item "ev_embed_sweep (loop, ev_embed *)"
-Make a single, non-blocking sweep over the embedded loop. This works
-similarly to \f(CW\*(C`ev_run (embedded_loop, EVRUN_NOWAIT)\*(C'\fR, but in the most
-appropriate way for embedded loops.
-.IP "struct ev_loop *other [read\-only]" 4
-.IX Item "struct ev_loop *other [read-only]"
-The embedded event loop.
-.PP
-\fIExamples\fR
-.IX Subsection "Examples"
-.PP
-Example: Try to get an embeddable event loop and embed it into the default
-event loop. If that is not possible, use the default loop. The default
-loop is stored in \f(CW\*(C`loop_hi\*(C'\fR, while the embeddable loop is stored in
-\&\f(CW\*(C`loop_lo\*(C'\fR (which is \f(CW\*(C`loop_hi\*(C'\fR in the case no embeddable loop can be
-used).
-.PP
-.Vb 3
-\&   struct ev_loop *loop_hi = ev_default_init (0);
-\&   struct ev_loop *loop_lo = 0;
-\&   ev_embed embed;
-\&
-\&   // see if there is a chance of getting one that works
-\&   // (remember that a flags value of 0 means autodetection)
-\&   loop_lo = ev_embeddable_backends () & ev_recommended_backends ()
-\&     ? ev_loop_new (ev_embeddable_backends () & ev_recommended_backends ())
-\&     : 0;
-\&
-\&   // if we got one, then embed it, otherwise default to loop_hi
-\&   if (loop_lo)
-\&     {
-\&       ev_embed_init (&embed, 0, loop_lo);
-\&       ev_embed_start (loop_hi, &embed);
-\&     }
-\&   else
-\&     loop_lo = loop_hi;
-.Ve
-.PP
-Example: Check if kqueue is available but not recommended and create
-a kqueue backend for use with sockets (which usually work with any
-kqueue implementation). Store the kqueue/socket\-only event loop in
-\&\f(CW\*(C`loop_socket\*(C'\fR. (One might optionally use \f(CW\*(C`EVFLAG_NOENV\*(C'\fR, too).
-.PP
-.Vb 3
-\&   struct ev_loop *loop = ev_default_init (0);
-\&   struct ev_loop *loop_socket = 0;
-\&   ev_embed embed;
-\&
-\&   if (ev_supported_backends () & ~ev_recommended_backends () & EVBACKEND_KQUEUE)
-\&     if ((loop_socket = ev_loop_new (EVBACKEND_KQUEUE))
-\&       {
-\&         ev_embed_init (&embed, 0, loop_socket);
-\&         ev_embed_start (loop, &embed);
-\&       }
-\&
-\&   if (!loop_socket)
-\&     loop_socket = loop;
-\&
-\&   // now use loop_socket for all sockets, and loop for everything else
-.Ve
-.ie n .SS """ev_fork"" \- the audacity to resume the event loop after a fork"
-.el .SS "\f(CWev_fork\fP \- the audacity to resume the event loop after a fork"
-.IX Subsection "ev_fork - the audacity to resume the event loop after a fork"
-Fork watchers are called when a \f(CW\*(C`fork ()\*(C'\fR was detected (usually because
-whoever is a good citizen cared to tell libev about it by calling
-\&\f(CW\*(C`ev_loop_fork\*(C'\fR). The invocation is done before the event loop blocks next
-and before \f(CW\*(C`ev_check\*(C'\fR watchers are being called, and only in the child
-after the fork. If whoever good citizen calling \f(CW\*(C`ev_default_fork\*(C'\fR cheats
-and calls it in the wrong process, the fork handlers will be invoked, too,
-of course.
-.PP
-\fIThe special problem of life after fork \- how is it possible?\fR
-.IX Subsection "The special problem of life after fork - how is it possible?"
-.PP
-Most uses of \f(CW\*(C`fork ()\*(C'\fR consist of forking, then some simple calls to set
-up/change the process environment, followed by a call to \f(CW\*(C`exec()\*(C'\fR. This
-sequence should be handled by libev without any problems.
-.PP
-This changes when the application actually wants to do event handling
-in the child, or both parent in child, in effect \*(L"continuing\*(R" after the
-fork.
-.PP
-The default mode of operation (for libev, with application help to detect
-forks) is to duplicate all the state in the child, as would be expected
-when \fIeither\fR the parent \fIor\fR the child process continues.
-.PP
-When both processes want to continue using libev, then this is usually the
-wrong result. In that case, usually one process (typically the parent) is
-supposed to continue with all watchers in place as before, while the other
-process typically wants to start fresh, i.e. without any active watchers.
-.PP
-The cleanest and most efficient way to achieve that with libev is to
-simply create a new event loop, which of course will be \*(L"empty\*(R", and
-use that for new watchers. This has the advantage of not touching more
-memory than necessary, and thus avoiding the copy-on-write, and the
-disadvantage of having to use multiple event loops (which do not support
-signal watchers).
-.PP
-When this is not possible, or you want to use the default loop for
-other reasons, then in the process that wants to start \*(L"fresh\*(R", call
-\&\f(CW\*(C`ev_loop_destroy (EV_DEFAULT)\*(C'\fR followed by \f(CW\*(C`ev_default_loop (...)\*(C'\fR.
-Destroying the default loop will \*(L"orphan\*(R" (not stop) all registered
-watchers, so you have to be careful not to execute code that modifies
-those watchers. Note also that in that case, you have to re-register any
-signal watchers.
-.PP
-\fIWatcher-Specific Functions and Data Members\fR
-.IX Subsection "Watcher-Specific Functions and Data Members"
-.IP "ev_fork_init (ev_fork *, callback)" 4
-.IX Item "ev_fork_init (ev_fork *, callback)"
-Initialises and configures the fork watcher \- it has no parameters of any
-kind. There is a \f(CW\*(C`ev_fork_set\*(C'\fR macro, but using it is utterly pointless,
-really.
-.ie n .SS """ev_cleanup"" \- even the best things end"
-.el .SS "\f(CWev_cleanup\fP \- even the best things end"
-.IX Subsection "ev_cleanup - even the best things end"
-Cleanup watchers are called just before the event loop is being destroyed
-by a call to \f(CW\*(C`ev_loop_destroy\*(C'\fR.
-.PP
-While there is no guarantee that the event loop gets destroyed, cleanup
-watchers provide a convenient method to install cleanup hooks for your
-program, worker threads and so on \- you just to make sure to destroy the
-loop when you want them to be invoked.
-.PP
-Cleanup watchers are invoked in the same way as any other watcher. Unlike
-all other watchers, they do not keep a reference to the event loop (which
-makes a lot of sense if you think about it). Like all other watchers, you
-can call libev functions in the callback, except \f(CW\*(C`ev_cleanup_start\*(C'\fR.
-.PP
-\fIWatcher-Specific Functions and Data Members\fR
-.IX Subsection "Watcher-Specific Functions and Data Members"
-.IP "ev_cleanup_init (ev_cleanup *, callback)" 4
-.IX Item "ev_cleanup_init (ev_cleanup *, callback)"
-Initialises and configures the cleanup watcher \- it has no parameters of
-any kind. There is a \f(CW\*(C`ev_cleanup_set\*(C'\fR macro, but using it is utterly
-pointless, I assure you.
-.PP
-Example: Register an atexit handler to destroy the default loop, so any
-cleanup functions are called.
-.PP
-.Vb 5
-\&   static void
-\&   program_exits (void)
-\&   {
-\&     ev_loop_destroy (EV_DEFAULT_UC);
-\&   }
-\&
-\&   ...
-\&   atexit (program_exits);
-.Ve
-.ie n .SS """ev_async"" \- how to wake up an event loop"
-.el .SS "\f(CWev_async\fP \- how to wake up an event loop"
-.IX Subsection "ev_async - how to wake up an event loop"
-In general, you cannot use an \f(CW\*(C`ev_loop\*(C'\fR from multiple threads or other
-asynchronous sources such as signal handlers (as opposed to multiple event
-loops \- those are of course safe to use in different threads).
-.PP
-Sometimes, however, you need to wake up an event loop you do not control,
-for example because it belongs to another thread. This is what \f(CW\*(C`ev_async\*(C'\fR
-watchers do: as long as the \f(CW\*(C`ev_async\*(C'\fR watcher is active, you can signal
-it by calling \f(CW\*(C`ev_async_send\*(C'\fR, which is thread\- and signal safe.
-.PP
-This functionality is very similar to \f(CW\*(C`ev_signal\*(C'\fR watchers, as signals,
-too, are asynchronous in nature, and signals, too, will be compressed
-(i.e. the number of callback invocations may be less than the number of
-\&\f(CW\*(C`ev_async_send\*(C'\fR calls). In fact, you could use signal watchers as a kind
-of \*(L"global async watchers\*(R" by using a watcher on an otherwise unused
-signal, and \f(CW\*(C`ev_feed_signal\*(C'\fR to signal this watcher from another thread,
-even without knowing which loop owns the signal.
-.PP
-\fIQueueing\fR
-.IX Subsection "Queueing"
-.PP
-\&\f(CW\*(C`ev_async\*(C'\fR does not support queueing of data in any way. The reason
-is that the author does not know of a simple (or any) algorithm for a
-multiple-writer-single-reader queue that works in all cases and doesn't
-need elaborate support such as pthreads or unportable memory access
-semantics.
-.PP
-That means that if you want to queue data, you have to provide your own
-queue. But at least I can tell you how to implement locking around your
-queue:
-.IP "queueing from a signal handler context" 4
-.IX Item "queueing from a signal handler context"
-To implement race-free queueing, you simply add to the queue in the signal
-handler but you block the signal handler in the watcher callback. Here is
-an example that does that for some fictitious \s-1SIGUSR1\s0 handler:
-.Sp
-.Vb 1
-\&   static ev_async mysig;
-\&
-\&   static void
-\&   sigusr1_handler (void)
-\&   {
-\&     sometype data;
-\&
-\&     // no locking etc.
-\&     queue_put (data);
-\&     ev_async_send (EV_DEFAULT_ &mysig);
-\&   }
-\&
-\&   static void
-\&   mysig_cb (EV_P_ ev_async *w, int revents)
-\&   {
-\&     sometype data;
-\&     sigset_t block, prev;
-\&
-\&     sigemptyset (&block);
-\&     sigaddset (&block, SIGUSR1);
-\&     sigprocmask (SIG_BLOCK, &block, &prev);
-\&
-\&     while (queue_get (&data))
-\&       process (data);
-\&
-\&     if (sigismember (&prev, SIGUSR1)
-\&       sigprocmask (SIG_UNBLOCK, &block, 0);
-\&   }
-.Ve
-.Sp
-(Note: pthreads in theory requires you to use \f(CW\*(C`pthread_setmask\*(C'\fR
-instead of \f(CW\*(C`sigprocmask\*(C'\fR when you use threads, but libev doesn't do it
-either...).
-.IP "queueing from a thread context" 4
-.IX Item "queueing from a thread context"
-The strategy for threads is different, as you cannot (easily) block
-threads but you can easily preempt them, so to queue safely you need to
-employ a traditional mutex lock, such as in this pthread example:
-.Sp
-.Vb 2
-\&   static ev_async mysig;
-\&   static pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER;
-\&
-\&   static void
-\&   otherthread (void)
-\&   {
-\&     // only need to lock the actual queueing operation
-\&     pthread_mutex_lock (&mymutex);
-\&     queue_put (data);
-\&     pthread_mutex_unlock (&mymutex);
-\&
-\&     ev_async_send (EV_DEFAULT_ &mysig);
-\&   }
-\&
-\&   static void
-\&   mysig_cb (EV_P_ ev_async *w, int revents)
-\&   {
-\&     pthread_mutex_lock (&mymutex);
-\&
-\&     while (queue_get (&data))
-\&       process (data);
-\&
-\&     pthread_mutex_unlock (&mymutex);
-\&   }
-.Ve
-.PP
-\fIWatcher-Specific Functions and Data Members\fR
-.IX Subsection "Watcher-Specific Functions and Data Members"
-.IP "ev_async_init (ev_async *, callback)" 4
-.IX Item "ev_async_init (ev_async *, callback)"
-Initialises and configures the async watcher \- it has no parameters of any
-kind. There is a \f(CW\*(C`ev_async_set\*(C'\fR macro, but using it is utterly pointless,
-trust me.
-.IP "ev_async_send (loop, ev_async *)" 4
-.IX Item "ev_async_send (loop, ev_async *)"
-Sends/signals/activates the given \f(CW\*(C`ev_async\*(C'\fR watcher, that is, feeds
-an \f(CW\*(C`EV_ASYNC\*(C'\fR event on the watcher into the event loop, and instantly
-returns.
-.Sp
-Unlike \f(CW\*(C`ev_feed_event\*(C'\fR, this call is safe to do from other threads,
-signal or similar contexts (see the discussion of \f(CW\*(C`EV_ATOMIC_T\*(C'\fR in the
-embedding section below on what exactly this means).
-.Sp
-Note that, as with other watchers in libev, multiple events might get
-compressed into a single callback invocation (another way to look at
-this is that \f(CW\*(C`ev_async\*(C'\fR watchers are level-triggered: they are set on
-\&\f(CW\*(C`ev_async_send\*(C'\fR, reset when the event loop detects that).
-.Sp
-This call incurs the overhead of at most one extra system call per event
-loop iteration, if the event loop is blocked, and no syscall at all if
-the event loop (or your program) is processing events. That means that
-repeated calls are basically free (there is no need to avoid calls for
-performance reasons) and that the overhead becomes smaller (typically
-zero) under load.
-.IP "bool = ev_async_pending (ev_async *)" 4
-.IX Item "bool = ev_async_pending (ev_async *)"
-Returns a non-zero value when \f(CW\*(C`ev_async_send\*(C'\fR has been called on the
-watcher but the event has not yet been processed (or even noted) by the
-event loop.
-.Sp
-\&\f(CW\*(C`ev_async_send\*(C'\fR sets a flag in the watcher and wakes up the loop. When
-the loop iterates next and checks for the watcher to have become active,
-it will reset the flag again. \f(CW\*(C`ev_async_pending\*(C'\fR can be used to very
-quickly check whether invoking the loop might be a good idea.
-.Sp
-Not that this does \fInot\fR check whether the watcher itself is pending,
-only whether it has been requested to make this watcher pending: there
-is a time window between the event loop checking and resetting the async
-notification, and the callback being invoked.
-.SH "OTHER FUNCTIONS"
-.IX Header "OTHER FUNCTIONS"
-There are some other functions of possible interest. Described. Here. Now.
-.IP "ev_once (loop, int fd, int events, ev_tstamp timeout, callback)" 4
-.IX Item "ev_once (loop, int fd, int events, ev_tstamp timeout, callback)"
-This function combines a simple timer and an I/O watcher, calls your
-callback on whichever event happens first and automatically stops both
-watchers. This is useful if you want to wait for a single event on an fd
-or timeout without having to allocate/configure/start/stop/free one or
-more watchers yourself.
-.Sp
-If \f(CW\*(C`fd\*(C'\fR is less than 0, then no I/O watcher will be started and the
-\&\f(CW\*(C`events\*(C'\fR argument is being ignored. Otherwise, an \f(CW\*(C`ev_io\*(C'\fR watcher for
-the given \f(CW\*(C`fd\*(C'\fR and \f(CW\*(C`events\*(C'\fR set will be created and started.
-.Sp
-If \f(CW\*(C`timeout\*(C'\fR is less than 0, then no timeout watcher will be
-started. Otherwise an \f(CW\*(C`ev_timer\*(C'\fR watcher with after = \f(CW\*(C`timeout\*(C'\fR (and
-repeat = 0) will be started. \f(CW0\fR is a valid timeout.
-.Sp
-The callback has the type \f(CW\*(C`void (*cb)(int revents, void *arg)\*(C'\fR and is
-passed an \f(CW\*(C`revents\*(C'\fR set like normal event callbacks (a combination of
-\&\f(CW\*(C`EV_ERROR\*(C'\fR, \f(CW\*(C`EV_READ\*(C'\fR, \f(CW\*(C`EV_WRITE\*(C'\fR or \f(CW\*(C`EV_TIMER\*(C'\fR) and the \f(CW\*(C`arg\*(C'\fR
-value passed to \f(CW\*(C`ev_once\*(C'\fR. Note that it is possible to receive \fIboth\fR
-a timeout and an io event at the same time \- you probably should give io
-events precedence.
-.Sp
-Example: wait up to ten seconds for data to appear on \s-1STDIN_FILENO.\s0
-.Sp
-.Vb 7
-\&   static void stdin_ready (int revents, void *arg)
-\&   {
-\&     if (revents & EV_READ)
-\&       /* stdin might have data for us, joy! */;
-\&     else if (revents & EV_TIMER)
-\&       /* doh, nothing entered */;
-\&   }
-\&
-\&   ev_once (STDIN_FILENO, EV_READ, 10., stdin_ready, 0);
-.Ve
-.IP "ev_feed_fd_event (loop, int fd, int revents)" 4
-.IX Item "ev_feed_fd_event (loop, int fd, int revents)"
-Feed an event on the given fd, as if a file descriptor backend detected
-the given events.
-.IP "ev_feed_signal_event (loop, int signum)" 4
-.IX Item "ev_feed_signal_event (loop, int signum)"
-Feed an event as if the given signal occurred. See also \f(CW\*(C`ev_feed_signal\*(C'\fR,
-which is async-safe.
-.SH "COMMON OR USEFUL IDIOMS (OR BOTH)"
-.IX Header "COMMON OR USEFUL IDIOMS (OR BOTH)"
-This section explains some common idioms that are not immediately
-obvious. Note that examples are sprinkled over the whole manual, and this
-section only contains stuff that wouldn't fit anywhere else.
-.SS "\s-1ASSOCIATING CUSTOM DATA WITH A WATCHER\s0"
-.IX Subsection "ASSOCIATING CUSTOM DATA WITH A WATCHER"
-Each watcher has, by default, a \f(CW\*(C`void *data\*(C'\fR member that you can read
-or modify at any time: libev will completely ignore it. This can be used
-to associate arbitrary data with your watcher. If you need more data and
-don't want to allocate memory separately and store a pointer to it in that
-data member, you can also \*(L"subclass\*(R" the watcher type and provide your own
-data:
-.PP
-.Vb 7
-\&   struct my_io
-\&   {
-\&     ev_io io;
-\&     int otherfd;
-\&     void *somedata;
-\&     struct whatever *mostinteresting;
-\&   };
-\&
-\&   ...
-\&   struct my_io w;
-\&   ev_io_init (&w.io, my_cb, fd, EV_READ);
-.Ve
-.PP
-And since your callback will be called with a pointer to the watcher, you
-can cast it back to your own type:
-.PP
-.Vb 5
-\&   static void my_cb (struct ev_loop *loop, ev_io *w_, int revents)
-\&   {
-\&     struct my_io *w = (struct my_io *)w_;
-\&     ...
-\&   }
-.Ve
-.PP
-More interesting and less C\-conformant ways of casting your callback
-function type instead have been omitted.
-.SS "\s-1BUILDING YOUR OWN COMPOSITE WATCHERS\s0"
-.IX Subsection "BUILDING YOUR OWN COMPOSITE WATCHERS"
-Another common scenario is to use some data structure with multiple
-embedded watchers, in effect creating your own watcher that combines
-multiple libev event sources into one \*(L"super-watcher\*(R":
-.PP
-.Vb 6
-\&   struct my_biggy
-\&   {
-\&     int some_data;
-\&     ev_timer t1;
-\&     ev_timer t2;
-\&   }
-.Ve
-.PP
-In this case getting the pointer to \f(CW\*(C`my_biggy\*(C'\fR is a bit more
-complicated: Either you store the address of your \f(CW\*(C`my_biggy\*(C'\fR struct in
-the \f(CW\*(C`data\*(C'\fR member of the watcher (for woozies or \*(C+ coders), or you need
-to use some pointer arithmetic using \f(CW\*(C`offsetof\*(C'\fR inside your watchers (for
-real programmers):
-.PP
-.Vb 1
-\&   #include <stddef.h>
-\&
-\&   static void
-\&   t1_cb (EV_P_ ev_timer *w, int revents)
-\&   {
-\&     struct my_biggy big = (struct my_biggy *)
-\&       (((char *)w) \- offsetof (struct my_biggy, t1));
-\&   }
-\&
-\&   static void
-\&   t2_cb (EV_P_ ev_timer *w, int revents)
-\&   {
-\&     struct my_biggy big = (struct my_biggy *)
-\&       (((char *)w) \- offsetof (struct my_biggy, t2));
-\&   }
-.Ve
-.SS "\s-1AVOIDING FINISHING BEFORE RETURNING\s0"
-.IX Subsection "AVOIDING FINISHING BEFORE RETURNING"
-Often you have structures like this in event-based programs:
-.PP
-.Vb 4
-\&  callback ()
-\&  {
-\&    free (request);
-\&  }
-\&
-\&  request = start_new_request (..., callback);
-.Ve
-.PP
-The intent is to start some \*(L"lengthy\*(R" operation. The \f(CW\*(C`request\*(C'\fR could be
-used to cancel the operation, or do other things with it.
-.PP
-It's not uncommon to have code paths in \f(CW\*(C`start_new_request\*(C'\fR that
-immediately invoke the callback, for example, to report errors. Or you add
-some caching layer that finds that it can skip the lengthy aspects of the
-operation and simply invoke the callback with the result.
-.PP
-The problem here is that this will happen \fIbefore\fR \f(CW\*(C`start_new_request\*(C'\fR
-has returned, so \f(CW\*(C`request\*(C'\fR is not set.
-.PP
-Even if you pass the request by some safer means to the callback, you
-might want to do something to the request after starting it, such as
-canceling it, which probably isn't working so well when the callback has
-already been invoked.
-.PP
-A common way around all these issues is to make sure that
-\&\f(CW\*(C`start_new_request\*(C'\fR \fIalways\fR returns before the callback is invoked. If
-\&\f(CW\*(C`start_new_request\*(C'\fR immediately knows the result, it can artificially
-delay invoking the callback by using a \f(CW\*(C`prepare\*(C'\fR or \f(CW\*(C`idle\*(C'\fR watcher for
-example, or more sneakily, by reusing an existing (stopped) watcher and
-pushing it into the pending queue:
-.PP
-.Vb 2
-\&   ev_set_cb (watcher, callback);
-\&   ev_feed_event (EV_A_ watcher, 0);
-.Ve
-.PP
-This way, \f(CW\*(C`start_new_request\*(C'\fR can safely return before the callback is
-invoked, while not delaying callback invocation too much.
-.SS "\s-1MODEL/NESTED EVENT LOOP INVOCATIONS AND EXIT CONDITIONS\s0"
-.IX Subsection "MODEL/NESTED EVENT LOOP INVOCATIONS AND EXIT CONDITIONS"
-Often (especially in \s-1GUI\s0 toolkits) there are places where you have
-\&\fImodal\fR interaction, which is most easily implemented by recursively
-invoking \f(CW\*(C`ev_run\*(C'\fR.
-.PP
-This brings the problem of exiting \- a callback might want to finish the
-main \f(CW\*(C`ev_run\*(C'\fR call, but not the nested one (e.g. user clicked \*(L"Quit\*(R", but
-a modal \*(L"Are you sure?\*(R" dialog is still waiting), or just the nested one
-and not the main one (e.g. user clocked \*(L"Ok\*(R" in a modal dialog), or some
-other combination: In these cases, a simple \f(CW\*(C`ev_break\*(C'\fR will not work.
-.PP
-The solution is to maintain \*(L"break this loop\*(R" variable for each \f(CW\*(C`ev_run\*(C'\fR
-invocation, and use a loop around \f(CW\*(C`ev_run\*(C'\fR until the condition is
-triggered, using \f(CW\*(C`EVRUN_ONCE\*(C'\fR:
-.PP
-.Vb 2
-\&   // main loop
-\&   int exit_main_loop = 0;
-\&
-\&   while (!exit_main_loop)
-\&     ev_run (EV_DEFAULT_ EVRUN_ONCE);
-\&
-\&   // in a modal watcher
-\&   int exit_nested_loop = 0;
-\&
-\&   while (!exit_nested_loop)
-\&     ev_run (EV_A_ EVRUN_ONCE);
-.Ve
-.PP
-To exit from any of these loops, just set the corresponding exit variable:
-.PP
-.Vb 2
-\&   // exit modal loop
-\&   exit_nested_loop = 1;
-\&
-\&   // exit main program, after modal loop is finished
-\&   exit_main_loop = 1;
-\&
-\&   // exit both
-\&   exit_main_loop = exit_nested_loop = 1;
-.Ve
-.SS "\s-1THREAD LOCKING EXAMPLE\s0"
-.IX Subsection "THREAD LOCKING EXAMPLE"
-Here is a fictitious example of how to run an event loop in a different
-thread from where callbacks are being invoked and watchers are
-created/added/removed.
-.PP
-For a real-world example, see the \f(CW\*(C`EV::Loop::Async\*(C'\fR perl module,
-which uses exactly this technique (which is suited for many high-level
-languages).
-.PP
-The example uses a pthread mutex to protect the loop data, a condition
-variable to wait for callback invocations, an async watcher to notify the
-event loop thread and an unspecified mechanism to wake up the main thread.
-.PP
-First, you need to associate some data with the event loop:
-.PP
-.Vb 6
-\&   typedef struct {
-\&     mutex_t lock; /* global loop lock */
-\&     ev_async async_w;
-\&     thread_t tid;
-\&     cond_t invoke_cv;
-\&   } userdata;
-\&
-\&   void prepare_loop (EV_P)
-\&   {
-\&      // for simplicity, we use a static userdata struct.
-\&      static userdata u;
-\&
-\&      ev_async_init (&u\->async_w, async_cb);
-\&      ev_async_start (EV_A_ &u\->async_w);
-\&
-\&      pthread_mutex_init (&u\->lock, 0);
-\&      pthread_cond_init (&u\->invoke_cv, 0);
-\&
-\&      // now associate this with the loop
-\&      ev_set_userdata (EV_A_ u);
-\&      ev_set_invoke_pending_cb (EV_A_ l_invoke);
-\&      ev_set_loop_release_cb (EV_A_ l_release, l_acquire);
-\&
-\&      // then create the thread running ev_run
-\&      pthread_create (&u\->tid, 0, l_run, EV_A);
-\&   }
-.Ve
-.PP
-The callback for the \f(CW\*(C`ev_async\*(C'\fR watcher does nothing: the watcher is used
-solely to wake up the event loop so it takes notice of any new watchers
-that might have been added:
-.PP
-.Vb 5
-\&   static void
-\&   async_cb (EV_P_ ev_async *w, int revents)
-\&   {
-\&      // just used for the side effects
-\&   }
-.Ve
-.PP
-The \f(CW\*(C`l_release\*(C'\fR and \f(CW\*(C`l_acquire\*(C'\fR callbacks simply unlock/lock the mutex
-protecting the loop data, respectively.
-.PP
-.Vb 6
-\&   static void
-\&   l_release (EV_P)
-\&   {
-\&     userdata *u = ev_userdata (EV_A);
-\&     pthread_mutex_unlock (&u\->lock);
-\&   }
-\&
-\&   static void
-\&   l_acquire (EV_P)
-\&   {
-\&     userdata *u = ev_userdata (EV_A);
-\&     pthread_mutex_lock (&u\->lock);
-\&   }
-.Ve
-.PP
-The event loop thread first acquires the mutex, and then jumps straight
-into \f(CW\*(C`ev_run\*(C'\fR:
-.PP
-.Vb 4
-\&   void *
-\&   l_run (void *thr_arg)
-\&   {
-\&     struct ev_loop *loop = (struct ev_loop *)thr_arg;
-\&
-\&     l_acquire (EV_A);
-\&     pthread_setcanceltype (PTHREAD_CANCEL_ASYNCHRONOUS, 0);
-\&     ev_run (EV_A_ 0);
-\&     l_release (EV_A);
-\&
-\&     return 0;
-\&   }
-.Ve
-.PP
-Instead of invoking all pending watchers, the \f(CW\*(C`l_invoke\*(C'\fR callback will
-signal the main thread via some unspecified mechanism (signals? pipe
-writes? \f(CW\*(C`Async::Interrupt\*(C'\fR?) and then waits until all pending watchers
-have been called (in a while loop because a) spurious wakeups are possible
-and b) skipping inter-thread-communication when there are no pending
-watchers is very beneficial):
-.PP
-.Vb 4
-\&   static void
-\&   l_invoke (EV_P)
-\&   {
-\&     userdata *u = ev_userdata (EV_A);
-\&
-\&     while (ev_pending_count (EV_A))
-\&       {
-\&         wake_up_other_thread_in_some_magic_or_not_so_magic_way ();
-\&         pthread_cond_wait (&u\->invoke_cv, &u\->lock);
-\&       }
-\&   }
-.Ve
-.PP
-Now, whenever the main thread gets told to invoke pending watchers, it
-will grab the lock, call \f(CW\*(C`ev_invoke_pending\*(C'\fR and then signal the loop
-thread to continue:
-.PP
-.Vb 4
-\&   static void
-\&   real_invoke_pending (EV_P)
-\&   {
-\&     userdata *u = ev_userdata (EV_A);
-\&
-\&     pthread_mutex_lock (&u\->lock);
-\&     ev_invoke_pending (EV_A);
-\&     pthread_cond_signal (&u\->invoke_cv);
-\&     pthread_mutex_unlock (&u\->lock);
-\&   }
-.Ve
-.PP
-Whenever you want to start/stop a watcher or do other modifications to an
-event loop, you will now have to lock:
-.PP
-.Vb 2
-\&   ev_timer timeout_watcher;
-\&   userdata *u = ev_userdata (EV_A);
-\&
-\&   ev_timer_init (&timeout_watcher, timeout_cb, 5.5, 0.);
-\&
-\&   pthread_mutex_lock (&u\->lock);
-\&   ev_timer_start (EV_A_ &timeout_watcher);
-\&   ev_async_send (EV_A_ &u\->async_w);
-\&   pthread_mutex_unlock (&u\->lock);
-.Ve
-.PP
-Note that sending the \f(CW\*(C`ev_async\*(C'\fR watcher is required because otherwise
-an event loop currently blocking in the kernel will have no knowledge
-about the newly added timer. By waking up the loop it will pick up any new
-watchers in the next event loop iteration.
-.SS "\s-1THREADS, COROUTINES, CONTINUATIONS, QUEUES... INSTEAD OF CALLBACKS\s0"
-.IX Subsection "THREADS, COROUTINES, CONTINUATIONS, QUEUES... INSTEAD OF CALLBACKS"
-While the overhead of a callback that e.g. schedules a thread is small, it
-is still an overhead. If you embed libev, and your main usage is with some
-kind of threads or coroutines, you might want to customise libev so that
-doesn't need callbacks anymore.
-.PP
-Imagine you have coroutines that you can switch to using a function
-\&\f(CW\*(C`switch_to (coro)\*(C'\fR, that libev runs in a coroutine called \f(CW\*(C`libev_coro\*(C'\fR
-and that due to some magic, the currently active coroutine is stored in a
-global called \f(CW\*(C`current_coro\*(C'\fR. Then you can build your own \*(L"wait for libev
-event\*(R" primitive by changing \f(CW\*(C`EV_CB_DECLARE\*(C'\fR and \f(CW\*(C`EV_CB_INVOKE\*(C'\fR (note
-the differing \f(CW\*(C`;\*(C'\fR conventions):
-.PP
-.Vb 2
-\&   #define EV_CB_DECLARE(type)   struct my_coro *cb;
-\&   #define EV_CB_INVOKE(watcher) switch_to ((watcher)\->cb)
-.Ve
-.PP
-That means instead of having a C callback function, you store the
-coroutine to switch to in each watcher, and instead of having libev call
-your callback, you instead have it switch to that coroutine.
-.PP
-A coroutine might now wait for an event with a function called
-\&\f(CW\*(C`wait_for_event\*(C'\fR. (the watcher needs to be started, as always, but it doesn't
-matter when, or whether the watcher is active or not when this function is
-called):
-.PP
-.Vb 6
-\&   void
-\&   wait_for_event (ev_watcher *w)
-\&   {
-\&     ev_set_cb (w, current_coro);
-\&     switch_to (libev_coro);
-\&   }
-.Ve
-.PP
-That basically suspends the coroutine inside \f(CW\*(C`wait_for_event\*(C'\fR and
-continues the libev coroutine, which, when appropriate, switches back to
-this or any other coroutine.
-.PP
-You can do similar tricks if you have, say, threads with an event queue \-
-instead of storing a coroutine, you store the queue object and instead of
-switching to a coroutine, you push the watcher onto the queue and notify
-any waiters.
-.PP
-To embed libev, see \*(L"\s-1EMBEDDING\*(R"\s0, but in short, it's easiest to create two
-files, \fImy_ev.h\fR and \fImy_ev.c\fR that include the respective libev files:
-.PP
-.Vb 4
-\&   // my_ev.h
-\&   #define EV_CB_DECLARE(type)   struct my_coro *cb;
-\&   #define EV_CB_INVOKE(watcher) switch_to ((watcher)\->cb)
-\&   #include "../libev/ev.h"
-\&
-\&   // my_ev.c
-\&   #define EV_H "my_ev.h"
-\&   #include "../libev/ev.c"
-.Ve
-.PP
-And then use \fImy_ev.h\fR when you would normally use \fIev.h\fR, and compile
-\&\fImy_ev.c\fR into your project. When properly specifying include paths, you
-can even use \fIev.h\fR as header file name directly.
-.SH "LIBEVENT EMULATION"
-.IX Header "LIBEVENT EMULATION"
-Libev offers a compatibility emulation layer for libevent. It cannot
-emulate the internals of libevent, so here are some usage hints:
-.IP "\(bu" 4
-Only the libevent\-1.4.1\-beta \s-1API\s0 is being emulated.
-.Sp
-This was the newest libevent version available when libev was implemented,
-and is still mostly unchanged in 2010.
-.IP "\(bu" 4
-Use it by including <event.h>, as usual.
-.IP "\(bu" 4
-The following members are fully supported: ev_base, ev_callback,
-ev_arg, ev_fd, ev_res, ev_events.
-.IP "\(bu" 4
-Avoid using ev_flags and the EVLIST_*\-macros, while it is
-maintained by libev, it does not work exactly the same way as in libevent (consider
-it a private \s-1API\s0).
-.IP "\(bu" 4
-Priorities are not currently supported. Initialising priorities
-will fail and all watchers will have the same priority, even though there
-is an ev_pri field.
-.IP "\(bu" 4
-In libevent, the last base created gets the signals, in libev, the
-base that registered the signal gets the signals.
-.IP "\(bu" 4
-Other members are not supported.
-.IP "\(bu" 4
-The libev emulation is \fInot\fR \s-1ABI\s0 compatible to libevent, you need
-to use the libev header file and library.
-.SH "\*(C+ SUPPORT"
-.IX Header " SUPPORT"
-.SS "C \s-1API\s0"
-.IX Subsection "C API"
-The normal C \s-1API\s0 should work fine when used from \*(C+: both ev.h and the
-libev sources can be compiled as \*(C+. Therefore, code that uses the C \s-1API\s0
-will work fine.
-.PP
-Proper exception specifications might have to be added to callbacks passed
-to libev: exceptions may be thrown only from watcher callbacks, all
-other callbacks (allocator, syserr, loop acquire/release and periodic
-reschedule callbacks) must not throw exceptions, and might need a \f(CW\*(C`throw
-()\*(C'\fR specification. If you have code that needs to be compiled as both C
-and \*(C+ you can use the \f(CW\*(C`EV_THROW\*(C'\fR macro for this:
-.PP
-.Vb 6
-\&   static void
-\&   fatal_error (const char *msg) EV_THROW
-\&   {
-\&     perror (msg);
-\&     abort ();
-\&   }
-\&
-\&   ...
-\&   ev_set_syserr_cb (fatal_error);
-.Ve
-.PP
-The only \s-1API\s0 functions that can currently throw exceptions are \f(CW\*(C`ev_run\*(C'\fR,
-\&\f(CW\*(C`ev_invoke\*(C'\fR, \f(CW\*(C`ev_invoke_pending\*(C'\fR and \f(CW\*(C`ev_loop_destroy\*(C'\fR (the latter
-because it runs cleanup watchers).
-.PP
-Throwing exceptions in watcher callbacks is only supported if libev itself
-is compiled with a \*(C+ compiler or your C and \*(C+ environments allow
-throwing exceptions through C libraries (most do).
-.SS "\*(C+ \s-1API\s0"
-.IX Subsection " API"
-Libev comes with some simplistic wrapper classes for \*(C+ that mainly allow
-you to use some convenience methods to start/stop watchers and also change
-the callback model to a model using method callbacks on objects.
-.PP
-To use it,
-.PP
-.Vb 1
-\&   #include <ev++.h>
-.Ve
-.PP
-This automatically includes \fIev.h\fR and puts all of its definitions (many
-of them macros) into the global namespace. All \*(C+ specific things are
-put into the \f(CW\*(C`ev\*(C'\fR namespace. It should support all the same embedding
-options as \fIev.h\fR, most notably \f(CW\*(C`EV_MULTIPLICITY\*(C'\fR.
-.PP
-Care has been taken to keep the overhead low. The only data member the \*(C+
-classes add (compared to plain C\-style watchers) is the event loop pointer
-that the watcher is associated with (or no additional members at all if
-you disable \f(CW\*(C`EV_MULTIPLICITY\*(C'\fR when embedding libev).
-.PP
-Currently, functions, static and non-static member functions and classes
-with \f(CW\*(C`operator ()\*(C'\fR can be used as callbacks. Other types should be easy
-to add as long as they only need one additional pointer for context. If
-you need support for other types of functors please contact the author
-(preferably after implementing it).
-.PP
-For all this to work, your \*(C+ compiler either has to use the same calling
-conventions as your C compiler (for static member functions), or you have
-to embed libev and compile libev itself as \*(C+.
-.PP
-Here is a list of things available in the \f(CW\*(C`ev\*(C'\fR namespace:
-.ie n .IP """ev::READ"", ""ev::WRITE"" etc." 4
-.el .IP "\f(CWev::READ\fR, \f(CWev::WRITE\fR etc." 4
-.IX Item "ev::READ, ev::WRITE etc."
-These are just enum values with the same values as the \f(CW\*(C`EV_READ\*(C'\fR etc.
-macros from \fIev.h\fR.
-.ie n .IP """ev::tstamp"", ""ev::now""" 4
-.el .IP "\f(CWev::tstamp\fR, \f(CWev::now\fR" 4
-.IX Item "ev::tstamp, ev::now"
-Aliases to the same types/functions as with the \f(CW\*(C`ev_\*(C'\fR prefix.
-.ie n .IP """ev::io"", ""ev::timer"", ""ev::periodic"", ""ev::idle"", ""ev::sig"" etc." 4
-.el .IP "\f(CWev::io\fR, \f(CWev::timer\fR, \f(CWev::periodic\fR, \f(CWev::idle\fR, \f(CWev::sig\fR etc." 4
-.IX Item "ev::io, ev::timer, ev::periodic, ev::idle, ev::sig etc."
-For each \f(CW\*(C`ev_TYPE\*(C'\fR watcher in \fIev.h\fR there is a corresponding class of
-the same name in the \f(CW\*(C`ev\*(C'\fR namespace, with the exception of \f(CW\*(C`ev_signal\*(C'\fR
-which is called \f(CW\*(C`ev::sig\*(C'\fR to avoid clashes with the \f(CW\*(C`signal\*(C'\fR macro
-defined by many implementations.
-.Sp
-All of those classes have these methods:
-.RS 4
-.IP "ev::TYPE::TYPE ()" 4
-.IX Item "ev::TYPE::TYPE ()"
-.PD 0
-.IP "ev::TYPE::TYPE (loop)" 4
-.IX Item "ev::TYPE::TYPE (loop)"
-.IP "ev::TYPE::~TYPE" 4
-.IX Item "ev::TYPE::~TYPE"
-.PD
-The constructor (optionally) takes an event loop to associate the watcher
-with. If it is omitted, it will use \f(CW\*(C`EV_DEFAULT\*(C'\fR.
-.Sp
-The constructor calls \f(CW\*(C`ev_init\*(C'\fR for you, which means you have to call the
-\&\f(CW\*(C`set\*(C'\fR method before starting it.
-.Sp
-It will not set a callback, however: You have to call the templated \f(CW\*(C`set\*(C'\fR
-method to set a callback before you can start the watcher.
-.Sp
-(The reason why you have to use a method is a limitation in \*(C+ which does
-not allow explicit template arguments for constructors).
-.Sp
-The destructor automatically stops the watcher if it is active.
-.IP "w\->set<class, &class::method> (object *)" 4
-.IX Item "w->set<class, &class::method> (object *)"
-This method sets the callback method to call. The method has to have a
-signature of \f(CW\*(C`void (*)(ev_TYPE &, int)\*(C'\fR, it receives the watcher as
-first argument and the \f(CW\*(C`revents\*(C'\fR as second. The object must be given as
-parameter and is stored in the \f(CW\*(C`data\*(C'\fR member of the watcher.
-.Sp
-This method synthesizes efficient thunking code to call your method from
-the C callback that libev requires. If your compiler can inline your
-callback (i.e. it is visible to it at the place of the \f(CW\*(C`set\*(C'\fR call and
-your compiler is good :), then the method will be fully inlined into the
-thunking function, making it as fast as a direct C callback.
-.Sp
-Example: simple class declaration and watcher initialisation
-.Sp
-.Vb 4
-\&   struct myclass
-\&   {
-\&     void io_cb (ev::io &w, int revents) { }
-\&   }
-\&
-\&   myclass obj;
-\&   ev::io iow;
-\&   iow.set <myclass, &myclass::io_cb> (&obj);
-.Ve
-.IP "w\->set (object *)" 4
-.IX Item "w->set (object *)"
-This is a variation of a method callback \- leaving out the method to call
-will default the method to \f(CW\*(C`operator ()\*(C'\fR, which makes it possible to use
-functor objects without having to manually specify the \f(CW\*(C`operator ()\*(C'\fR all
-the time. Incidentally, you can then also leave out the template argument
-list.
-.Sp
-The \f(CW\*(C`operator ()\*(C'\fR method prototype must be \f(CW\*(C`void operator ()(watcher &w,
-int revents)\*(C'\fR.
-.Sp
-See the method\-\f(CW\*(C`set\*(C'\fR above for more details.
-.Sp
-Example: use a functor object as callback.
-.Sp
-.Vb 7
-\&   struct myfunctor
-\&   {
-\&     void operator() (ev::io &w, int revents)
-\&     {
-\&       ...
-\&     }
-\&   }
-\&
-\&   myfunctor f;
-\&
-\&   ev::io w;
-\&   w.set (&f);
-.Ve
-.IP "w\->set<function> (void *data = 0)" 4
-.IX Item "w->set<function> (void *data = 0)"
-Also sets a callback, but uses a static method or plain function as
-callback. The optional \f(CW\*(C`data\*(C'\fR argument will be stored in the watcher's
-\&\f(CW\*(C`data\*(C'\fR member and is free for you to use.
-.Sp
-The prototype of the \f(CW\*(C`function\*(C'\fR must be \f(CW\*(C`void (*)(ev::TYPE &w, int)\*(C'\fR.
-.Sp
-See the method\-\f(CW\*(C`set\*(C'\fR above for more details.
-.Sp
-Example: Use a plain function as callback.
-.Sp
-.Vb 2
-\&   static void io_cb (ev::io &w, int revents) { }
-\&   iow.set <io_cb> ();
-.Ve
-.IP "w\->set (loop)" 4
-.IX Item "w->set (loop)"
-Associates a different \f(CW\*(C`struct ev_loop\*(C'\fR with this watcher. You can only
-do this when the watcher is inactive (and not pending either).
-.IP "w\->set ([arguments])" 4
-.IX Item "w->set ([arguments])"
-Basically the same as \f(CW\*(C`ev_TYPE_set\*(C'\fR (except for \f(CW\*(C`ev::embed\*(C'\fR watchers>),
-with the same arguments. Either this method or a suitable start method
-must be called at least once. Unlike the C counterpart, an active watcher
-gets automatically stopped and restarted when reconfiguring it with this
-method.
-.Sp
-For \f(CW\*(C`ev::embed\*(C'\fR watchers this method is called \f(CW\*(C`set_embed\*(C'\fR, to avoid
-clashing with the \f(CW\*(C`set (loop)\*(C'\fR method.
-.IP "w\->start ()" 4
-.IX Item "w->start ()"
-Starts the watcher. Note that there is no \f(CW\*(C`loop\*(C'\fR argument, as the
-constructor already stores the event loop.
-.IP "w\->start ([arguments])" 4
-.IX Item "w->start ([arguments])"
-Instead of calling \f(CW\*(C`set\*(C'\fR and \f(CW\*(C`start\*(C'\fR methods separately, it is often
-convenient to wrap them in one call. Uses the same type of arguments as
-the configure \f(CW\*(C`set\*(C'\fR method of the watcher.
-.IP "w\->stop ()" 4
-.IX Item "w->stop ()"
-Stops the watcher if it is active. Again, no \f(CW\*(C`loop\*(C'\fR argument.
-.ie n .IP "w\->again () (""ev::timer"", ""ev::periodic"" only)" 4
-.el .IP "w\->again () (\f(CWev::timer\fR, \f(CWev::periodic\fR only)" 4
-.IX Item "w->again () (ev::timer, ev::periodic only)"
-For \f(CW\*(C`ev::timer\*(C'\fR and \f(CW\*(C`ev::periodic\*(C'\fR, this invokes the corresponding
-\&\f(CW\*(C`ev_TYPE_again\*(C'\fR function.
-.ie n .IP "w\->sweep () (""ev::embed"" only)" 4
-.el .IP "w\->sweep () (\f(CWev::embed\fR only)" 4
-.IX Item "w->sweep () (ev::embed only)"
-Invokes \f(CW\*(C`ev_embed_sweep\*(C'\fR.
-.ie n .IP "w\->update () (""ev::stat"" only)" 4
-.el .IP "w\->update () (\f(CWev::stat\fR only)" 4
-.IX Item "w->update () (ev::stat only)"
-Invokes \f(CW\*(C`ev_stat_stat\*(C'\fR.
-.RE
-.RS 4
-.RE
-.PP
-Example: Define a class with two I/O and idle watchers, start the I/O
-watchers in the constructor.
-.PP
-.Vb 5
-\&   class myclass
-\&   {
-\&     ev::io   io  ; void io_cb   (ev::io   &w, int revents);
-\&     ev::io   io2 ; void io2_cb  (ev::io   &w, int revents);
-\&     ev::idle idle; void idle_cb (ev::idle &w, int revents);
-\&
-\&     myclass (int fd)
-\&     {
-\&       io  .set <myclass, &myclass::io_cb  > (this);
-\&       io2 .set <myclass, &myclass::io2_cb > (this);
-\&       idle.set <myclass, &myclass::idle_cb> (this);
-\&
-\&       io.set (fd, ev::WRITE); // configure the watcher
-\&       io.start ();            // start it whenever convenient
-\&
-\&       io2.start (fd, ev::READ); // set + start in one call
-\&     }
-\&   };
-.Ve
-.SH "OTHER LANGUAGE BINDINGS"
-.IX Header "OTHER LANGUAGE BINDINGS"
-Libev does not offer other language bindings itself, but bindings for a
-number of languages exist in the form of third-party packages. If you know
-any interesting language binding in addition to the ones listed here, drop
-me a note.
-.IP "Perl" 4
-.IX Item "Perl"
-The \s-1EV\s0 module implements the full libev \s-1API\s0 and is actually used to test
-libev. \s-1EV\s0 is developed together with libev. Apart from the \s-1EV\s0 core module,
-there are additional modules that implement libev-compatible interfaces
-to \f(CW\*(C`libadns\*(C'\fR (\f(CW\*(C`EV::ADNS\*(C'\fR, but \f(CW\*(C`AnyEvent::DNS\*(C'\fR is preferred nowadays),
-\&\f(CW\*(C`Net::SNMP\*(C'\fR (\f(CW\*(C`Net::SNMP::EV\*(C'\fR) and the \f(CW\*(C`libglib\*(C'\fR event core (\f(CW\*(C`Glib::EV\*(C'\fR
-and \f(CW\*(C`EV::Glib\*(C'\fR).
-.Sp
-It can be found and installed via \s-1CPAN,\s0 its homepage is at
-<http://software.schmorp.de/pkg/EV>.
-.IP "Python" 4
-.IX Item "Python"
-Python bindings can be found at <http://code.google.com/p/pyev/>. It
-seems to be quite complete and well-documented.
-.IP "Ruby" 4
-.IX Item "Ruby"
-Tony Arcieri has written a ruby extension that offers access to a subset
-of the libev \s-1API\s0 and adds file handle abstractions, asynchronous \s-1DNS\s0 and
-more on top of it. It can be found via gem servers. Its homepage is at
-<http://rev.rubyforge.org/>.
-.Sp
-Roger Pack reports that using the link order \f(CW\*(C`\-lws2_32 \-lmsvcrt\-ruby\-190\*(C'\fR
-makes rev work even on mingw.
-.IP "Haskell" 4
-.IX Item "Haskell"
-A haskell binding to libev is available at
-<http://hackage.haskell.org/cgi\-bin/hackage\-scripts/package/hlibev>.
-.IP "D" 4
-.IX Item "D"
-Leandro Lucarella has written a D language binding (\fIev.d\fR) for libev, to
-be found at <http://www.llucax.com.ar/proj/ev.d/index.html>.
-.IP "Ocaml" 4
-.IX Item "Ocaml"
-Erkki Seppala has written Ocaml bindings for libev, to be found at
-<http://modeemi.cs.tut.fi/~flux/software/ocaml\-ev/>.
-.IP "Lua" 4
-.IX Item "Lua"
-Brian Maher has written a partial interface to libev for lua (at the
-time of this writing, only \f(CW\*(C`ev_io\*(C'\fR and \f(CW\*(C`ev_timer\*(C'\fR), to be found at
-<http://github.com/brimworks/lua\-ev>.
-.IP "Javascript" 4
-.IX Item "Javascript"
-Node.js (<http://nodejs.org>) uses libev as the underlying event library.
-.IP "Others" 4
-.IX Item "Others"
-There are others, and I stopped counting.
-.SH "MACRO MAGIC"
-.IX Header "MACRO MAGIC"
-Libev can be compiled with a variety of options, the most fundamental
-of which is \f(CW\*(C`EV_MULTIPLICITY\*(C'\fR. This option determines whether (most)
-functions and callbacks have an initial \f(CW\*(C`struct ev_loop *\*(C'\fR argument.
-.PP
-To make it easier to write programs that cope with either variant, the
-following macros are defined:
-.ie n .IP """EV_A"", ""EV_A_""" 4
-.el .IP "\f(CWEV_A\fR, \f(CWEV_A_\fR" 4
-.IX Item "EV_A, EV_A_"
-This provides the loop \fIargument\fR for functions, if one is required (\*(L"ev
-loop argument\*(R"). The \f(CW\*(C`EV_A\*(C'\fR form is used when this is the sole argument,
-\&\f(CW\*(C`EV_A_\*(C'\fR is used when other arguments are following. Example:
-.Sp
-.Vb 3
-\&   ev_unref (EV_A);
-\&   ev_timer_add (EV_A_ watcher);
-\&   ev_run (EV_A_ 0);
-.Ve
-.Sp
-It assumes the variable \f(CW\*(C`loop\*(C'\fR of type \f(CW\*(C`struct ev_loop *\*(C'\fR is in scope,
-which is often provided by the following macro.
-.ie n .IP """EV_P"", ""EV_P_""" 4
-.el .IP "\f(CWEV_P\fR, \f(CWEV_P_\fR" 4
-.IX Item "EV_P, EV_P_"
-This provides the loop \fIparameter\fR for functions, if one is required (\*(L"ev
-loop parameter\*(R"). The \f(CW\*(C`EV_P\*(C'\fR form is used when this is the sole parameter,
-\&\f(CW\*(C`EV_P_\*(C'\fR is used when other parameters are following. Example:
-.Sp
-.Vb 2
-\&   // this is how ev_unref is being declared
-\&   static void ev_unref (EV_P);
-\&
-\&   // this is how you can declare your typical callback
-\&   static void cb (EV_P_ ev_timer *w, int revents)
-.Ve
-.Sp
-It declares a parameter \f(CW\*(C`loop\*(C'\fR of type \f(CW\*(C`struct ev_loop *\*(C'\fR, quite
-suitable for use with \f(CW\*(C`EV_A\*(C'\fR.
-.ie n .IP """EV_DEFAULT"", ""EV_DEFAULT_""" 4
-.el .IP "\f(CWEV_DEFAULT\fR, \f(CWEV_DEFAULT_\fR" 4
-.IX Item "EV_DEFAULT, EV_DEFAULT_"
-Similar to the other two macros, this gives you the value of the default
-loop, if multiple loops are supported (\*(L"ev loop default\*(R"). The default loop
-will be initialised if it isn't already initialised.
-.Sp
-For non-multiplicity builds, these macros do nothing, so you always have
-to initialise the loop somewhere.
-.ie n .IP """EV_DEFAULT_UC"", ""EV_DEFAULT_UC_""" 4
-.el .IP "\f(CWEV_DEFAULT_UC\fR, \f(CWEV_DEFAULT_UC_\fR" 4
-.IX Item "EV_DEFAULT_UC, EV_DEFAULT_UC_"
-Usage identical to \f(CW\*(C`EV_DEFAULT\*(C'\fR and \f(CW\*(C`EV_DEFAULT_\*(C'\fR, but requires that the
-default loop has been initialised (\f(CW\*(C`UC\*(C'\fR == unchecked). Their behaviour
-is undefined when the default loop has not been initialised by a previous
-execution of \f(CW\*(C`EV_DEFAULT\*(C'\fR, \f(CW\*(C`EV_DEFAULT_\*(C'\fR or \f(CW\*(C`ev_default_init (...)\*(C'\fR.
-.Sp
-It is often prudent to use \f(CW\*(C`EV_DEFAULT\*(C'\fR when initialising the first
-watcher in a function but use \f(CW\*(C`EV_DEFAULT_UC\*(C'\fR afterwards.
-.PP
-Example: Declare and initialise a check watcher, utilising the above
-macros so it will work regardless of whether multiple loops are supported
-or not.
-.PP
-.Vb 5
-\&   static void
-\&   check_cb (EV_P_ ev_timer *w, int revents)
-\&   {
-\&     ev_check_stop (EV_A_ w);
-\&   }
-\&
-\&   ev_check check;
-\&   ev_check_init (&check, check_cb);
-\&   ev_check_start (EV_DEFAULT_ &check);
-\&   ev_run (EV_DEFAULT_ 0);
-.Ve
-.SH "EMBEDDING"
-.IX Header "EMBEDDING"
-Libev can (and often is) directly embedded into host
-applications. Examples of applications that embed it include the Deliantra
-Game Server, the \s-1EV\s0 perl module, the \s-1GNU\s0 Virtual Private Ethernet (gvpe)
-and rxvt-unicode.
-.PP
-The goal is to enable you to just copy the necessary files into your
-source directory without having to change even a single line in them, so
-you can easily upgrade by simply copying (or having a checked-out copy of
-libev somewhere in your source tree).
-.SS "\s-1FILESETS\s0"
-.IX Subsection "FILESETS"
-Depending on what features you need you need to include one or more sets of files
-in your application.
-.PP
-\fI\s-1CORE EVENT LOOP\s0\fR
-.IX Subsection "CORE EVENT LOOP"
-.PP
-To include only the libev core (all the \f(CW\*(C`ev_*\*(C'\fR functions), with manual
-configuration (no autoconf):
-.PP
-.Vb 2
-\&   #define EV_STANDALONE 1
-\&   #include "ev.c"
-.Ve
-.PP
-This will automatically include \fIev.h\fR, too, and should be done in a
-single C source file only to provide the function implementations. To use
-it, do the same for \fIev.h\fR in all files wishing to use this \s-1API \s0(best
-done by writing a wrapper around \fIev.h\fR that you can include instead and
-where you can put other configuration options):
-.PP
-.Vb 2
-\&   #define EV_STANDALONE 1
-\&   #include "ev.h"
-.Ve
-.PP
-Both header files and implementation files can be compiled with a \*(C+
-compiler (at least, that's a stated goal, and breakage will be treated
-as a bug).
-.PP
-You need the following files in your source tree, or in a directory
-in your include path (e.g. in libev/ when using \-Ilibev):
-.PP
-.Vb 4
-\&   ev.h
-\&   ev.c
-\&   ev_vars.h
-\&   ev_wrap.h
-\&
-\&   ev_win32.c      required on win32 platforms only
-\&
-\&   ev_select.c     only when select backend is enabled
-\&   ev_poll.c       only when poll backend is enabled
-\&   ev_epoll.c      only when the epoll backend is enabled
-\&   ev_kqueue.c     only when the kqueue backend is enabled
-\&   ev_port.c       only when the solaris port backend is enabled
-.Ve
-.PP
-\&\fIev.c\fR includes the backend files directly when enabled, so you only need
-to compile this single file.
-.PP
-\fI\s-1LIBEVENT COMPATIBILITY API\s0\fR
-.IX Subsection "LIBEVENT COMPATIBILITY API"
-.PP
-To include the libevent compatibility \s-1API,\s0 also include:
-.PP
-.Vb 1
-\&   #include "event.c"
-.Ve
-.PP
-in the file including \fIev.c\fR, and:
-.PP
-.Vb 1
-\&   #include "event.h"
-.Ve
-.PP
-in the files that want to use the libevent \s-1API.\s0 This also includes \fIev.h\fR.
-.PP
-You need the following additional files for this:
-.PP
-.Vb 2
-\&   event.h
-\&   event.c
-.Ve
-.PP
-\fI\s-1AUTOCONF SUPPORT\s0\fR
-.IX Subsection "AUTOCONF SUPPORT"
-.PP
-Instead of using \f(CW\*(C`EV_STANDALONE=1\*(C'\fR and providing your configuration in
-whatever way you want, you can also \f(CW\*(C`m4_include([libev.m4])\*(C'\fR in your
-\&\fIconfigure.ac\fR and leave \f(CW\*(C`EV_STANDALONE\*(C'\fR undefined. \fIev.c\fR will then
-include \fIconfig.h\fR and configure itself accordingly.
-.PP
-For this of course you need the m4 file:
-.PP
-.Vb 1
-\&   libev.m4
-.Ve
-.SS "\s-1PREPROCESSOR SYMBOLS/MACROS\s0"
-.IX Subsection "PREPROCESSOR SYMBOLS/MACROS"
-Libev can be configured via a variety of preprocessor symbols you have to
-define before including (or compiling) any of its files. The default in
-the absence of autoconf is documented for every option.
-.PP
-Symbols marked with \*(L"(h)\*(R" do not change the \s-1ABI,\s0 and can have different
-values when compiling libev vs. including \fIev.h\fR, so it is permissible
-to redefine them before including \fIev.h\fR without breaking compatibility
-to a compiled library. All other symbols change the \s-1ABI,\s0 which means all
-users of libev and the libev code itself must be compiled with compatible
-settings.
-.IP "\s-1EV_COMPAT3 \s0(h)" 4
-.IX Item "EV_COMPAT3 (h)"
-Backwards compatibility is a major concern for libev. This is why this
-release of libev comes with wrappers for the functions and symbols that
-have been renamed between libev version 3 and 4.
-.Sp
-You can disable these wrappers (to test compatibility with future
-versions) by defining \f(CW\*(C`EV_COMPAT3\*(C'\fR to \f(CW0\fR when compiling your
-sources. This has the additional advantage that you can drop the \f(CW\*(C`struct\*(C'\fR
-from \f(CW\*(C`struct ev_loop\*(C'\fR declarations, as libev will provide an \f(CW\*(C`ev_loop\*(C'\fR
-typedef in that case.
-.Sp
-In some future version, the default for \f(CW\*(C`EV_COMPAT3\*(C'\fR will become \f(CW0\fR,
-and in some even more future version the compatibility code will be
-removed completely.
-.IP "\s-1EV_STANDALONE \s0(h)" 4
-.IX Item "EV_STANDALONE (h)"
-Must always be \f(CW1\fR if you do not use autoconf configuration, which
-keeps libev from including \fIconfig.h\fR, and it also defines dummy
-implementations for some libevent functions (such as logging, which is not
-supported). It will also not define any of the structs usually found in
-\&\fIevent.h\fR that are not directly supported by the libev core alone.
-.Sp
-In standalone mode, libev will still try to automatically deduce the
-configuration, but has to be more conservative.
-.IP "\s-1EV_USE_FLOOR\s0" 4
-.IX Item "EV_USE_FLOOR"
-If defined to be \f(CW1\fR, libev will use the \f(CW\*(C`floor ()\*(C'\fR function for its
-periodic reschedule calculations, otherwise libev will fall back on a
-portable (slower) implementation. If you enable this, you usually have to
-link against libm or something equivalent. Enabling this when the \f(CW\*(C`floor\*(C'\fR
-function is not available will fail, so the safe default is to not enable
-this.
-.IP "\s-1EV_USE_MONOTONIC\s0" 4
-.IX Item "EV_USE_MONOTONIC"
-If defined to be \f(CW1\fR, libev will try to detect the availability of the
-monotonic clock option at both compile time and runtime. Otherwise no
-use of the monotonic clock option will be attempted. If you enable this,
-you usually have to link against librt or something similar. Enabling it
-when the functionality isn't available is safe, though, although you have
-to make sure you link against any libraries where the \f(CW\*(C`clock_gettime\*(C'\fR
-function is hiding in (often \fI\-lrt\fR). See also \f(CW\*(C`EV_USE_CLOCK_SYSCALL\*(C'\fR.
-.IP "\s-1EV_USE_REALTIME\s0" 4
-.IX Item "EV_USE_REALTIME"
-If defined to be \f(CW1\fR, libev will try to detect the availability of the
-real-time clock option at compile time (and assume its availability
-at runtime if successful). Otherwise no use of the real-time clock
-option will be attempted. This effectively replaces \f(CW\*(C`gettimeofday\*(C'\fR
-by \f(CW\*(C`clock_get (CLOCK_REALTIME, ...)\*(C'\fR and will not normally affect
-correctness. See the note about libraries in the description of
-\&\f(CW\*(C`EV_USE_MONOTONIC\*(C'\fR, though. Defaults to the opposite value of
-\&\f(CW\*(C`EV_USE_CLOCK_SYSCALL\*(C'\fR.
-.IP "\s-1EV_USE_CLOCK_SYSCALL\s0" 4
-.IX Item "EV_USE_CLOCK_SYSCALL"
-If defined to be \f(CW1\fR, libev will try to use a direct syscall instead
-of calling the system-provided \f(CW\*(C`clock_gettime\*(C'\fR function. This option
-exists because on GNU/Linux, \f(CW\*(C`clock_gettime\*(C'\fR is in \f(CW\*(C`librt\*(C'\fR, but \f(CW\*(C`librt\*(C'\fR
-unconditionally pulls in \f(CW\*(C`libpthread\*(C'\fR, slowing down single-threaded
-programs needlessly. Using a direct syscall is slightly slower (in
-theory), because no optimised vdso implementation can be used, but avoids
-the pthread dependency. Defaults to \f(CW1\fR on GNU/Linux with glibc 2.x or
-higher, as it simplifies linking (no need for \f(CW\*(C`\-lrt\*(C'\fR).
-.IP "\s-1EV_USE_NANOSLEEP\s0" 4
-.IX Item "EV_USE_NANOSLEEP"
-If defined to be \f(CW1\fR, libev will assume that \f(CW\*(C`nanosleep ()\*(C'\fR is available
-and will use it for delays. Otherwise it will use \f(CW\*(C`select ()\*(C'\fR.
-.IP "\s-1EV_USE_EVENTFD\s0" 4
-.IX Item "EV_USE_EVENTFD"
-If defined to be \f(CW1\fR, then libev will assume that \f(CW\*(C`eventfd ()\*(C'\fR is
-available and will probe for kernel support at runtime. This will improve
-\&\f(CW\*(C`ev_signal\*(C'\fR and \f(CW\*(C`ev_async\*(C'\fR performance and reduce resource consumption.
-If undefined, it will be enabled if the headers indicate GNU/Linux + Glibc
-2.7 or newer, otherwise disabled.
-.IP "\s-1EV_USE_SELECT\s0" 4
-.IX Item "EV_USE_SELECT"
-If undefined or defined to be \f(CW1\fR, libev will compile in support for the
-\&\f(CW\*(C`select\*(C'\fR(2) backend. No attempt at auto-detection will be done: if no
-other method takes over, select will be it. Otherwise the select backend
-will not be compiled in.
-.IP "\s-1EV_SELECT_USE_FD_SET\s0" 4
-.IX Item "EV_SELECT_USE_FD_SET"
-If defined to \f(CW1\fR, then the select backend will use the system \f(CW\*(C`fd_set\*(C'\fR
-structure. This is useful if libev doesn't compile due to a missing
-\&\f(CW\*(C`NFDBITS\*(C'\fR or \f(CW\*(C`fd_mask\*(C'\fR definition or it mis-guesses the bitset layout
-on exotic systems. This usually limits the range of file descriptors to
-some low limit such as 1024 or might have other limitations (winsocket
-only allows 64 sockets). The \f(CW\*(C`FD_SETSIZE\*(C'\fR macro, set before compilation,
-configures the maximum size of the \f(CW\*(C`fd_set\*(C'\fR.
-.IP "\s-1EV_SELECT_IS_WINSOCKET\s0" 4
-.IX Item "EV_SELECT_IS_WINSOCKET"
-When defined to \f(CW1\fR, the select backend will assume that
-select/socket/connect etc. don't understand file descriptors but
-wants osf handles on win32 (this is the case when the select to
-be used is the winsock select). This means that it will call
-\&\f(CW\*(C`_get_osfhandle\*(C'\fR on the fd to convert it to an \s-1OS\s0 handle. Otherwise,
-it is assumed that all these functions actually work on fds, even
-on win32. Should not be defined on non\-win32 platforms.
-.IP "\s-1EV_FD_TO_WIN32_HANDLE\s0(fd)" 4
-.IX Item "EV_FD_TO_WIN32_HANDLE(fd)"
-If \f(CW\*(C`EV_SELECT_IS_WINSOCKET\*(C'\fR is enabled, then libev needs a way to map
-file descriptors to socket handles. When not defining this symbol (the
-default), then libev will call \f(CW\*(C`_get_osfhandle\*(C'\fR, which is usually
-correct. In some cases, programs use their own file descriptor management,
-in which case they can provide this function to map fds to socket handles.
-.IP "\s-1EV_WIN32_HANDLE_TO_FD\s0(handle)" 4
-.IX Item "EV_WIN32_HANDLE_TO_FD(handle)"
-If \f(CW\*(C`EV_SELECT_IS_WINSOCKET\*(C'\fR then libev maps handles to file descriptors
-using the standard \f(CW\*(C`_open_osfhandle\*(C'\fR function. For programs implementing
-their own fd to handle mapping, overwriting this function makes it easier
-to do so. This can be done by defining this macro to an appropriate value.
-.IP "\s-1EV_WIN32_CLOSE_FD\s0(fd)" 4
-.IX Item "EV_WIN32_CLOSE_FD(fd)"
-If programs implement their own fd to handle mapping on win32, then this
-macro can be used to override the \f(CW\*(C`close\*(C'\fR function, useful to unregister
-file descriptors again. Note that the replacement function has to close
-the underlying \s-1OS\s0 handle.
-.IP "\s-1EV_USE_WSASOCKET\s0" 4
-.IX Item "EV_USE_WSASOCKET"
-If defined to be \f(CW1\fR, libev will use \f(CW\*(C`WSASocket\*(C'\fR to create its internal
-communication socket, which works better in some environments. Otherwise,
-the normal \f(CW\*(C`socket\*(C'\fR function will be used, which works better in other
-environments.
-.IP "\s-1EV_USE_POLL\s0" 4
-.IX Item "EV_USE_POLL"
-If defined to be \f(CW1\fR, libev will compile in support for the \f(CW\*(C`poll\*(C'\fR(2)
-backend. Otherwise it will be enabled on non\-win32 platforms. It
-takes precedence over select.
-.IP "\s-1EV_USE_EPOLL\s0" 4
-.IX Item "EV_USE_EPOLL"
-If defined to be \f(CW1\fR, libev will compile in support for the Linux
-\&\f(CW\*(C`epoll\*(C'\fR(7) backend. Its availability will be detected at runtime,
-otherwise another method will be used as fallback. This is the preferred
-backend for GNU/Linux systems. If undefined, it will be enabled if the
-headers indicate GNU/Linux + Glibc 2.4 or newer, otherwise disabled.
-.IP "\s-1EV_USE_KQUEUE\s0" 4
-.IX Item "EV_USE_KQUEUE"
-If defined to be \f(CW1\fR, libev will compile in support for the \s-1BSD\s0 style
-\&\f(CW\*(C`kqueue\*(C'\fR(2) backend. Its actual availability will be detected at runtime,
-otherwise another method will be used as fallback. This is the preferred
-backend for \s-1BSD\s0 and BSD-like systems, although on most BSDs kqueue only
-supports some types of fds correctly (the only platform we found that
-supports ptys for example was NetBSD), so kqueue might be compiled in, but
-not be used unless explicitly requested. The best way to use it is to find
-out whether kqueue supports your type of fd properly and use an embedded
-kqueue loop.
-.IP "\s-1EV_USE_PORT\s0" 4
-.IX Item "EV_USE_PORT"
-If defined to be \f(CW1\fR, libev will compile in support for the Solaris
-10 port style backend. Its availability will be detected at runtime,
-otherwise another method will be used as fallback. This is the preferred
-backend for Solaris 10 systems.
-.IP "\s-1EV_USE_DEVPOLL\s0" 4
-.IX Item "EV_USE_DEVPOLL"
-Reserved for future expansion, works like the \s-1USE\s0 symbols above.
-.IP "\s-1EV_USE_INOTIFY\s0" 4
-.IX Item "EV_USE_INOTIFY"
-If defined to be \f(CW1\fR, libev will compile in support for the Linux inotify
-interface to speed up \f(CW\*(C`ev_stat\*(C'\fR watchers. Its actual availability will
-be detected at runtime. If undefined, it will be enabled if the headers
-indicate GNU/Linux + Glibc 2.4 or newer, otherwise disabled.
-.IP "\s-1EV_NO_SMP\s0" 4
-.IX Item "EV_NO_SMP"
-If defined to be \f(CW1\fR, libev will assume that memory is always coherent
-between threads, that is, threads can be used, but threads never run on
-different cpus (or different cpu cores). This reduces dependencies
-and makes libev faster.
-.IP "\s-1EV_NO_THREADS\s0" 4
-.IX Item "EV_NO_THREADS"
-If defined to be \f(CW1\fR, libev will assume that it will never be called from
-different threads (that includes signal handlers), which is a stronger
-assumption than \f(CW\*(C`EV_NO_SMP\*(C'\fR, above. This reduces dependencies and makes
-libev faster.
-.IP "\s-1EV_ATOMIC_T\s0" 4
-.IX Item "EV_ATOMIC_T"
-Libev requires an integer type (suitable for storing \f(CW0\fR or \f(CW1\fR) whose
-access is atomic with respect to other threads or signal contexts. No
-such type is easily found in the C language, so you can provide your own
-type that you know is safe for your purposes. It is used both for signal
-handler \*(L"locking\*(R" as well as for signal and thread safety in \f(CW\*(C`ev_async\*(C'\fR
-watchers.
-.Sp
-In the absence of this define, libev will use \f(CW\*(C`sig_atomic_t volatile\*(C'\fR
-(from \fIsignal.h\fR), which is usually good enough on most platforms.
-.IP "\s-1EV_H \s0(h)" 4
-.IX Item "EV_H (h)"
-The name of the \fIev.h\fR header file used to include it. The default if
-undefined is \f(CW"ev.h"\fR in \fIevent.h\fR, \fIev.c\fR and \fIev++.h\fR. This can be
-used to virtually rename the \fIev.h\fR header file in case of conflicts.
-.IP "\s-1EV_CONFIG_H \s0(h)" 4
-.IX Item "EV_CONFIG_H (h)"
-If \f(CW\*(C`EV_STANDALONE\*(C'\fR isn't \f(CW1\fR, this variable can be used to override
-\&\fIev.c\fR's idea of where to find the \fIconfig.h\fR file, similarly to
-\&\f(CW\*(C`EV_H\*(C'\fR, above.
-.IP "\s-1EV_EVENT_H \s0(h)" 4
-.IX Item "EV_EVENT_H (h)"
-Similarly to \f(CW\*(C`EV_H\*(C'\fR, this macro can be used to override \fIevent.c\fR's idea
-of how the \fIevent.h\fR header can be found, the default is \f(CW"event.h"\fR.
-.IP "\s-1EV_PROTOTYPES \s0(h)" 4
-.IX Item "EV_PROTOTYPES (h)"
-If defined to be \f(CW0\fR, then \fIev.h\fR will not define any function
-prototypes, but still define all the structs and other symbols. This is
-occasionally useful if you want to provide your own wrapper functions
-around libev functions.
-.IP "\s-1EV_MULTIPLICITY\s0" 4
-.IX Item "EV_MULTIPLICITY"
-If undefined or defined to \f(CW1\fR, then all event-loop-specific functions
-will have the \f(CW\*(C`struct ev_loop *\*(C'\fR as first argument, and you can create
-additional independent event loops. Otherwise there will be no support
-for multiple event loops and there is no first event loop pointer
-argument. Instead, all functions act on the single default loop.
-.Sp
-Note that \f(CW\*(C`EV_DEFAULT\*(C'\fR and \f(CW\*(C`EV_DEFAULT_\*(C'\fR will no longer provide a
-default loop when multiplicity is switched off \- you always have to
-initialise the loop manually in this case.
-.IP "\s-1EV_MINPRI\s0" 4
-.IX Item "EV_MINPRI"
-.PD 0
-.IP "\s-1EV_MAXPRI\s0" 4
-.IX Item "EV_MAXPRI"
-.PD
-The range of allowed priorities. \f(CW\*(C`EV_MINPRI\*(C'\fR must be smaller or equal to
-\&\f(CW\*(C`EV_MAXPRI\*(C'\fR, but otherwise there are no non-obvious limitations. You can
-provide for more priorities by overriding those symbols (usually defined
-to be \f(CW\*(C`\-2\*(C'\fR and \f(CW2\fR, respectively).
-.Sp
-When doing priority-based operations, libev usually has to linearly search
-all the priorities, so having many of them (hundreds) uses a lot of space
-and time, so using the defaults of five priorities (\-2 .. +2) is usually
-fine.
-.Sp
-If your embedding application does not need any priorities, defining these
-both to \f(CW0\fR will save some memory and \s-1CPU.\s0
-.IP "\s-1EV_PERIODIC_ENABLE, EV_IDLE_ENABLE, EV_EMBED_ENABLE, EV_STAT_ENABLE, EV_PREPARE_ENABLE, EV_CHECK_ENABLE, EV_FORK_ENABLE, EV_SIGNAL_ENABLE, EV_ASYNC_ENABLE, EV_CHILD_ENABLE.\s0" 4
-.IX Item "EV_PERIODIC_ENABLE, EV_IDLE_ENABLE, EV_EMBED_ENABLE, EV_STAT_ENABLE, EV_PREPARE_ENABLE, EV_CHECK_ENABLE, EV_FORK_ENABLE, EV_SIGNAL_ENABLE, EV_ASYNC_ENABLE, EV_CHILD_ENABLE."
-If undefined or defined to be \f(CW1\fR (and the platform supports it), then
-the respective watcher type is supported. If defined to be \f(CW0\fR, then it
-is not. Disabling watcher types mainly saves code size.
-.IP "\s-1EV_FEATURES\s0" 4
-.IX Item "EV_FEATURES"
-If you need to shave off some kilobytes of code at the expense of some
-speed (but with the full \s-1API\s0), you can define this symbol to request
-certain subsets of functionality. The default is to enable all features
-that can be enabled on the platform.
-.Sp
-A typical way to use this symbol is to define it to \f(CW0\fR (or to a bitset
-with some broad features you want) and then selectively re-enable
-additional parts you want, for example if you want everything minimal,
-but multiple event loop support, async and child watchers and the poll
-backend, use this:
-.Sp
-.Vb 5
-\&   #define EV_FEATURES 0
-\&   #define EV_MULTIPLICITY 1
-\&   #define EV_USE_POLL 1
-\&   #define EV_CHILD_ENABLE 1
-\&   #define EV_ASYNC_ENABLE 1
-.Ve
-.Sp
-The actual value is a bitset, it can be a combination of the following
-values (by default, all of these are enabled):
-.RS 4
-.ie n .IP "1 \- faster/larger code" 4
-.el .IP "\f(CW1\fR \- faster/larger code" 4
-.IX Item "1 - faster/larger code"
-Use larger code to speed up some operations.
-.Sp
-Currently this is used to override some inlining decisions (enlarging the
-code size by roughly 30% on amd64).
-.Sp
-When optimising for size, use of compiler flags such as \f(CW\*(C`\-Os\*(C'\fR with
-gcc is recommended, as well as \f(CW\*(C`\-DNDEBUG\*(C'\fR, as libev contains a number of
-assertions.
-.Sp
-The default is off when \f(CW\*(C`_\|_OPTIMIZE_SIZE_\|_\*(C'\fR is defined by your compiler
-(e.g. gcc with \f(CW\*(C`\-Os\*(C'\fR).
-.ie n .IP "2 \- faster/larger data structures" 4
-.el .IP "\f(CW2\fR \- faster/larger data structures" 4
-.IX Item "2 - faster/larger data structures"
-Replaces the small 2\-heap for timer management by a faster 4\-heap, larger
-hash table sizes and so on. This will usually further increase code size
-and can additionally have an effect on the size of data structures at
-runtime.
-.Sp
-The default is off when \f(CW\*(C`_\|_OPTIMIZE_SIZE_\|_\*(C'\fR is defined by your compiler
-(e.g. gcc with \f(CW\*(C`\-Os\*(C'\fR).
-.ie n .IP "4 \- full \s-1API\s0 configuration" 4
-.el .IP "\f(CW4\fR \- full \s-1API\s0 configuration" 4
-.IX Item "4 - full API configuration"
-This enables priorities (sets \f(CW\*(C`EV_MAXPRI\*(C'\fR=2 and \f(CW\*(C`EV_MINPRI\*(C'\fR=\-2), and
-enables multiplicity (\f(CW\*(C`EV_MULTIPLICITY\*(C'\fR=1).
-.ie n .IP "8 \- full \s-1API\s0" 4
-.el .IP "\f(CW8\fR \- full \s-1API\s0" 4
-.IX Item "8 - full API"
-This enables a lot of the \*(L"lesser used\*(R" \s-1API\s0 functions. See \f(CW\*(C`ev.h\*(C'\fR for
-details on which parts of the \s-1API\s0 are still available without this
-feature, and do not complain if this subset changes over time.
-.ie n .IP "16 \- enable all optional watcher types" 4
-.el .IP "\f(CW16\fR \- enable all optional watcher types" 4
-.IX Item "16 - enable all optional watcher types"
-Enables all optional watcher types.  If you want to selectively enable
-only some watcher types other than I/O and timers (e.g. prepare,
-embed, async, child...) you can enable them manually by defining
-\&\f(CW\*(C`EV_watchertype_ENABLE\*(C'\fR to \f(CW1\fR instead.
-.ie n .IP "32 \- enable all backends" 4
-.el .IP "\f(CW32\fR \- enable all backends" 4
-.IX Item "32 - enable all backends"
-This enables all backends \- without this feature, you need to enable at
-least one backend manually (\f(CW\*(C`EV_USE_SELECT\*(C'\fR is a good choice).
-.ie n .IP "64 \- enable OS-specific ""helper"" APIs" 4
-.el .IP "\f(CW64\fR \- enable OS-specific ``helper'' APIs" 4
-.IX Item "64 - enable OS-specific helper APIs"
-Enable inotify, eventfd, signalfd and similar OS-specific helper APIs by
-default.
-.RE
-.RS 4
-.Sp
-Compiling with \f(CW\*(C`gcc \-Os \-DEV_STANDALONE \-DEV_USE_EPOLL=1 \-DEV_FEATURES=0\*(C'\fR
-reduces the compiled size of libev from 24.7Kb code/2.8Kb data to 6.5Kb
-code/0.3Kb data on my GNU/Linux amd64 system, while still giving you I/O
-watchers, timers and monotonic clock support.
-.Sp
-With an intelligent-enough linker (gcc+binutils are intelligent enough
-when you use \f(CW\*(C`\-Wl,\-\-gc\-sections \-ffunction\-sections\*(C'\fR) functions unused by
-your program might be left out as well \- a binary starting a timer and an
-I/O watcher then might come out at only 5Kb.
-.RE
-.IP "\s-1EV_API_STATIC\s0" 4
-.IX Item "EV_API_STATIC"
-If this symbol is defined (by default it is not), then all identifiers
-will have static linkage. This means that libev will not export any
-identifiers, and you cannot link against libev anymore. This can be useful
-when you embed libev, only want to use libev functions in a single file,
-and do not want its identifiers to be visible.
-.Sp
-To use this, define \f(CW\*(C`EV_API_STATIC\*(C'\fR and include \fIev.c\fR in the file that
-wants to use libev.
-.Sp
-This option only works when libev is compiled with a C compiler, as \*(C+
-doesn't support the required declaration syntax.
-.IP "\s-1EV_AVOID_STDIO\s0" 4
-.IX Item "EV_AVOID_STDIO"
-If this is set to \f(CW1\fR at compiletime, then libev will avoid using stdio
-functions (printf, scanf, perror etc.). This will increase the code size
-somewhat, but if your program doesn't otherwise depend on stdio and your
-libc allows it, this avoids linking in the stdio library which is quite
-big.
-.Sp
-Note that error messages might become less precise when this option is
-enabled.
-.IP "\s-1EV_NSIG\s0" 4
-.IX Item "EV_NSIG"
-The highest supported signal number, +1 (or, the number of
-signals): Normally, libev tries to deduce the maximum number of signals
-automatically, but sometimes this fails, in which case it can be
-specified. Also, using a lower number than detected (\f(CW32\fR should be
-good for about any system in existence) can save some memory, as libev
-statically allocates some 12\-24 bytes per signal number.
-.IP "\s-1EV_PID_HASHSIZE\s0" 4
-.IX Item "EV_PID_HASHSIZE"
-\&\f(CW\*(C`ev_child\*(C'\fR watchers use a small hash table to distribute workload by
-pid. The default size is \f(CW16\fR (or \f(CW1\fR with \f(CW\*(C`EV_FEATURES\*(C'\fR disabled),
-usually more than enough. If you need to manage thousands of children you
-might want to increase this value (\fImust\fR be a power of two).
-.IP "\s-1EV_INOTIFY_HASHSIZE\s0" 4
-.IX Item "EV_INOTIFY_HASHSIZE"
-\&\f(CW\*(C`ev_stat\*(C'\fR watchers use a small hash table to distribute workload by
-inotify watch id. The default size is \f(CW16\fR (or \f(CW1\fR with \f(CW\*(C`EV_FEATURES\*(C'\fR
-disabled), usually more than enough. If you need to manage thousands of
-\&\f(CW\*(C`ev_stat\*(C'\fR watchers you might want to increase this value (\fImust\fR be a
-power of two).
-.IP "\s-1EV_USE_4HEAP\s0" 4
-.IX Item "EV_USE_4HEAP"
-Heaps are not very cache-efficient. To improve the cache-efficiency of the
-timer and periodics heaps, libev uses a 4\-heap when this symbol is defined
-to \f(CW1\fR. The 4\-heap uses more complicated (longer) code but has noticeably
-faster performance with many (thousands) of watchers.
-.Sp
-The default is \f(CW1\fR, unless \f(CW\*(C`EV_FEATURES\*(C'\fR overrides it, in which case it
-will be \f(CW0\fR.
-.IP "\s-1EV_HEAP_CACHE_AT\s0" 4
-.IX Item "EV_HEAP_CACHE_AT"
-Heaps are not very cache-efficient. To improve the cache-efficiency of the
-timer and periodics heaps, libev can cache the timestamp (\fIat\fR) within
-the heap structure (selected by defining \f(CW\*(C`EV_HEAP_CACHE_AT\*(C'\fR to \f(CW1\fR),
-which uses 8\-12 bytes more per watcher and a few hundred bytes more code,
-but avoids random read accesses on heap changes. This improves performance
-noticeably with many (hundreds) of watchers.
-.Sp
-The default is \f(CW1\fR, unless \f(CW\*(C`EV_FEATURES\*(C'\fR overrides it, in which case it
-will be \f(CW0\fR.
-.IP "\s-1EV_VERIFY\s0" 4
-.IX Item "EV_VERIFY"
-Controls how much internal verification (see \f(CW\*(C`ev_verify ()\*(C'\fR) will
-be done: If set to \f(CW0\fR, no internal verification code will be compiled
-in. If set to \f(CW1\fR, then verification code will be compiled in, but not
-called. If set to \f(CW2\fR, then the internal verification code will be
-called once per loop, which can slow down libev. If set to \f(CW3\fR, then the
-verification code will be called very frequently, which will slow down
-libev considerably.
-.Sp
-The default is \f(CW1\fR, unless \f(CW\*(C`EV_FEATURES\*(C'\fR overrides it, in which case it
-will be \f(CW0\fR.
-.IP "\s-1EV_COMMON\s0" 4
-.IX Item "EV_COMMON"
-By default, all watchers have a \f(CW\*(C`void *data\*(C'\fR member. By redefining
-this macro to something else you can include more and other types of
-members. You have to define it each time you include one of the files,
-though, and it must be identical each time.
-.Sp
-For example, the perl \s-1EV\s0 module uses something like this:
-.Sp
-.Vb 3
-\&   #define EV_COMMON                       \e
-\&     SV *self; /* contains this struct */  \e
-\&     SV *cb_sv, *fh /* note no trailing ";" */
-.Ve
-.IP "\s-1EV_CB_DECLARE \s0(type)" 4
-.IX Item "EV_CB_DECLARE (type)"
-.PD 0
-.IP "\s-1EV_CB_INVOKE \s0(watcher, revents)" 4
-.IX Item "EV_CB_INVOKE (watcher, revents)"
-.IP "ev_set_cb (ev, cb)" 4
-.IX Item "ev_set_cb (ev, cb)"
-.PD
-Can be used to change the callback member declaration in each watcher,
-and the way callbacks are invoked and set. Must expand to a struct member
-definition and a statement, respectively. See the \fIev.h\fR header file for
-their default definitions. One possible use for overriding these is to
-avoid the \f(CW\*(C`struct ev_loop *\*(C'\fR as first argument in all cases, or to use
-method calls instead of plain function calls in \*(C+.
-.SS "\s-1EXPORTED API SYMBOLS\s0"
-.IX Subsection "EXPORTED API SYMBOLS"
-If you need to re-export the \s-1API \s0(e.g. via a \s-1DLL\s0) and you need a list of
-exported symbols, you can use the provided \fISymbol.*\fR files which list
-all public symbols, one per line:
-.PP
-.Vb 2
-\&   Symbols.ev      for libev proper
-\&   Symbols.event   for the libevent emulation
-.Ve
-.PP
-This can also be used to rename all public symbols to avoid clashes with
-multiple versions of libev linked together (which is obviously bad in
-itself, but sometimes it is inconvenient to avoid this).
-.PP
-A sed command like this will create wrapper \f(CW\*(C`#define\*(C'\fR's that you need to
-include before including \fIev.h\fR:
-.PP
-.Vb 1
-\&   <Symbols.ev sed \-e "s/.*/#define & myprefix_&/" >wrap.h
-.Ve
-.PP
-This would create a file \fIwrap.h\fR which essentially looks like this:
-.PP
-.Vb 4
-\&   #define ev_backend     myprefix_ev_backend
-\&   #define ev_check_start myprefix_ev_check_start
-\&   #define ev_check_stop  myprefix_ev_check_stop
-\&   ...
-.Ve
-.SS "\s-1EXAMPLES\s0"
-.IX Subsection "EXAMPLES"
-For a real-world example of a program the includes libev
-verbatim, you can have a look at the \s-1EV\s0 perl module
-(<http://software.schmorp.de/pkg/EV.html>). It has the libev files in
-the \fIlibev/\fR subdirectory and includes them in the \fI\s-1EV/EVAPI\s0.h\fR (public
-interface) and \fI\s-1EV\s0.xs\fR (implementation) files. Only the \fI\s-1EV\s0.xs\fR file
-will be compiled. It is pretty complex because it provides its own header
-file.
-.PP
-The usage in rxvt-unicode is simpler. It has a \fIev_cpp.h\fR header file
-that everybody includes and which overrides some configure choices:
-.PP
-.Vb 8
-\&   #define EV_FEATURES 8
-\&   #define EV_USE_SELECT 1
-\&   #define EV_PREPARE_ENABLE 1
-\&   #define EV_IDLE_ENABLE 1
-\&   #define EV_SIGNAL_ENABLE 1
-\&   #define EV_CHILD_ENABLE 1
-\&   #define EV_USE_STDEXCEPT 0
-\&   #define EV_CONFIG_H <config.h>
-\&
-\&   #include "ev++.h"
-.Ve
-.PP
-And a \fIev_cpp.C\fR implementation file that contains libev proper and is compiled:
-.PP
-.Vb 2
-\&   #include "ev_cpp.h"
-\&   #include "ev.c"
-.Ve
-.SH "INTERACTION WITH OTHER PROGRAMS, LIBRARIES OR THE ENVIRONMENT"
-.IX Header "INTERACTION WITH OTHER PROGRAMS, LIBRARIES OR THE ENVIRONMENT"
-.SS "\s-1THREADS AND COROUTINES\s0"
-.IX Subsection "THREADS AND COROUTINES"
-\fI\s-1THREADS\s0\fR
-.IX Subsection "THREADS"
-.PP
-All libev functions are reentrant and thread-safe unless explicitly
-documented otherwise, but libev implements no locking itself. This means
-that you can use as many loops as you want in parallel, as long as there
-are no concurrent calls into any libev function with the same loop
-parameter (\f(CW\*(C`ev_default_*\*(C'\fR calls have an implicit default loop parameter,
-of course): libev guarantees that different event loops share no data
-structures that need any locking.
-.PP
-Or to put it differently: calls with different loop parameters can be done
-concurrently from multiple threads, calls with the same loop parameter
-must be done serially (but can be done from different threads, as long as
-only one thread ever is inside a call at any point in time, e.g. by using
-a mutex per loop).
-.PP
-Specifically to support threads (and signal handlers), libev implements
-so-called \f(CW\*(C`ev_async\*(C'\fR watchers, which allow some limited form of
-concurrency on the same event loop, namely waking it up \*(L"from the
-outside\*(R".
-.PP
-If you want to know which design (one loop, locking, or multiple loops
-without or something else still) is best for your problem, then I cannot
-help you, but here is some generic advice:
-.IP "\(bu" 4
-most applications have a main thread: use the default libev loop
-in that thread, or create a separate thread running only the default loop.
-.Sp
-This helps integrating other libraries or software modules that use libev
-themselves and don't care/know about threading.
-.IP "\(bu" 4
-one loop per thread is usually a good model.
-.Sp
-Doing this is almost never wrong, sometimes a better-performance model
-exists, but it is always a good start.
-.IP "\(bu" 4
-other models exist, such as the leader/follower pattern, where one
-loop is handed through multiple threads in a kind of round-robin fashion.
-.Sp
-Choosing a model is hard \- look around, learn, know that usually you can do
-better than you currently do :\-)
-.IP "\(bu" 4
-often you need to talk to some other thread which blocks in the
-event loop.
-.Sp
-\&\f(CW\*(C`ev_async\*(C'\fR watchers can be used to wake them up from other threads safely
-(or from signal contexts...).
-.Sp
-An example use would be to communicate signals or other events that only
-work in the default loop by registering the signal watcher with the
-default loop and triggering an \f(CW\*(C`ev_async\*(C'\fR watcher from the default loop
-watcher callback into the event loop interested in the signal.
-.PP
-See also \*(L"\s-1THREAD LOCKING EXAMPLE\*(R"\s0.
-.PP
-\fI\s-1COROUTINES\s0\fR
-.IX Subsection "COROUTINES"
-.PP
-Libev is very accommodating to coroutines (\*(L"cooperative threads\*(R"):
-libev fully supports nesting calls to its functions from different
-coroutines (e.g. you can call \f(CW\*(C`ev_run\*(C'\fR on the same loop from two
-different coroutines, and switch freely between both coroutines running
-the loop, as long as you don't confuse yourself). The only exception is
-that you must not do this from \f(CW\*(C`ev_periodic\*(C'\fR reschedule callbacks.
-.PP
-Care has been taken to ensure that libev does not keep local state inside
-\&\f(CW\*(C`ev_run\*(C'\fR, and other calls do not usually allow for coroutine switches as
-they do not call any callbacks.
-.SS "\s-1COMPILER WARNINGS\s0"
-.IX Subsection "COMPILER WARNINGS"
-Depending on your compiler and compiler settings, you might get no or a
-lot of warnings when compiling libev code. Some people are apparently
-scared by this.
-.PP
-However, these are unavoidable for many reasons. For one, each compiler
-has different warnings, and each user has different tastes regarding
-warning options. \*(L"Warn-free\*(R" code therefore cannot be a goal except when
-targeting a specific compiler and compiler-version.
-.PP
-Another reason is that some compiler warnings require elaborate
-workarounds, or other changes to the code that make it less clear and less
-maintainable.
-.PP
-And of course, some compiler warnings are just plain stupid, or simply
-wrong (because they don't actually warn about the condition their message
-seems to warn about). For example, certain older gcc versions had some
-warnings that resulted in an extreme number of false positives. These have
-been fixed, but some people still insist on making code warn-free with
-such buggy versions.
-.PP
-While libev is written to generate as few warnings as possible,
-\&\*(L"warn-free\*(R" code is not a goal, and it is recommended not to build libev
-with any compiler warnings enabled unless you are prepared to cope with
-them (e.g. by ignoring them). Remember that warnings are just that:
-warnings, not errors, or proof of bugs.
-.SS "\s-1VALGRIND\s0"
-.IX Subsection "VALGRIND"
-Valgrind has a special section here because it is a popular tool that is
-highly useful. Unfortunately, valgrind reports are very hard to interpret.
-.PP
-If you think you found a bug (memory leak, uninitialised data access etc.)
-in libev, then check twice: If valgrind reports something like:
-.PP
-.Vb 3
-\&   ==2274==    definitely lost: 0 bytes in 0 blocks.
-\&   ==2274==      possibly lost: 0 bytes in 0 blocks.
-\&   ==2274==    still reachable: 256 bytes in 1 blocks.
-.Ve
-.PP
-Then there is no memory leak, just as memory accounted to global variables
-is not a memleak \- the memory is still being referenced, and didn't leak.
-.PP
-Similarly, under some circumstances, valgrind might report kernel bugs
-as if it were a bug in libev (e.g. in realloc or in the poll backend,
-although an acceptable workaround has been found here), or it might be
-confused.
-.PP
-Keep in mind that valgrind is a very good tool, but only a tool. Don't
-make it into some kind of religion.
-.PP
-If you are unsure about something, feel free to contact the mailing list
-with the full valgrind report and an explanation on why you think this
-is a bug in libev (best check the archives, too :). However, don't be
-annoyed when you get a brisk \*(L"this is no bug\*(R" answer and take the chance
-of learning how to interpret valgrind properly.
-.PP
-If you need, for some reason, empty reports from valgrind for your project
-I suggest using suppression lists.
-.SH "PORTABILITY NOTES"
-.IX Header "PORTABILITY NOTES"
-.SS "\s-1GNU/LINUX 32 BIT LIMITATIONS\s0"
-.IX Subsection "GNU/LINUX 32 BIT LIMITATIONS"
-GNU/Linux is the only common platform that supports 64 bit file/large file
-interfaces but \fIdisables\fR them by default.
-.PP
-That means that libev compiled in the default environment doesn't support
-files larger than 2GiB or so, which mainly affects \f(CW\*(C`ev_stat\*(C'\fR watchers.
-.PP
-Unfortunately, many programs try to work around this GNU/Linux issue
-by enabling the large file \s-1API,\s0 which makes them incompatible with the
-standard libev compiled for their system.
-.PP
-Likewise, libev cannot enable the large file \s-1API\s0 itself as this would
-suddenly make it incompatible to the default compile time environment,
-i.e. all programs not using special compile switches.
-.SS "\s-1OS/X AND DARWIN BUGS\s0"
-.IX Subsection "OS/X AND DARWIN BUGS"
-The whole thing is a bug if you ask me \- basically any system interface
-you touch is broken, whether it is locales, poll, kqueue or even the
-OpenGL drivers.
-.PP
-\fI\f(CI\*(C`kqueue\*(C'\fI is buggy\fR
-.IX Subsection "kqueue is buggy"
-.PP
-The kqueue syscall is broken in all known versions \- most versions support
-only sockets, many support pipes.
-.PP
-Libev tries to work around this by not using \f(CW\*(C`kqueue\*(C'\fR by default on this
-rotten platform, but of course you can still ask for it when creating a
-loop \- embedding a socket-only kqueue loop into a select-based one is
-probably going to work well.
-.PP
-\fI\f(CI\*(C`poll\*(C'\fI is buggy\fR
-.IX Subsection "poll is buggy"
-.PP
-Instead of fixing \f(CW\*(C`kqueue\*(C'\fR, Apple replaced their (working) \f(CW\*(C`poll\*(C'\fR
-implementation by something calling \f(CW\*(C`kqueue\*(C'\fR internally around the 10.5.6
-release, so now \f(CW\*(C`kqueue\*(C'\fR \fIand\fR \f(CW\*(C`poll\*(C'\fR are broken.
-.PP
-Libev tries to work around this by not using \f(CW\*(C`poll\*(C'\fR by default on
-this rotten platform, but of course you can still ask for it when creating
-a loop.
-.PP
-\fI\f(CI\*(C`select\*(C'\fI is buggy\fR
-.IX Subsection "select is buggy"
-.PP
-All that's left is \f(CW\*(C`select\*(C'\fR, and of course Apple found a way to fuck this
-one up as well: On \s-1OS/X, \s0\f(CW\*(C`select\*(C'\fR actively limits the number of file
-descriptors you can pass in to 1024 \- your program suddenly crashes when
-you use more.
-.PP
-There is an undocumented \*(L"workaround\*(R" for this \- defining
-\&\f(CW\*(C`_DARWIN_UNLIMITED_SELECT\*(C'\fR, which libev tries to use, so select \fIshould\fR
-work on \s-1OS/X.\s0
-.SS "\s-1SOLARIS PROBLEMS AND WORKAROUNDS\s0"
-.IX Subsection "SOLARIS PROBLEMS AND WORKAROUNDS"
-\fI\f(CI\*(C`errno\*(C'\fI reentrancy\fR
-.IX Subsection "errno reentrancy"
-.PP
-The default compile environment on Solaris is unfortunately so
-thread-unsafe that you can't even use components/libraries compiled
-without \f(CW\*(C`\-D_REENTRANT\*(C'\fR in a threaded program, which, of course, isn't
-defined by default. A valid, if stupid, implementation choice.
-.PP
-If you want to use libev in threaded environments you have to make sure
-it's compiled with \f(CW\*(C`_REENTRANT\*(C'\fR defined.
-.PP
-\fIEvent port backend\fR
-.IX Subsection "Event port backend"
-.PP
-The scalable event interface for Solaris is called \*(L"event
-ports\*(R". Unfortunately, this mechanism is very buggy in all major
-releases. If you run into high \s-1CPU\s0 usage, your program freezes or you get
-a large number of spurious wakeups, make sure you have all the relevant
-and latest kernel patches applied. No, I don't know which ones, but there
-are multiple ones to apply, and afterwards, event ports actually work
-great.
-.PP
-If you can't get it to work, you can try running the program by setting
-the environment variable \f(CW\*(C`LIBEV_FLAGS=3\*(C'\fR to only allow \f(CW\*(C`poll\*(C'\fR and
-\&\f(CW\*(C`select\*(C'\fR backends.
-.SS "\s-1AIX POLL BUG\s0"
-.IX Subsection "AIX POLL BUG"
-\&\s-1AIX\s0 unfortunately has a broken \f(CW\*(C`poll.h\*(C'\fR header. Libev works around
-this by trying to avoid the poll backend altogether (i.e. it's not even
-compiled in), which normally isn't a big problem as \f(CW\*(C`select\*(C'\fR works fine
-with large bitsets on \s-1AIX,\s0 and \s-1AIX\s0 is dead anyway.
-.SS "\s-1WIN32 PLATFORM LIMITATIONS AND WORKAROUNDS\s0"
-.IX Subsection "WIN32 PLATFORM LIMITATIONS AND WORKAROUNDS"
-\fIGeneral issues\fR
-.IX Subsection "General issues"
-.PP
-Win32 doesn't support any of the standards (e.g. \s-1POSIX\s0) that libev
-requires, and its I/O model is fundamentally incompatible with the \s-1POSIX\s0
-model. Libev still offers limited functionality on this platform in
-the form of the \f(CW\*(C`EVBACKEND_SELECT\*(C'\fR backend, and only supports socket
-descriptors. This only applies when using Win32 natively, not when using
-e.g. cygwin. Actually, it only applies to the microsofts own compilers,
-as every compiler comes with a slightly differently broken/incompatible
-environment.
-.PP
-Lifting these limitations would basically require the full
-re-implementation of the I/O system. If you are into this kind of thing,
-then note that glib does exactly that for you in a very portable way (note
-also that glib is the slowest event library known to man).
-.PP
-There is no supported compilation method available on windows except
-embedding it into other applications.
-.PP
-Sensible signal handling is officially unsupported by Microsoft \- libev
-tries its best, but under most conditions, signals will simply not work.
-.PP
-Not a libev limitation but worth mentioning: windows apparently doesn't
-accept large writes: instead of resulting in a partial write, windows will
-either accept everything or return \f(CW\*(C`ENOBUFS\*(C'\fR if the buffer is too large,
-so make sure you only write small amounts into your sockets (less than a
-megabyte seems safe, but this apparently depends on the amount of memory
-available).
-.PP
-Due to the many, low, and arbitrary limits on the win32 platform and
-the abysmal performance of winsockets, using a large number of sockets
-is not recommended (and not reasonable). If your program needs to use
-more than a hundred or so sockets, then likely it needs to use a totally
-different implementation for windows, as libev offers the \s-1POSIX\s0 readiness
-notification model, which cannot be implemented efficiently on windows
-(due to Microsoft monopoly games).
-.PP
-A typical way to use libev under windows is to embed it (see the embedding
-section for details) and use the following \fIevwrap.h\fR header file instead
-of \fIev.h\fR:
-.PP
-.Vb 2
-\&   #define EV_STANDALONE              /* keeps ev from requiring config.h */
-\&   #define EV_SELECT_IS_WINSOCKET 1   /* configure libev for windows select */
-\&
-\&   #include "ev.h"
-.Ve
-.PP
-And compile the following \fIevwrap.c\fR file into your project (make sure
-you do \fInot\fR compile the \fIev.c\fR or any other embedded source files!):
-.PP
-.Vb 2
-\&   #include "evwrap.h"
-\&   #include "ev.c"
-.Ve
-.PP
-\fIThe winsocket \f(CI\*(C`select\*(C'\fI function\fR
-.IX Subsection "The winsocket select function"
-.PP
-The winsocket \f(CW\*(C`select\*(C'\fR function doesn't follow \s-1POSIX\s0 in that it
-requires socket \fIhandles\fR and not socket \fIfile descriptors\fR (it is
-also extremely buggy). This makes select very inefficient, and also
-requires a mapping from file descriptors to socket handles (the Microsoft
-C runtime provides the function \f(CW\*(C`_open_osfhandle\*(C'\fR for this). See the
-discussion of the \f(CW\*(C`EV_SELECT_USE_FD_SET\*(C'\fR, \f(CW\*(C`EV_SELECT_IS_WINSOCKET\*(C'\fR and
-\&\f(CW\*(C`EV_FD_TO_WIN32_HANDLE\*(C'\fR preprocessor symbols for more info.
-.PP
-The configuration for a \*(L"naked\*(R" win32 using the Microsoft runtime
-libraries and raw winsocket select is:
-.PP
-.Vb 2
-\&   #define EV_USE_SELECT 1
-\&   #define EV_SELECT_IS_WINSOCKET 1   /* forces EV_SELECT_USE_FD_SET, too */
-.Ve
-.PP
-Note that winsockets handling of fd sets is O(n), so you can easily get a
-complexity in the O(nX) range when using win32.
-.PP
-\fILimited number of file descriptors\fR
-.IX Subsection "Limited number of file descriptors"
-.PP
-Windows has numerous arbitrary (and low) limits on things.
-.PP
-Early versions of winsocket's select only supported waiting for a maximum
-of \f(CW64\fR handles (probably owning to the fact that all windows kernels
-can only wait for \f(CW64\fR things at the same time internally; Microsoft
-recommends spawning a chain of threads and wait for 63 handles and the
-previous thread in each. Sounds great!).
-.PP
-Newer versions support more handles, but you need to define \f(CW\*(C`FD_SETSIZE\*(C'\fR
-to some high number (e.g. \f(CW2048\fR) before compiling the winsocket select
-call (which might be in libev or elsewhere, for example, perl and many
-other interpreters do their own select emulation on windows).
-.PP
-Another limit is the number of file descriptors in the Microsoft runtime
-libraries, which by default is \f(CW64\fR (there must be a hidden \fI64\fR
-fetish or something like this inside Microsoft). You can increase this
-by calling \f(CW\*(C`_setmaxstdio\*(C'\fR, which can increase this limit to \f(CW2048\fR
-(another arbitrary limit), but is broken in many versions of the Microsoft
-runtime libraries. This might get you to about \f(CW512\fR or \f(CW2048\fR sockets
-(depending on windows version and/or the phase of the moon). To get more,
-you need to wrap all I/O functions and provide your own fd management, but
-the cost of calling select (O(nX)) will likely make this unworkable.
-.SS "\s-1PORTABILITY REQUIREMENTS\s0"
-.IX Subsection "PORTABILITY REQUIREMENTS"
-In addition to a working ISO-C implementation and of course the
-backend-specific APIs, libev relies on a few additional extensions:
-.ie n .IP """void (*)(ev_watcher_type *, int revents)"" must have compatible calling conventions regardless of ""ev_watcher_type *""." 4
-.el .IP "\f(CWvoid (*)(ev_watcher_type *, int revents)\fR must have compatible calling conventions regardless of \f(CWev_watcher_type *\fR." 4
-.IX Item "void (*)(ev_watcher_type *, int revents) must have compatible calling conventions regardless of ev_watcher_type *."
-Libev assumes not only that all watcher pointers have the same internal
-structure (guaranteed by \s-1POSIX\s0 but not by \s-1ISO C\s0 for example), but it also
-assumes that the same (machine) code can be used to call any watcher
-callback: The watcher callbacks have different type signatures, but libev
-calls them using an \f(CW\*(C`ev_watcher *\*(C'\fR internally.
-.IP "null pointers and integer zero are represented by 0 bytes" 4
-.IX Item "null pointers and integer zero are represented by 0 bytes"
-Libev uses \f(CW\*(C`memset\*(C'\fR to initialise structs and arrays to \f(CW0\fR bytes, and
-relies on this setting pointers and integers to null.
-.IP "pointer accesses must be thread-atomic" 4
-.IX Item "pointer accesses must be thread-atomic"
-Accessing a pointer value must be atomic, it must both be readable and
-writable in one piece \- this is the case on all current architectures.
-.ie n .IP """sig_atomic_t volatile"" must be thread-atomic as well" 4
-.el .IP "\f(CWsig_atomic_t volatile\fR must be thread-atomic as well" 4
-.IX Item "sig_atomic_t volatile must be thread-atomic as well"
-The type \f(CW\*(C`sig_atomic_t volatile\*(C'\fR (or whatever is defined as
-\&\f(CW\*(C`EV_ATOMIC_T\*(C'\fR) must be atomic with respect to accesses from different
-threads. This is not part of the specification for \f(CW\*(C`sig_atomic_t\*(C'\fR, but is
-believed to be sufficiently portable.
-.ie n .IP """sigprocmask"" must work in a threaded environment" 4
-.el .IP "\f(CWsigprocmask\fR must work in a threaded environment" 4
-.IX Item "sigprocmask must work in a threaded environment"
-Libev uses \f(CW\*(C`sigprocmask\*(C'\fR to temporarily block signals. This is not
-allowed in a threaded program (\f(CW\*(C`pthread_sigmask\*(C'\fR has to be used). Typical
-pthread implementations will either allow \f(CW\*(C`sigprocmask\*(C'\fR in the \*(L"main
-thread\*(R" or will block signals process-wide, both behaviours would
-be compatible with libev. Interaction between \f(CW\*(C`sigprocmask\*(C'\fR and
-\&\f(CW\*(C`pthread_sigmask\*(C'\fR could complicate things, however.
-.Sp
-The most portable way to handle signals is to block signals in all threads
-except the initial one, and run the signal handling loop in the initial
-thread as well.
-.ie n .IP """long"" must be large enough for common memory allocation sizes" 4
-.el .IP "\f(CWlong\fR must be large enough for common memory allocation sizes" 4
-.IX Item "long must be large enough for common memory allocation sizes"
-To improve portability and simplify its \s-1API,\s0 libev uses \f(CW\*(C`long\*(C'\fR internally
-instead of \f(CW\*(C`size_t\*(C'\fR when allocating its data structures. On non-POSIX
-systems (Microsoft...) this might be unexpectedly low, but is still at
-least 31 bits everywhere, which is enough for hundreds of millions of
-watchers.
-.ie n .IP """double"" must hold a time value in seconds with enough accuracy" 4
-.el .IP "\f(CWdouble\fR must hold a time value in seconds with enough accuracy" 4
-.IX Item "double must hold a time value in seconds with enough accuracy"
-The type \f(CW\*(C`double\*(C'\fR is used to represent timestamps. It is required to
-have at least 51 bits of mantissa (and 9 bits of exponent), which is
-good enough for at least into the year 4000 with millisecond accuracy
-(the design goal for libev). This requirement is overfulfilled by
-implementations using \s-1IEEE 754,\s0 which is basically all existing ones.
-.Sp
-With \s-1IEEE 754\s0 doubles, you get microsecond accuracy until at least the
-year 2255 (and millisecond accuracy till the year 287396 \- by then, libev
-is either obsolete or somebody patched it to use \f(CW\*(C`long double\*(C'\fR or
-something like that, just kidding).
-.PP
-If you know of other additional requirements drop me a note.
-.SH "ALGORITHMIC COMPLEXITIES"
-.IX Header "ALGORITHMIC COMPLEXITIES"
-In this section the complexities of (many of) the algorithms used inside
-libev will be documented. For complexity discussions about backends see
-the documentation for \f(CW\*(C`ev_default_init\*(C'\fR.
-.PP
-All of the following are about amortised time: If an array needs to be
-extended, libev needs to realloc and move the whole array, but this
-happens asymptotically rarer with higher number of elements, so O(1) might
-mean that libev does a lengthy realloc operation in rare cases, but on
-average it is much faster and asymptotically approaches constant time.
-.IP "Starting and stopping timer/periodic watchers: O(log skipped_other_timers)" 4
-.IX Item "Starting and stopping timer/periodic watchers: O(log skipped_other_timers)"
-This means that, when you have a watcher that triggers in one hour and
-there are 100 watchers that would trigger before that, then inserting will
-have to skip roughly seven (\f(CW\*(C`ld 100\*(C'\fR) of these watchers.
-.IP "Changing timer/periodic watchers (by autorepeat or calling again): O(log skipped_other_timers)" 4
-.IX Item "Changing timer/periodic watchers (by autorepeat or calling again): O(log skipped_other_timers)"
-That means that changing a timer costs less than removing/adding them,
-as only the relative motion in the event queue has to be paid for.
-.IP "Starting io/check/prepare/idle/signal/child/fork/async watchers: O(1)" 4
-.IX Item "Starting io/check/prepare/idle/signal/child/fork/async watchers: O(1)"
-These just add the watcher into an array or at the head of a list.
-.IP "Stopping check/prepare/idle/fork/async watchers: O(1)" 4
-.IX Item "Stopping check/prepare/idle/fork/async watchers: O(1)"
-.PD 0
-.IP "Stopping an io/signal/child watcher: O(number_of_watchers_for_this_(fd/signal/pid % \s-1EV_PID_HASHSIZE\s0))" 4
-.IX Item "Stopping an io/signal/child watcher: O(number_of_watchers_for_this_(fd/signal/pid % EV_PID_HASHSIZE))"
-.PD
-These watchers are stored in lists, so they need to be walked to find the
-correct watcher to remove. The lists are usually short (you don't usually
-have many watchers waiting for the same fd or signal: one is typical, two
-is rare).
-.IP "Finding the next timer in each loop iteration: O(1)" 4
-.IX Item "Finding the next timer in each loop iteration: O(1)"
-By virtue of using a binary or 4\-heap, the next timer is always found at a
-fixed position in the storage array.
-.IP "Each change on a file descriptor per loop iteration: O(number_of_watchers_for_this_fd)" 4
-.IX Item "Each change on a file descriptor per loop iteration: O(number_of_watchers_for_this_fd)"
-A change means an I/O watcher gets started or stopped, which requires
-libev to recalculate its status (and possibly tell the kernel, depending
-on backend and whether \f(CW\*(C`ev_io_set\*(C'\fR was used).
-.IP "Activating one watcher (putting it into the pending state): O(1)" 4
-.IX Item "Activating one watcher (putting it into the pending state): O(1)"
-.PD 0
-.IP "Priority handling: O(number_of_priorities)" 4
-.IX Item "Priority handling: O(number_of_priorities)"
-.PD
-Priorities are implemented by allocating some space for each
-priority. When doing priority-based operations, libev usually has to
-linearly search all the priorities, but starting/stopping and activating
-watchers becomes O(1) with respect to priority handling.
-.IP "Sending an ev_async: O(1)" 4
-.IX Item "Sending an ev_async: O(1)"
-.PD 0
-.IP "Processing ev_async_send: O(number_of_async_watchers)" 4
-.IX Item "Processing ev_async_send: O(number_of_async_watchers)"
-.IP "Processing signals: O(max_signal_number)" 4
-.IX Item "Processing signals: O(max_signal_number)"
-.PD
-Sending involves a system call \fIiff\fR there were no other \f(CW\*(C`ev_async_send\*(C'\fR
-calls in the current loop iteration and the loop is currently
-blocked. Checking for async and signal events involves iterating over all
-running async watchers or all signal numbers.
-.SH "PORTING FROM LIBEV 3.X TO 4.X"
-.IX Header "PORTING FROM LIBEV 3.X TO 4.X"
-The major version 4 introduced some incompatible changes to the \s-1API.\s0
-.PP
-At the moment, the \f(CW\*(C`ev.h\*(C'\fR header file provides compatibility definitions
-for all changes, so most programs should still compile. The compatibility
-layer might be removed in later versions of libev, so better update to the
-new \s-1API\s0 early than late.
-.ie n .IP """EV_COMPAT3"" backwards compatibility mechanism" 4
-.el .IP "\f(CWEV_COMPAT3\fR backwards compatibility mechanism" 4
-.IX Item "EV_COMPAT3 backwards compatibility mechanism"
-The backward compatibility mechanism can be controlled by
-\&\f(CW\*(C`EV_COMPAT3\*(C'\fR. See \*(L"\s-1PREPROCESSOR SYMBOLS/MACROS\*(R"\s0 in the \*(L"\s-1EMBEDDING\*(R"\s0
-section.
-.ie n .IP """ev_default_destroy"" and ""ev_default_fork"" have been removed" 4
-.el .IP "\f(CWev_default_destroy\fR and \f(CWev_default_fork\fR have been removed" 4
-.IX Item "ev_default_destroy and ev_default_fork have been removed"
-These calls can be replaced easily by their \f(CW\*(C`ev_loop_xxx\*(C'\fR counterparts:
-.Sp
-.Vb 2
-\&   ev_loop_destroy (EV_DEFAULT_UC);
-\&   ev_loop_fork (EV_DEFAULT);
-.Ve
-.IP "function/symbol renames" 4
-.IX Item "function/symbol renames"
-A number of functions and symbols have been renamed:
-.Sp
-.Vb 3
-\&  ev_loop         => ev_run
-\&  EVLOOP_NONBLOCK => EVRUN_NOWAIT
-\&  EVLOOP_ONESHOT  => EVRUN_ONCE
-\&
-\&  ev_unloop       => ev_break
-\&  EVUNLOOP_CANCEL => EVBREAK_CANCEL
-\&  EVUNLOOP_ONE    => EVBREAK_ONE
-\&  EVUNLOOP_ALL    => EVBREAK_ALL
-\&
-\&  EV_TIMEOUT      => EV_TIMER
-\&
-\&  ev_loop_count   => ev_iteration
-\&  ev_loop_depth   => ev_depth
-\&  ev_loop_verify  => ev_verify
-.Ve
-.Sp
-Most functions working on \f(CW\*(C`struct ev_loop\*(C'\fR objects don't have an
-\&\f(CW\*(C`ev_loop_\*(C'\fR prefix, so it was removed; \f(CW\*(C`ev_loop\*(C'\fR, \f(CW\*(C`ev_unloop\*(C'\fR and
-associated constants have been renamed to not collide with the \f(CW\*(C`struct
-ev_loop\*(C'\fR anymore and \f(CW\*(C`EV_TIMER\*(C'\fR now follows the same naming scheme
-as all other watcher types. Note that \f(CW\*(C`ev_loop_fork\*(C'\fR is still called
-\&\f(CW\*(C`ev_loop_fork\*(C'\fR because it would otherwise clash with the \f(CW\*(C`ev_fork\*(C'\fR
-typedef.
-.ie n .IP """EV_MINIMAL"" mechanism replaced by ""EV_FEATURES""" 4
-.el .IP "\f(CWEV_MINIMAL\fR mechanism replaced by \f(CWEV_FEATURES\fR" 4
-.IX Item "EV_MINIMAL mechanism replaced by EV_FEATURES"
-The preprocessor symbol \f(CW\*(C`EV_MINIMAL\*(C'\fR has been replaced by a different
-mechanism, \f(CW\*(C`EV_FEATURES\*(C'\fR. Programs using \f(CW\*(C`EV_MINIMAL\*(C'\fR usually compile
-and work, but the library code will of course be larger.
-.SH "GLOSSARY"
-.IX Header "GLOSSARY"
-.IP "active" 4
-.IX Item "active"
-A watcher is active as long as it has been started and not yet stopped.
-See \*(L"\s-1WATCHER STATES\*(R"\s0 for details.
-.IP "application" 4
-.IX Item "application"
-In this document, an application is whatever is using libev.
-.IP "backend" 4
-.IX Item "backend"
-The part of the code dealing with the operating system interfaces.
-.IP "callback" 4
-.IX Item "callback"
-The address of a function that is called when some event has been
-detected. Callbacks are being passed the event loop, the watcher that
-received the event, and the actual event bitset.
-.IP "callback/watcher invocation" 4
-.IX Item "callback/watcher invocation"
-The act of calling the callback associated with a watcher.
-.IP "event" 4
-.IX Item "event"
-A change of state of some external event, such as data now being available
-for reading on a file descriptor, time having passed or simply not having
-any other events happening anymore.
-.Sp
-In libev, events are represented as single bits (such as \f(CW\*(C`EV_READ\*(C'\fR or
-\&\f(CW\*(C`EV_TIMER\*(C'\fR).
-.IP "event library" 4
-.IX Item "event library"
-A software package implementing an event model and loop.
-.IP "event loop" 4
-.IX Item "event loop"
-An entity that handles and processes external events and converts them
-into callback invocations.
-.IP "event model" 4
-.IX Item "event model"
-The model used to describe how an event loop handles and processes
-watchers and events.
-.IP "pending" 4
-.IX Item "pending"
-A watcher is pending as soon as the corresponding event has been
-detected. See \*(L"\s-1WATCHER STATES\*(R"\s0 for details.
-.IP "real time" 4
-.IX Item "real time"
-The physical time that is observed. It is apparently strictly monotonic :)
-.IP "wall-clock time" 4
-.IX Item "wall-clock time"
-The time and date as shown on clocks. Unlike real time, it can actually
-be wrong and jump forwards and backwards, e.g. when you adjust your
-clock.
-.IP "watcher" 4
-.IX Item "watcher"
-A data structure that describes interest in certain events. Watchers need
-to be started (attached to an event loop) before they can receive events.
-.SH "AUTHOR"
-.IX Header "AUTHOR"
-Marc Lehmann <libev@schmorp.de>, with repeated corrections by Mikael
-Magnusson and Emanuele Giaquinta, and minor corrections by many others.
diff --git a/libev/ev.c b/libev/ev.c
index fe03dac..ec212a1 100644
--- a/libev/ev.c
+++ b/libev/ev.c
@@ -1,7 +1,7 @@
 /*
  * libev event processing core, watcher management
  *
- * Copyright (c) 2007,2008,2009,2010,2011,2012,2013 Marc Alexander Lehmann <libev@schmorp.de>
+ * Copyright (c) 2007-2019 Marc Alexander Lehmann <libev@schmorp.de>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modifica-
@@ -117,6 +117,24 @@
 #  define EV_USE_EPOLL 0
 # endif
    
+# if HAVE_LINUX_AIO_ABI_H
+#  ifndef EV_USE_LINUXAIO
+#   define EV_USE_LINUXAIO 0 /* was: EV_FEATURE_BACKENDS, always off by default */
+#  endif
+# else
+#  undef EV_USE_LINUXAIO
+#  define EV_USE_LINUXAIO 0
+# endif
+   
+# if HAVE_LINUX_FS_H && HAVE_SYS_TIMERFD_H && HAVE_KERNEL_RWF_T
+#  ifndef EV_USE_IOURING
+#   define EV_USE_IOURING EV_FEATURE_BACKENDS
+#  endif
+# else
+#  undef EV_USE_IOURING
+#  define EV_USE_IOURING 0
+# endif
+ 
 # if HAVE_KQUEUE && HAVE_SYS_EVENT_H
 #  ifndef EV_USE_KQUEUE
 #   define EV_USE_KQUEUE EV_FEATURE_BACKENDS
@@ -161,9 +179,28 @@
 #  undef EV_USE_EVENTFD
 #  define EV_USE_EVENTFD 0
 # endif
- 
+
+# if HAVE_SYS_TIMERFD_H
+#  ifndef EV_USE_TIMERFD
+#   define EV_USE_TIMERFD EV_FEATURE_OS
+#  endif
+# else
+#  undef EV_USE_TIMERFD
+#  define EV_USE_TIMERFD 0
+# endif
+
 #endif
 
+/* OS X, in its infinite idiocy, actually HARDCODES
+ * a limit of 1024 into their select. Where people have brains,
+ * OS X engineers apparently have a vacuum. Or maybe they were
+ * ordered to have a vacuum, or they do anything for money.
+ * This might help. Or not.
+ * Note that this must be defined early, as other include files
+ * will rely on this define as well.
+ */
+#define _DARWIN_UNLIMITED_SELECT 1
+
 #include <stdlib.h>
 #include <string.h>
 #include <fcntl.h>
@@ -211,14 +248,6 @@
 # undef EV_AVOID_STDIO
 #endif
 
-/* OS X, in its infinite idiocy, actually HARDCODES
- * a limit of 1024 into their select. Where people have brains,
- * OS X engineers apparently have a vacuum. Or maybe they were
- * ordered to have a vacuum, or they do anything for money.
- * This might help. Or not.
- */
-#define _DARWIN_UNLIMITED_SELECT 1
-
 /* this block tries to deduce configuration from header-defined symbols and defaults */
 
 /* try to deduce the maximum number of signals on this platform */
@@ -315,6 +344,22 @@
 # define EV_USE_PORT 0
 #endif
 
+#ifndef EV_USE_LINUXAIO
+# if __linux /* libev currently assumes linux/aio_abi.h is always available on linux */
+#  define EV_USE_LINUXAIO 0 /* was: 1, always off by default */
+# else
+#  define EV_USE_LINUXAIO 0
+# endif
+#endif
+
+#ifndef EV_USE_IOURING
+# if __linux /* later checks might disable again */
+#  define EV_USE_IOURING 1
+# else
+#  define EV_USE_IOURING 0
+# endif
+#endif
+
 #ifndef EV_USE_INOTIFY
 # if __linux && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 4))
 #  define EV_USE_INOTIFY EV_FEATURE_OS
@@ -347,6 +392,14 @@
 # endif
 #endif
 
+#ifndef EV_USE_TIMERFD
+# if __linux && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 8))
+#  define EV_USE_TIMERFD EV_FEATURE_OS
+# else
+#  define EV_USE_TIMERFD 0
+# endif
+#endif
+
 #if 0 /* debugging */
 # define EV_VERIFY 3
 # define EV_USE_4HEAP 1
@@ -389,6 +442,7 @@
 #  define clock_gettime(id, ts) syscall (SYS_clock_gettime, (id), (ts))
 #  undef EV_USE_MONOTONIC
 #  define EV_USE_MONOTONIC 1
+#  define EV_NEED_SYSCALL 1
 # else
 #  undef EV_USE_CLOCK_SYSCALL
 #  define EV_USE_CLOCK_SYSCALL 0
@@ -412,6 +466,14 @@
 # define EV_USE_INOTIFY 0
 #endif
 
+#if __linux && EV_USE_IOURING
+# include <linux/version.h>
+# if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+#  undef EV_USE_IOURING
+#  define EV_USE_IOURING 0
+# endif
+#endif
+
 #if !EV_USE_NANOSLEEP
 /* hp-ux has it in sys/time.h, which we unconditionally include above */
 # if !defined _WIN32 && !defined __hpux
@@ -419,6 +481,31 @@
 # endif
 #endif
 
+#if EV_USE_LINUXAIO
+# include <sys/syscall.h>
+# if SYS_io_getevents && EV_USE_EPOLL /* linuxaio backend requires epoll backend */
+#  define EV_NEED_SYSCALL 1
+# else
+#  undef EV_USE_LINUXAIO
+#  define EV_USE_LINUXAIO 0
+# endif
+#endif
+
+#if EV_USE_IOURING
+# include <sys/syscall.h>
+# if !SYS_io_uring_setup && __linux && !__alpha
+#  define SYS_io_uring_setup     425
+#  define SYS_io_uring_enter     426
+#  define SYS_io_uring_wregister 427
+# endif
+# if SYS_io_uring_setup && EV_USE_EPOLL /* iouring backend requires epoll backend */
+#  define EV_NEED_SYSCALL 1
+# else
+#  undef EV_USE_IOURING
+#  define EV_USE_IOURING 0
+# endif
+#endif
+
 #if EV_USE_INOTIFY
 # include <sys/statfs.h>
 # include <sys/inotify.h>
@@ -430,7 +517,7 @@
 #endif
 
 #if EV_USE_EVENTFD
-/* our minimum requirement is glibc 2.7 which has the stub, but not the header */
+/* our minimum requirement is glibc 2.7 which has the stub, but not the full header */
 # include <stdint.h>
 # ifndef EFD_NONBLOCK
 #  define EFD_NONBLOCK O_NONBLOCK
@@ -446,7 +533,7 @@ EV_CPP(extern "C") int (eventfd) (unsigned int initval, int flags);
 #endif
 
 #if EV_USE_SIGNALFD
-/* our minimum requirement is glibc 2.7 which has the stub, but not the header */
+/* our minimum requirement is glibc 2.7 which has the stub, but not the full header */
 # include <stdint.h>
 # ifndef SFD_NONBLOCK
 #  define SFD_NONBLOCK O_NONBLOCK
@@ -458,7 +545,7 @@ EV_CPP(extern "C") int (eventfd) (unsigned int initval, int flags);
 #   define SFD_CLOEXEC 02000000
 #  endif
 # endif
-EV_CPP (extern "C") int signalfd (int fd, const sigset_t *mask, int flags);
+EV_CPP (extern "C") int (signalfd) (int fd, const sigset_t *mask, int flags);
 
 struct signalfd_siginfo
 {
@@ -467,7 +554,17 @@ struct signalfd_siginfo
 };
 #endif
 
-/**/
+/* for timerfd, libev core requires TFD_TIMER_CANCEL_ON_SET &c */
+#if EV_USE_TIMERFD
+# include <sys/timerfd.h>
+/* timerfd is only used for periodics */
+# if !(defined (TFD_TIMER_CANCEL_ON_SET) && defined (TFD_CLOEXEC) && defined (TFD_NONBLOCK)) || !EV_PERIODIC_ENABLE
+#  undef EV_USE_TIMERFD
+#  define EV_USE_TIMERFD 0
+# endif
+#endif
+
+/*****************************************************************************/
 
 #if EV_VERIFY >= 3
 # define EV_FREQUENT_CHECK ev_verify (EV_A)
@@ -482,18 +579,34 @@ struct signalfd_siginfo
 #define MIN_INTERVAL  0.0001220703125 /* 1/2**13, good till 4000 */
 /*#define MIN_INTERVAL  0.00000095367431640625 /* 1/2**20, good till 2200 */
 
-#define MIN_TIMEJUMP  1. /* minimum timejump that gets detected (if monotonic clock available) */
-#define MAX_BLOCKTIME 59.743 /* never wait longer than this time (to detect time jumps) */
+#define MIN_TIMEJUMP   1. /* minimum timejump that gets detected (if monotonic clock available) */
+#define MAX_BLOCKTIME  59.743 /* never wait longer than this time (to detect time jumps) */
+#define MAX_BLOCKTIME2 1500001.07 /* same, but when timerfd is used to detect jumps, also safe delay to not overflow */
 
-#define EV_TV_SET(tv,t) do { tv.tv_sec = (long)t; tv.tv_usec = (long)((t - tv.tv_sec) * 1e6); } while (0)
-#define EV_TS_SET(ts,t) do { ts.tv_sec = (long)t; ts.tv_nsec = (long)((t - ts.tv_sec) * 1e9); } while (0)
+/* find a portable timestamp that is "always" in the future but fits into time_t.
+ * this is quite hard, and we are mostly guessing - we handle 32 bit signed/unsigned time_t,
+ * and sizes larger than 32 bit, and maybe the unlikely floating point time_t */
+#define EV_TSTAMP_HUGE \
+  (sizeof (time_t) >= 8     ? 10000000000000.  \
+   : 0 < (time_t)4294967295 ?     4294967295.  \
+   :                              2147483647.) \
+
+#ifndef EV_TS_CONST
+# define EV_TS_CONST(nv) nv
+# define EV_TS_TO_MSEC(a) a * 1e3 + 0.9999
+# define EV_TS_FROM_USEC(us) us * 1e-6
+# define EV_TV_SET(tv,t) do { tv.tv_sec = (long)t; tv.tv_usec = (long)((t - tv.tv_sec) * 1e6); } while (0)
+# define EV_TS_SET(ts,t) do { ts.tv_sec = (long)t; ts.tv_nsec = (long)((t - ts.tv_sec) * 1e9); } while (0)
+# define EV_TV_GET(tv) ((tv).tv_sec + (tv).tv_usec * 1e-6)
+# define EV_TS_GET(ts) ((ts).tv_sec + (ts).tv_nsec * 1e-9)
+#endif
 
 /* the following is ecb.h embedded into libev - use update_ev_c to update from an external copy */
 /* ECB.H BEGIN */
 /*
  * libecb - http://software.schmorp.de/pkg/libecb
  *
- * Copyright (©) 2009-2015 Marc Alexander Lehmann <libecb@schmorp.de>
+ * Copyright (©) 2009-2015,2018-2020 Marc Alexander Lehmann <libecb@schmorp.de>
  * Copyright (©) 2011 Emanuele Giaquinta
  * All rights reserved.
  *
@@ -534,15 +647,23 @@ struct signalfd_siginfo
 #define ECB_H
 
 /* 16 bits major, 16 bits minor */
-#define ECB_VERSION 0x00010005
+#define ECB_VERSION 0x00010008
 
-#ifdef _WIN32
+#include <string.h> /* for memcpy */
+
+#if defined (_WIN32) && !defined (__MINGW32__)
   typedef   signed char   int8_t;
   typedef unsigned char  uint8_t;
+  typedef   signed char   int_fast8_t;
+  typedef unsigned char  uint_fast8_t;
   typedef   signed short  int16_t;
   typedef unsigned short uint16_t;
+  typedef   signed int    int_fast16_t;
+  typedef unsigned int   uint_fast16_t;
   typedef   signed int    int32_t;
   typedef unsigned int   uint32_t;
+  typedef   signed int    int_fast32_t;
+  typedef unsigned int   uint_fast32_t;
   #if __GNUC__
     typedef   signed long long int64_t;
     typedef unsigned long long uint64_t;
@@ -550,6 +671,8 @@ struct signalfd_siginfo
     typedef   signed __int64   int64_t;
     typedef unsigned __int64   uint64_t;
   #endif
+  typedef  int64_t  int_fast64_t;
+  typedef uint64_t uint_fast64_t;
   #ifdef _WIN64
     #define ECB_PTRSIZE 8
     typedef uint64_t uintptr_t;
@@ -571,6 +694,14 @@ struct signalfd_siginfo
 #define ECB_GCC_AMD64 (__amd64 || __amd64__ || __x86_64 || __x86_64__)
 #define ECB_MSVC_AMD64 (_M_AMD64 || _M_X64)
 
+#ifndef ECB_OPTIMIZE_SIZE
+  #if __OPTIMIZE_SIZE__
+    #define ECB_OPTIMIZE_SIZE 1
+  #else
+    #define ECB_OPTIMIZE_SIZE 0
+  #endif
+#endif
+
 /* work around x32 idiocy by defining proper macros */
 #if ECB_GCC_AMD64 || ECB_MSVC_AMD64
   #if _ILP32
@@ -609,6 +740,8 @@ struct signalfd_siginfo
 
 #define ECB_CPP   (__cplusplus+0)
 #define ECB_CPP11 (__cplusplus >= 201103L)
+#define ECB_CPP14 (__cplusplus >= 201402L)
+#define ECB_CPP17 (__cplusplus >= 201703L)
 
 #if ECB_CPP
   #define ECB_C            0
@@ -620,6 +753,7 @@ struct signalfd_siginfo
 
 #define ECB_C99   (ECB_STDC_VERSION >= 199901L)
 #define ECB_C11   (ECB_STDC_VERSION >= 201112L)
+#define ECB_C17   (ECB_STDC_VERSION >= 201710L)
 
 #if ECB_CPP
   #define ECB_EXTERN_C extern "C"
@@ -655,14 +789,15 @@ struct signalfd_siginfo
 
 #ifndef ECB_MEMORY_FENCE
   #if ECB_GCC_VERSION(2,5) || defined __INTEL_COMPILER || (__llvm__ && __GNUC__) || __SUNPRO_C >= 0x5110 || __SUNPRO_CC >= 0x5110
+    #define ECB_MEMORY_FENCE_RELAXED __asm__ __volatile__ ("" : : : "memory")
     #if __i386 || __i386__
       #define ECB_MEMORY_FENCE         __asm__ __volatile__ ("lock; orb $0, -1(%%esp)" : : : "memory")
       #define ECB_MEMORY_FENCE_ACQUIRE __asm__ __volatile__ (""                        : : : "memory")
-      #define ECB_MEMORY_FENCE_RELEASE __asm__ __volatile__ ("")
+      #define ECB_MEMORY_FENCE_RELEASE __asm__ __volatile__ (""                        : : : "memory")
     #elif ECB_GCC_AMD64
       #define ECB_MEMORY_FENCE         __asm__ __volatile__ ("mfence"   : : : "memory")
       #define ECB_MEMORY_FENCE_ACQUIRE __asm__ __volatile__ (""         : : : "memory")
-      #define ECB_MEMORY_FENCE_RELEASE __asm__ __volatile__ ("")
+      #define ECB_MEMORY_FENCE_RELEASE __asm__ __volatile__ (""         : : : "memory")
     #elif __powerpc__ || __ppc__ || __powerpc64__ || __ppc64__
       #define ECB_MEMORY_FENCE         __asm__ __volatile__ ("sync"     : : : "memory")
     #elif defined __ARM_ARCH_2__ \
@@ -714,12 +849,14 @@ struct signalfd_siginfo
     #define ECB_MEMORY_FENCE         __atomic_thread_fence (__ATOMIC_SEQ_CST)
     #define ECB_MEMORY_FENCE_ACQUIRE __atomic_thread_fence (__ATOMIC_ACQUIRE)
     #define ECB_MEMORY_FENCE_RELEASE __atomic_thread_fence (__ATOMIC_RELEASE)
+    #define ECB_MEMORY_FENCE_RELAXED __atomic_thread_fence (__ATOMIC_RELAXED)
 
   #elif ECB_CLANG_EXTENSION(c_atomic)
     /* see comment below (stdatomic.h) about the C11 memory model. */
     #define ECB_MEMORY_FENCE         __c11_atomic_thread_fence (__ATOMIC_SEQ_CST)
     #define ECB_MEMORY_FENCE_ACQUIRE __c11_atomic_thread_fence (__ATOMIC_ACQUIRE)
     #define ECB_MEMORY_FENCE_RELEASE __c11_atomic_thread_fence (__ATOMIC_RELEASE)
+    #define ECB_MEMORY_FENCE_RELAXED __c11_atomic_thread_fence (__ATOMIC_RELAXED)
 
   #elif ECB_GCC_VERSION(4,4) || defined __INTEL_COMPILER || defined __clang__
     #define ECB_MEMORY_FENCE         __sync_synchronize ()
@@ -739,9 +876,10 @@ struct signalfd_siginfo
     #define ECB_MEMORY_FENCE         MemoryBarrier () /* actually just xchg on x86... scary */
   #elif __SUNPRO_C >= 0x5110 || __SUNPRO_CC >= 0x5110
     #include <mbarrier.h>
-    #define ECB_MEMORY_FENCE         __machine_rw_barrier ()
-    #define ECB_MEMORY_FENCE_ACQUIRE __machine_r_barrier  ()
-    #define ECB_MEMORY_FENCE_RELEASE __machine_w_barrier  ()
+    #define ECB_MEMORY_FENCE         __machine_rw_barrier  ()
+    #define ECB_MEMORY_FENCE_ACQUIRE __machine_acq_barrier ()
+    #define ECB_MEMORY_FENCE_RELEASE __machine_rel_barrier ()
+    #define ECB_MEMORY_FENCE_RELAXED __compiler_barrier ()
   #elif __xlC__
     #define ECB_MEMORY_FENCE         __sync ()
   #endif
@@ -752,15 +890,9 @@ struct signalfd_siginfo
     /* we assume that these memory fences work on all variables/all memory accesses, */
     /* not just C11 atomics and atomic accesses */
     #include <stdatomic.h>
-    /* Unfortunately, neither gcc 4.7 nor clang 3.1 generate any instructions for */
-    /* any fence other than seq_cst, which isn't very efficient for us. */
-    /* Why that is, we don't know - either the C11 memory model is quite useless */
-    /* for most usages, or gcc and clang have a bug */
-    /* I *currently* lean towards the latter, and inefficiently implement */
-    /* all three of ecb's fences as a seq_cst fence */
-    /* Update, gcc-4.8 generates mfence for all c++ fences, but nothing */
-    /* for all __atomic_thread_fence's except seq_cst */
     #define ECB_MEMORY_FENCE         atomic_thread_fence (memory_order_seq_cst)
+    #define ECB_MEMORY_FENCE_ACQUIRE atomic_thread_fence (memory_order_acquire)
+    #define ECB_MEMORY_FENCE_RELEASE atomic_thread_fence (memory_order_release)
   #endif
 #endif
 
@@ -790,6 +922,10 @@ struct signalfd_siginfo
   #define ECB_MEMORY_FENCE_RELEASE ECB_MEMORY_FENCE
 #endif
 
+#if !defined ECB_MEMORY_FENCE_RELAXED && defined ECB_MEMORY_FENCE
+  #define ECB_MEMORY_FENCE_RELAXED ECB_MEMORY_FENCE /* very heavy-handed */
+#endif
+
 /*****************************************************************************/
 
 #if ECB_CPP
@@ -1081,6 +1217,44 @@ ecb_inline ecb_const uint32_t ecb_rotr32 (uint32_t x, unsigned int count) { retu
 ecb_inline ecb_const uint64_t ecb_rotl64 (uint64_t x, unsigned int count) { return (x >> (64 - count)) | (x << count); }
 ecb_inline ecb_const uint64_t ecb_rotr64 (uint64_t x, unsigned int count) { return (x << (64 - count)) | (x >> count); }
 
+#if ECB_CPP
+
+inline uint8_t  ecb_ctz (uint8_t  v) { return ecb_ctz32 (v); }
+inline uint16_t ecb_ctz (uint16_t v) { return ecb_ctz32 (v); }
+inline uint32_t ecb_ctz (uint32_t v) { return ecb_ctz32 (v); }
+inline uint64_t ecb_ctz (uint64_t v) { return ecb_ctz64 (v); }
+
+inline bool ecb_is_pot (uint8_t  v) { return ecb_is_pot32 (v); }
+inline bool ecb_is_pot (uint16_t v) { return ecb_is_pot32 (v); }
+inline bool ecb_is_pot (uint32_t v) { return ecb_is_pot32 (v); }
+inline bool ecb_is_pot (uint64_t v) { return ecb_is_pot64 (v); }
+
+inline int ecb_ld (uint8_t  v) { return ecb_ld32 (v); }
+inline int ecb_ld (uint16_t v) { return ecb_ld32 (v); }
+inline int ecb_ld (uint32_t v) { return ecb_ld32 (v); }
+inline int ecb_ld (uint64_t v) { return ecb_ld64 (v); }
+
+inline int ecb_popcount (uint8_t  v) { return ecb_popcount32 (v); }
+inline int ecb_popcount (uint16_t v) { return ecb_popcount32 (v); }
+inline int ecb_popcount (uint32_t v) { return ecb_popcount32 (v); }
+inline int ecb_popcount (uint64_t v) { return ecb_popcount64 (v); }
+
+inline uint8_t  ecb_bitrev (uint8_t  v) { return ecb_bitrev8  (v); }
+inline uint16_t ecb_bitrev (uint16_t v) { return ecb_bitrev16 (v); }
+inline uint32_t ecb_bitrev (uint32_t v) { return ecb_bitrev32 (v); }
+
+inline uint8_t  ecb_rotl (uint8_t  v, unsigned int count) { return ecb_rotl8  (v, count); }
+inline uint16_t ecb_rotl (uint16_t v, unsigned int count) { return ecb_rotl16 (v, count); }
+inline uint32_t ecb_rotl (uint32_t v, unsigned int count) { return ecb_rotl32 (v, count); }
+inline uint64_t ecb_rotl (uint64_t v, unsigned int count) { return ecb_rotl64 (v, count); }
+
+inline uint8_t  ecb_rotr (uint8_t  v, unsigned int count) { return ecb_rotr8  (v, count); }
+inline uint16_t ecb_rotr (uint16_t v, unsigned int count) { return ecb_rotr16 (v, count); }
+inline uint32_t ecb_rotr (uint32_t v, unsigned int count) { return ecb_rotr32 (v, count); }
+inline uint64_t ecb_rotr (uint64_t v, unsigned int count) { return ecb_rotr64 (v, count); }
+
+#endif
+
 #if ECB_GCC_VERSION(4,3) || (ECB_CLANG_BUILTIN(__builtin_bswap32) && ECB_CLANG_BUILTIN(__builtin_bswap64))
   #if ECB_GCC_VERSION(4,8) || ECB_CLANG_BUILTIN(__builtin_bswap16)
   #define ecb_bswap16(x)  __builtin_bswap16 (x)
@@ -1161,6 +1335,78 @@ ecb_inline ecb_const ecb_bool ecb_big_endian    (void) { return ecb_byteorder_he
 ecb_inline ecb_const ecb_bool ecb_little_endian (void);
 ecb_inline ecb_const ecb_bool ecb_little_endian (void) { return ecb_byteorder_helper () == 0x44332211; }
 
+/*****************************************************************************/
+/* unaligned load/store */
+
+ecb_inline uint_fast16_t ecb_be_u16_to_host (uint_fast16_t v) { return ecb_little_endian () ? ecb_bswap16 (v) : v; }
+ecb_inline uint_fast32_t ecb_be_u32_to_host (uint_fast32_t v) { return ecb_little_endian () ? ecb_bswap32 (v) : v; }
+ecb_inline uint_fast64_t ecb_be_u64_to_host (uint_fast64_t v) { return ecb_little_endian () ? ecb_bswap64 (v) : v; }
+
+ecb_inline uint_fast16_t ecb_le_u16_to_host (uint_fast16_t v) { return ecb_big_endian    () ? ecb_bswap16 (v) : v; }
+ecb_inline uint_fast32_t ecb_le_u32_to_host (uint_fast32_t v) { return ecb_big_endian    () ? ecb_bswap32 (v) : v; }
+ecb_inline uint_fast64_t ecb_le_u64_to_host (uint_fast64_t v) { return ecb_big_endian    () ? ecb_bswap64 (v) : v; }
+
+ecb_inline uint_fast16_t ecb_peek_u16_u (const void *ptr) { uint16_t v; memcpy (&v, ptr, sizeof (v)); return v; }
+ecb_inline uint_fast32_t ecb_peek_u32_u (const void *ptr) { uint32_t v; memcpy (&v, ptr, sizeof (v)); return v; }
+ecb_inline uint_fast64_t ecb_peek_u64_u (const void *ptr) { uint64_t v; memcpy (&v, ptr, sizeof (v)); return v; }
+
+ecb_inline uint_fast16_t ecb_peek_be_u16_u (const void *ptr) { return ecb_be_u16_to_host (ecb_peek_u16_u (ptr)); }
+ecb_inline uint_fast32_t ecb_peek_be_u32_u (const void *ptr) { return ecb_be_u32_to_host (ecb_peek_u32_u (ptr)); }
+ecb_inline uint_fast64_t ecb_peek_be_u64_u (const void *ptr) { return ecb_be_u64_to_host (ecb_peek_u64_u (ptr)); }
+
+ecb_inline uint_fast16_t ecb_peek_le_u16_u (const void *ptr) { return ecb_le_u16_to_host (ecb_peek_u16_u (ptr)); }
+ecb_inline uint_fast32_t ecb_peek_le_u32_u (const void *ptr) { return ecb_le_u32_to_host (ecb_peek_u32_u (ptr)); }
+ecb_inline uint_fast64_t ecb_peek_le_u64_u (const void *ptr) { return ecb_le_u64_to_host (ecb_peek_u64_u (ptr)); }
+
+ecb_inline uint_fast16_t ecb_host_to_be_u16 (uint_fast16_t v) { return ecb_little_endian () ? ecb_bswap16 (v) : v; }
+ecb_inline uint_fast32_t ecb_host_to_be_u32 (uint_fast32_t v) { return ecb_little_endian () ? ecb_bswap32 (v) : v; }
+ecb_inline uint_fast64_t ecb_host_to_be_u64 (uint_fast64_t v) { return ecb_little_endian () ? ecb_bswap64 (v) : v; }
+
+ecb_inline uint_fast16_t ecb_host_to_le_u16 (uint_fast16_t v) { return ecb_big_endian    () ? ecb_bswap16 (v) : v; }
+ecb_inline uint_fast32_t ecb_host_to_le_u32 (uint_fast32_t v) { return ecb_big_endian    () ? ecb_bswap32 (v) : v; }
+ecb_inline uint_fast64_t ecb_host_to_le_u64 (uint_fast64_t v) { return ecb_big_endian    () ? ecb_bswap64 (v) : v; }
+
+ecb_inline void ecb_poke_u16_u (void *ptr, uint16_t v) { memcpy (ptr, &v, sizeof (v)); }
+ecb_inline void ecb_poke_u32_u (void *ptr, uint32_t v) { memcpy (ptr, &v, sizeof (v)); }
+ecb_inline void ecb_poke_u64_u (void *ptr, uint64_t v) { memcpy (ptr, &v, sizeof (v)); }
+
+ecb_inline void ecb_poke_be_u16_u (void *ptr, uint_fast16_t v) { ecb_poke_u16_u (ptr, ecb_host_to_be_u16 (v)); }
+ecb_inline void ecb_poke_be_u32_u (void *ptr, uint_fast32_t v) { ecb_poke_u32_u (ptr, ecb_host_to_be_u32 (v)); }
+ecb_inline void ecb_poke_be_u64_u (void *ptr, uint_fast64_t v) { ecb_poke_u64_u (ptr, ecb_host_to_be_u64 (v)); }
+                                                                                                
+ecb_inline void ecb_poke_le_u16_u (void *ptr, uint_fast16_t v) { ecb_poke_u16_u (ptr, ecb_host_to_le_u16 (v)); }
+ecb_inline void ecb_poke_le_u32_u (void *ptr, uint_fast32_t v) { ecb_poke_u32_u (ptr, ecb_host_to_le_u32 (v)); }
+ecb_inline void ecb_poke_le_u64_u (void *ptr, uint_fast64_t v) { ecb_poke_u64_u (ptr, ecb_host_to_le_u64 (v)); }
+
+#if ECB_CPP
+
+inline uint8_t  ecb_bswap (uint8_t  v) { return v; }
+inline uint16_t ecb_bswap (uint16_t v) { return ecb_bswap16 (v); }
+inline uint32_t ecb_bswap (uint32_t v) { return ecb_bswap32 (v); }
+inline uint64_t ecb_bswap (uint64_t v) { return ecb_bswap64 (v); }
+
+template<typename T> inline T ecb_be_to_host (T v) { return ecb_little_endian () ? ecb_bswap (v) : v; }
+template<typename T> inline T ecb_le_to_host (T v) { return ecb_big_endian    () ? ecb_bswap (v) : v; }
+template<typename T> inline T ecb_peek       (const void *ptr) { return *(const T *)ptr; }
+template<typename T> inline T ecb_peek_be    (const void *ptr) { return ecb_be_to_host (ecb_peek  <T> (ptr)); }
+template<typename T> inline T ecb_peek_le    (const void *ptr) { return ecb_le_to_host (ecb_peek  <T> (ptr)); }
+template<typename T> inline T ecb_peek_u     (const void *ptr) { T v; memcpy (&v, ptr, sizeof (v)); return v; }
+template<typename T> inline T ecb_peek_be_u  (const void *ptr) { return ecb_be_to_host (ecb_peek_u<T> (ptr)); }
+template<typename T> inline T ecb_peek_le_u  (const void *ptr) { return ecb_le_to_host (ecb_peek_u<T> (ptr)); }
+
+template<typename T> inline T ecb_host_to_be (T v) { return ecb_little_endian () ? ecb_bswap (v) : v; }
+template<typename T> inline T ecb_host_to_le (T v) { return ecb_big_endian    () ? ecb_bswap (v) : v; }
+template<typename T> inline void ecb_poke      (void *ptr, T v) { *(T *)ptr = v; }
+template<typename T> inline void ecb_poke_be   (void *ptr, T v) { return ecb_poke  <T> (ptr, ecb_host_to_be (v)); }
+template<typename T> inline void ecb_poke_le   (void *ptr, T v) { return ecb_poke  <T> (ptr, ecb_host_to_le (v)); }
+template<typename T> inline void ecb_poke_u    (void *ptr, T v) { memcpy (ptr, &v, sizeof (v)); }
+template<typename T> inline void ecb_poke_be_u (void *ptr, T v) { return ecb_poke_u<T> (ptr, ecb_host_to_be (v)); }
+template<typename T> inline void ecb_poke_le_u (void *ptr, T v) { return ecb_poke_u<T> (ptr, ecb_host_to_le (v)); }
+
+#endif
+
+/*****************************************************************************/
+
 #if ECB_GCC_VERSION(3,0) || ECB_C99
   #define ecb_mod(m,n) ((m) % (n) + ((m) % (n) < 0 ? (n) : 0))
 #else
@@ -1194,6 +1440,8 @@ ecb_inline ecb_const ecb_bool ecb_little_endian (void) { return ecb_byteorder_he
   #define ecb_array_length(name) (sizeof (name) / sizeof (name [0]))
 #endif
 
+/*****************************************************************************/
+
 ecb_function_ ecb_const uint32_t ecb_binary16_to_binary32 (uint32_t x);
 ecb_function_ ecb_const uint32_t
 ecb_binary16_to_binary32 (uint32_t x)
@@ -1311,7 +1559,6 @@ ecb_binary32_to_binary16 (uint32_t x)
     || (defined __arm__ && (defined __ARM_EABI__ || defined __EABI__ || defined __VFP_FP__ || defined _WIN32_WCE || defined __ANDROID__)) \
     || defined __aarch64__
   #define ECB_STDFP 1
-  #include <string.h> /* for memcpy */
 #else
   #define ECB_STDFP 0
 #endif
@@ -1506,7 +1753,7 @@ ecb_binary32_to_binary16 (uint32_t x)
 #if ECB_MEMORY_FENCE_NEEDS_PTHREADS
 /* if your architecture doesn't need memory fences, e.g. because it is
  * single-cpu/core, or if you use libev in a project that doesn't use libev
- * from multiple threads, then you can define ECB_AVOID_PTHREADS when compiling
+ * from multiple threads, then you can define ECB_NO_THREADS when compiling
  * libev, in which cases the memory fences become nops.
  * alternatively, you can remove this #error and link against libpthread,
  * which will then provide the memory fences.
@@ -1520,18 +1767,80 @@ ecb_binary32_to_binary16 (uint32_t x)
 # define ECB_MEMORY_FENCE_RELEASE ECB_MEMORY_FENCE
 #endif
 
-#define expect_false(cond) ecb_expect_false (cond)
-#define expect_true(cond)  ecb_expect_true  (cond)
-#define noinline           ecb_noinline
-
 #define inline_size        ecb_inline
 
 #if EV_FEATURE_CODE
 # define inline_speed      ecb_inline
 #else
-# define inline_speed      noinline static
+# define inline_speed      ecb_noinline static
+#endif
+
+/*****************************************************************************/
+/* raw syscall wrappers */
+
+#if EV_NEED_SYSCALL
+
+#include <sys/syscall.h>
+
+/*
+ * define some syscall wrappers for common architectures
+ * this is mostly for nice looks during debugging, not performance.
+ * our syscalls return < 0, not == -1, on error. which is good
+ * enough for linux aio.
+ * TODO: arm is also common nowadays, maybe even mips and x86
+ * TODO: after implementing this, it suddenly looks like overkill, but its hard to remove...
+ */
+#if __GNUC__ && __linux && ECB_AMD64 && !EV_FEATURE_CODE
+  /* the costly errno access probably kills this for size optimisation */
+
+  #define ev_syscall(nr,narg,arg1,arg2,arg3,arg4,arg5,arg6)            \
+    ({                                                                 \
+        long res;                                                      \
+        register unsigned long r6 __asm__ ("r9" );                     \
+        register unsigned long r5 __asm__ ("r8" );                     \
+        register unsigned long r4 __asm__ ("r10");                     \
+        register unsigned long r3 __asm__ ("rdx");                     \
+        register unsigned long r2 __asm__ ("rsi");                     \
+        register unsigned long r1 __asm__ ("rdi");                     \
+        if (narg >= 6) r6 = (unsigned long)(arg6);                     \
+        if (narg >= 5) r5 = (unsigned long)(arg5);                     \
+        if (narg >= 4) r4 = (unsigned long)(arg4);                     \
+        if (narg >= 3) r3 = (unsigned long)(arg3);                     \
+        if (narg >= 2) r2 = (unsigned long)(arg2);                     \
+        if (narg >= 1) r1 = (unsigned long)(arg1);                     \
+        __asm__ __volatile__ (                                         \
+          "syscall\n\t"                                                \
+          : "=a" (res)                                                 \
+          : "0" (nr), "r" (r1), "r" (r2), "r" (r3), "r" (r4), "r" (r5) \
+          : "cc", "r11", "cx", "memory");                              \
+        errno = -res;                                                  \
+        res;                                                           \
+    })
+
+#endif
+
+#ifdef ev_syscall
+  #define ev_syscall0(nr)                               ev_syscall (nr, 0,    0,    0,    0,    0,    0,   0)
+  #define ev_syscall1(nr,arg1)                          ev_syscall (nr, 1, arg1,    0,    0,    0,    0,   0)
+  #define ev_syscall2(nr,arg1,arg2)                     ev_syscall (nr, 2, arg1, arg2,    0,    0,    0,   0)
+  #define ev_syscall3(nr,arg1,arg2,arg3)                ev_syscall (nr, 3, arg1, arg2, arg3,    0,    0,   0)
+  #define ev_syscall4(nr,arg1,arg2,arg3,arg4)           ev_syscall (nr, 3, arg1, arg2, arg3, arg4,    0,   0)
+  #define ev_syscall5(nr,arg1,arg2,arg3,arg4,arg5)      ev_syscall (nr, 5, arg1, arg2, arg3, arg4, arg5,   0)
+  #define ev_syscall6(nr,arg1,arg2,arg3,arg4,arg5,arg6) ev_syscall (nr, 6, arg1, arg2, arg3, arg4, arg5,arg6)
+#else
+  #define ev_syscall0(nr)                               syscall (nr)
+  #define ev_syscall1(nr,arg1)                          syscall (nr, arg1)
+  #define ev_syscall2(nr,arg1,arg2)                     syscall (nr, arg1, arg2)
+  #define ev_syscall3(nr,arg1,arg2,arg3)                syscall (nr, arg1, arg2, arg3)
+  #define ev_syscall4(nr,arg1,arg2,arg3,arg4)           syscall (nr, arg1, arg2, arg3, arg4)
+  #define ev_syscall5(nr,arg1,arg2,arg3,arg4,arg5)      syscall (nr, arg1, arg2, arg3, arg4, arg5)
+  #define ev_syscall6(nr,arg1,arg2,arg3,arg4,arg5,arg6) syscall (nr, arg1, arg2, arg3, arg4, arg5,arg6)
 #endif
 
+#endif
+
+/*****************************************************************************/
+
 #define NUMPRI (EV_MAXPRI - EV_MINPRI + 1)
 
 #if EV_MINPRI == EV_MAXPRI
@@ -1540,8 +1849,7 @@ ecb_binary32_to_binary16 (uint32_t x)
 # define ABSPRI(w) (((W)w)->priority - EV_MINPRI)
 #endif
 
-#define EMPTY       /* required for microsofts broken pseudo-c compiler */
-#define EMPTY2(a,b) /* used to suppress some warnings */
+#define EMPTY /* required for microsofts broken pseudo-c compiler */
 
 typedef ev_watcher *W;
 typedef ev_watcher_list *WL;
@@ -1576,6 +1884,10 @@ static EV_ATOMIC_T have_monotonic; /* did clock_gettime (CLOCK_MONOTONIC) work?
 
 /*****************************************************************************/
 
+#if EV_USE_LINUXAIO
+# include <linux/aio_abi.h> /* probably only needed for aio_context_t */
+#endif
+
 /* define a suitable floor function (only used by periodics atm) */
 
 #if EV_USE_FLOOR
@@ -1586,7 +1898,7 @@ static EV_ATOMIC_T have_monotonic; /* did clock_gettime (CLOCK_MONOTONIC) work?
 #include <float.h>
 
 /* a floor() replacement function, should be independent of ev_tstamp type */
-noinline
+ecb_noinline
 static ev_tstamp
 ev_floor (ev_tstamp v)
 {
@@ -1597,26 +1909,26 @@ ev_floor (ev_tstamp v)
   const ev_tstamp shift = sizeof (unsigned long) >= 8 ? 18446744073709551616. : 4294967296.;
 #endif
 
-  /* argument too large for an unsigned long? */
-  if (expect_false (v >= shift))
+  /* special treatment for negative arguments */
+  if (ecb_expect_false (v < 0.))
+    {
+      ev_tstamp f = -ev_floor (-v);
+
+      return f - (f == v ? 0 : 1);
+    }
+
+  /* argument too large for an unsigned long? then reduce it */
+  if (ecb_expect_false (v >= shift))
     {
       ev_tstamp f;
 
       if (v == v - 1.)
-        return v; /* very large number */
+        return v; /* very large numbers are assumed to be integer */
 
       f = shift * ev_floor (v * (1. / shift));
       return f + ev_floor (v - f);
     }
 
-  /* special treatment for negative args? */
-  if (expect_false (v < 0.))
-    {
-      ev_tstamp f = -ev_floor (-v);
-
-      return f - (f == v ? 0 : 1);
-    }
-
   /* fits into an unsigned long */
   return (unsigned long)v;
 }
@@ -1629,7 +1941,7 @@ ev_floor (ev_tstamp v)
 # include <sys/utsname.h>
 #endif
 
-noinline ecb_cold
+ecb_noinline ecb_cold
 static unsigned int
 ev_linux_version (void)
 {
@@ -1669,7 +1981,7 @@ ev_linux_version (void)
 /*****************************************************************************/
 
 #if EV_AVOID_STDIO
-noinline ecb_cold
+ecb_noinline ecb_cold
 static void
 ev_printerr (const char *msg)
 {
@@ -1677,16 +1989,16 @@ ev_printerr (const char *msg)
 }
 #endif
 
-static void (*syserr_cb)(const char *msg) EV_THROW;
+static void (*syserr_cb)(const char *msg) EV_NOEXCEPT;
 
 ecb_cold
 void
-ev_set_syserr_cb (void (*cb)(const char *msg) EV_THROW) EV_THROW
+ev_set_syserr_cb (void (*cb)(const char *msg) EV_NOEXCEPT) EV_NOEXCEPT
 {
   syserr_cb = cb;
 }
 
-noinline ecb_cold
+ecb_noinline ecb_cold
 static void
 ev_syserr (const char *msg)
 {
@@ -1710,7 +2022,7 @@ ev_syserr (const char *msg)
 }
 
 static void *
-ev_realloc_emul (void *ptr, long size) EV_THROW
+ev_realloc_emul (void *ptr, long size) EV_NOEXCEPT
 {
   /* some systems, notably openbsd and darwin, fail to properly
    * implement realloc (x, 0) (as required by both ansi c-89 and
@@ -1726,11 +2038,11 @@ ev_realloc_emul (void *ptr, long size) EV_THROW
   return 0;
 }
 
-static void *(*alloc)(void *ptr, long size) EV_THROW = ev_realloc_emul;
+static void *(*alloc)(void *ptr, long size) EV_NOEXCEPT = ev_realloc_emul;
 
 ecb_cold
 void
-ev_set_allocator (void *(*cb)(void *ptr, long size) EV_THROW) EV_THROW
+ev_set_allocator (void *(*cb)(void *ptr, long size) EV_NOEXCEPT) EV_NOEXCEPT
 {
   alloc = cb;
 }
@@ -1767,8 +2079,8 @@ typedef struct
   WL head;
   unsigned char events; /* the events watched for */
   unsigned char reify;  /* flag set when this ANFD needs reification (EV_ANFD_REIFY, EV__IOFDSET) */
-  unsigned char emask;  /* the epoll backend stores the actual kernel mask in here */
-  unsigned char unused;
+  unsigned char emask;  /* some backends store the actual kernel mask in here */
+  unsigned char eflags; /* flags field for use by backends */
 #if EV_USE_EPOLL
   unsigned int egen;    /* generation counter to counter epoll bugs */
 #endif
@@ -1832,7 +2144,7 @@ typedef struct
 
 #else
 
-  EV_API_DECL ev_tstamp ev_rt_now = 0; /* needs to be initialised to make it a definition despite extern */
+  EV_API_DECL ev_tstamp ev_rt_now = EV_TS_CONST (0.); /* needs to be initialised to make it a definition despite extern */
   #define VAR(name,decl) static decl;
     #include "ev_vars.h"
   #undef VAR
@@ -1842,8 +2154,8 @@ typedef struct
 #endif
 
 #if EV_FEATURE_API
-# define EV_RELEASE_CB if (expect_false (release_cb)) release_cb (EV_A)
-# define EV_ACQUIRE_CB if (expect_false (acquire_cb)) acquire_cb (EV_A)
+# define EV_RELEASE_CB if (ecb_expect_false (release_cb)) release_cb (EV_A)
+# define EV_ACQUIRE_CB if (ecb_expect_false (acquire_cb)) acquire_cb (EV_A)
 # define EV_INVOKE_PENDING invoke_cb (EV_A)
 #else
 # define EV_RELEASE_CB (void)0
@@ -1857,20 +2169,22 @@ typedef struct
 
 #ifndef EV_HAVE_EV_TIME
 ev_tstamp
-ev_time (void) EV_THROW
+ev_time (void) EV_NOEXCEPT
 {
 #if EV_USE_REALTIME
-  if (expect_true (have_realtime))
+  if (ecb_expect_true (have_realtime))
     {
       struct timespec ts;
       clock_gettime (CLOCK_REALTIME, &ts);
-      return ts.tv_sec + ts.tv_nsec * 1e-9;
+      return EV_TS_GET (ts);
     }
 #endif
 
-  struct timeval tv;
-  gettimeofday (&tv, 0);
-  return tv.tv_sec + tv.tv_usec * 1e-6;
+  {
+    struct timeval tv;
+    gettimeofday (&tv, 0);
+    return EV_TV_GET (tv);
+  }
 }
 #endif
 
@@ -1878,11 +2192,11 @@ inline_size ev_tstamp
 get_clock (void)
 {
 #if EV_USE_MONOTONIC
-  if (expect_true (have_monotonic))
+  if (ecb_expect_true (have_monotonic))
     {
       struct timespec ts;
       clock_gettime (CLOCK_MONOTONIC, &ts);
-      return ts.tv_sec + ts.tv_nsec * 1e-9;
+      return EV_TS_GET (ts);
     }
 #endif
 
@@ -1891,16 +2205,16 @@ get_clock (void)
 
 #if EV_MULTIPLICITY
 ev_tstamp
-ev_now (EV_P) EV_THROW
+ev_now (EV_P) EV_NOEXCEPT
 {
   return ev_rt_now;
 }
 #endif
 
 void
-ev_sleep (ev_tstamp delay) EV_THROW
+ev_sleep (ev_tstamp delay) EV_NOEXCEPT
 {
-  if (delay > 0.)
+  if (delay > EV_TS_CONST (0.))
     {
 #if EV_USE_NANOSLEEP
       struct timespec ts;
@@ -1908,7 +2222,9 @@ ev_sleep (ev_tstamp delay) EV_THROW
       EV_TS_SET (ts, delay);
       nanosleep (&ts, 0);
 #elif defined _WIN32
-      Sleep ((unsigned long)(delay * 1e3));
+      /* maybe this should round up, as ms is very low resolution */
+      /* compared to select (µs) or nanosleep (ns) */
+      Sleep ((unsigned long)(EV_TS_TO_MSEC (delay)));
 #else
       struct timeval tv;
 
@@ -1948,7 +2264,7 @@ array_nextsize (int elem, int cur, int cnt)
   return ncur;
 }
 
-noinline ecb_cold
+ecb_noinline ecb_cold
 static void *
 array_realloc (int elem, void *base, int *cur, int cnt)
 {
@@ -1956,16 +2272,18 @@ array_realloc (int elem, void *base, int *cur, int cnt)
   return ev_realloc (base, elem * *cur);
 }
 
-#define array_init_zero(base,count)	\
-  memset ((void *)(base), 0, sizeof (*(base)) * (count))
+#define array_needsize_noinit(base,offset,count)
+
+#define array_needsize_zerofill(base,offset,count)	\
+  memset ((void *)(base + offset), 0, sizeof (*(base)) * (count))
 
 #define array_needsize(type,base,cur,cnt,init)			\
-  if (expect_false ((cnt) > (cur)))				\
+  if (ecb_expect_false ((cnt) > (cur)))				\
     {								\
       ecb_unused int ocur_ = (cur);				\
       (base) = (type *)array_realloc				\
          (sizeof (type), (base), &(cur), (cnt));		\
-      init ((base) + (ocur_), (cur) - ocur_);			\
+      init ((base), ocur_, ((cur) - ocur_));			\
     }
 
 #if 0
@@ -1984,25 +2302,25 @@ array_realloc (int elem, void *base, int *cur, int cnt)
 /*****************************************************************************/
 
 /* dummy callback for pending events */
-noinline
+ecb_noinline
 static void
 pendingcb (EV_P_ ev_prepare *w, int revents)
 {
 }
 
-noinline
+ecb_noinline
 void
-ev_feed_event (EV_P_ void *w, int revents) EV_THROW
+ev_feed_event (EV_P_ void *w, int revents) EV_NOEXCEPT
 {
   W w_ = (W)w;
   int pri = ABSPRI (w_);
 
-  if (expect_false (w_->pending))
+  if (ecb_expect_false (w_->pending))
     pendings [pri][w_->pending - 1].events |= revents;
   else
     {
       w_->pending = ++pendingcnt [pri];
-      array_needsize (ANPENDING, pendings [pri], pendingmax [pri], w_->pending, EMPTY2);
+      array_needsize (ANPENDING, pendings [pri], pendingmax [pri], w_->pending, array_needsize_noinit);
       pendings [pri][w_->pending - 1].w      = w_;
       pendings [pri][w_->pending - 1].events = revents;
     }
@@ -2013,7 +2331,7 @@ ev_feed_event (EV_P_ void *w, int revents) EV_THROW
 inline_speed void
 feed_reverse (EV_P_ W w)
 {
-  array_needsize (W, rfeeds, rfeedmax, rfeedcnt + 1, EMPTY2);
+  array_needsize (W, rfeeds, rfeedmax, rfeedcnt + 1, array_needsize_noinit);
   rfeeds [rfeedcnt++] = w;
 }
 
@@ -2058,12 +2376,12 @@ fd_event (EV_P_ int fd, int revents)
 {
   ANFD *anfd = anfds + fd;
 
-  if (expect_true (!anfd->reify))
+  if (ecb_expect_true (!anfd->reify))
     fd_event_nocheck (EV_A_ fd, revents);
 }
 
 void
-ev_feed_fd_event (EV_P_ int fd, int revents) EV_THROW
+ev_feed_fd_event (EV_P_ int fd, int revents) EV_NOEXCEPT
 {
   if (fd >= 0 && fd < anfdmax)
     fd_event_nocheck (EV_A_ fd, revents);
@@ -2076,8 +2394,20 @@ fd_reify (EV_P)
 {
   int i;
 
+  /* most backends do not modify the fdchanges list in backend_modfiy.
+   * except io_uring, which has fixed-size buffers which might force us
+   * to handle events in backend_modify, causing fdchanges to be amended,
+   * which could result in an endless loop.
+   * to avoid this, we do not dynamically handle fds that were added
+   * during fd_reify. that means that for those backends, fdchangecnt
+   * might be non-zero during poll, which must cause them to not block.
+   * to not put too much of a burden on other backends, this detail
+   * needs to be handled in the backend.
+   */
+  int changecnt = fdchangecnt;
+
 #if EV_SELECT_IS_WINSOCKET || EV_USE_IOCP
-  for (i = 0; i < fdchangecnt; ++i)
+  for (i = 0; i < changecnt; ++i)
     {
       int fd = fdchanges [i];
       ANFD *anfd = anfds + fd;
@@ -2101,7 +2431,7 @@ fd_reify (EV_P)
     }
 #endif
 
-  for (i = 0; i < fdchangecnt; ++i)
+  for (i = 0; i < changecnt; ++i)
     {
       int fd = fdchanges [i];
       ANFD *anfd = anfds + fd;
@@ -2110,9 +2440,9 @@ fd_reify (EV_P)
       unsigned char o_events = anfd->events;
       unsigned char o_reify  = anfd->reify;
 
-      anfd->reify  = 0;
+      anfd->reify = 0;
 
-      /*if (expect_true (o_reify & EV_ANFD_REIFY)) probably a deoptimisation */
+      /*if (ecb_expect_true (o_reify & EV_ANFD_REIFY)) probably a deoptimisation */
         {
           anfd->events = 0;
 
@@ -2127,7 +2457,14 @@ fd_reify (EV_P)
         backend_modify (EV_A_ fd, o_events, anfd->events);
     }
 
-  fdchangecnt = 0;
+  /* normally, fdchangecnt hasn't changed. if it has, then new fds have been added.
+   * this is a rare case (see beginning comment in this function), so we copy them to the
+   * front and hope the backend handles this case.
+   */
+  if (ecb_expect_false (fdchangecnt != changecnt))
+    memmove (fdchanges, fdchanges + changecnt, (fdchangecnt - changecnt) * sizeof (*fdchanges));
+
+  fdchangecnt -= changecnt;
 }
 
 /* something about the given fd changed */
@@ -2136,12 +2473,12 @@ void
 fd_change (EV_P_ int fd, int flags)
 {
   unsigned char reify = anfds [fd].reify;
-  anfds [fd].reify |= flags;
+  anfds [fd].reify = reify | flags;
 
-  if (expect_true (!reify))
+  if (ecb_expect_true (!reify))
     {
       ++fdchangecnt;
-      array_needsize (int, fdchanges, fdchangemax, fdchangecnt, EMPTY2);
+      array_needsize (int, fdchanges, fdchangemax, fdchangecnt, array_needsize_noinit);
       fdchanges [fdchangecnt - 1] = fd;
     }
 }
@@ -2171,7 +2508,7 @@ fd_valid (int fd)
 }
 
 /* called on EBADF to verify fds */
-noinline ecb_cold
+ecb_noinline ecb_cold
 static void
 fd_ebadf (EV_P)
 {
@@ -2184,7 +2521,7 @@ fd_ebadf (EV_P)
 }
 
 /* called on ENOMEM in select/poll to kill some fds and retry */
-noinline ecb_cold
+ecb_noinline ecb_cold
 static void
 fd_enomem (EV_P)
 {
@@ -2199,7 +2536,7 @@ fd_enomem (EV_P)
 }
 
 /* usually called after fork if backend needs to re-arm all fds from scratch */
-noinline
+ecb_noinline
 static void
 fd_rearm_all (EV_P)
 {
@@ -2263,19 +2600,19 @@ downheap (ANHE *heap, int N, int k)
       ANHE *pos = heap + DHEAP * (k - HEAP0) + HEAP0 + 1;
 
       /* find minimum child */
-      if (expect_true (pos + DHEAP - 1 < E))
+      if (ecb_expect_true (pos + DHEAP - 1 < E))
         {
           /* fast path */                               (minpos = pos + 0), (minat = ANHE_at (*minpos));
-          if (               ANHE_at (pos [1]) < minat) (minpos = pos + 1), (minat = ANHE_at (*minpos));
-          if (               ANHE_at (pos [2]) < minat) (minpos = pos + 2), (minat = ANHE_at (*minpos));
-          if (               ANHE_at (pos [3]) < minat) (minpos = pos + 3), (minat = ANHE_at (*minpos));
+          if (               minat > ANHE_at (pos [1])) (minpos = pos + 1), (minat = ANHE_at (*minpos));
+          if (               minat > ANHE_at (pos [2])) (minpos = pos + 2), (minat = ANHE_at (*minpos));
+          if (               minat > ANHE_at (pos [3])) (minpos = pos + 3), (minat = ANHE_at (*minpos));
         }
       else if (pos < E)
         {
           /* slow path */                               (minpos = pos + 0), (minat = ANHE_at (*minpos));
-          if (pos + 1 < E && ANHE_at (pos [1]) < minat) (minpos = pos + 1), (minat = ANHE_at (*minpos));
-          if (pos + 2 < E && ANHE_at (pos [2]) < minat) (minpos = pos + 2), (minat = ANHE_at (*minpos));
-          if (pos + 3 < E && ANHE_at (pos [3]) < minat) (minpos = pos + 3), (minat = ANHE_at (*minpos));
+          if (pos + 1 < E && minat > ANHE_at (pos [1])) (minpos = pos + 1), (minat = ANHE_at (*minpos));
+          if (pos + 2 < E && minat > ANHE_at (pos [2])) (minpos = pos + 2), (minat = ANHE_at (*minpos));
+          if (pos + 3 < E && minat > ANHE_at (pos [3])) (minpos = pos + 3), (minat = ANHE_at (*minpos));
         }
       else
         break;
@@ -2293,7 +2630,7 @@ downheap (ANHE *heap, int N, int k)
   ev_active (ANHE_w (he)) = k;
 }
 
-#else /* 4HEAP */
+#else /* not 4HEAP */
 
 #define HEAP0 1
 #define HPARENT(k) ((k) >> 1)
@@ -2375,7 +2712,7 @@ reheap (ANHE *heap, int N)
 
 /*****************************************************************************/
 
-/* associate signal watchers to a signal signal */
+/* associate signal watchers to a signal */
 typedef struct
 {
   EV_ATOMIC_T pending;
@@ -2391,7 +2728,7 @@ static ANSIG signals [EV_NSIG - 1];
 
 #if EV_SIGNAL_ENABLE || EV_ASYNC_ENABLE
 
-noinline ecb_cold
+ecb_noinline ecb_cold
 static void
 evpipe_init (EV_P)
 {
@@ -2442,7 +2779,7 @@ evpipe_write (EV_P_ EV_ATOMIC_T *flag)
 {
   ECB_MEMORY_FENCE; /* push out the write before this function was called, acquire flag */
 
-  if (expect_true (*flag))
+  if (ecb_expect_true (*flag))
     return;
 
   *flag = 1;
@@ -2473,7 +2810,6 @@ evpipe_write (EV_P_ EV_ATOMIC_T *flag)
 #ifdef _WIN32
           WSABUF buf;
           DWORD sent;
-//	  buf.buf=&buf;
           buf.buf = (char *)&buf;
           buf.len = 1;
           WSASend (EV_FD_TO_WIN32_HANDLE (evpipe [1]), &buf, 1, &sent, 0, 0, 0);
@@ -2530,7 +2866,7 @@ pipecb (EV_P_ ev_io *iow, int revents)
       ECB_MEMORY_FENCE;
 
       for (i = EV_NSIG - 1; i--; )
-        if (expect_false (signals [i].pending))
+        if (ecb_expect_false (signals [i].pending))
           ev_feed_signal_event (EV_A_ i + 1);
     }
 #endif
@@ -2556,7 +2892,7 @@ pipecb (EV_P_ ev_io *iow, int revents)
 /*****************************************************************************/
 
 void
-ev_feed_signal (int signum) EV_THROW
+ev_feed_signal (int signum) EV_NOEXCEPT
 {
 #if EV_MULTIPLICITY
   EV_P;
@@ -2581,13 +2917,13 @@ ev_sighandler (int signum)
   ev_feed_signal (signum);
 }
 
-noinline
+ecb_noinline
 void
-ev_feed_signal_event (EV_P_ int signum) EV_THROW
+ev_feed_signal_event (EV_P_ int signum) EV_NOEXCEPT
 {
   WL w;
 
-  if (expect_false (signum <= 0 || signum >= EV_NSIG))
+  if (ecb_expect_false (signum <= 0 || signum >= EV_NSIG))
     return;
 
   --signum;
@@ -2596,7 +2932,7 @@ ev_feed_signal_event (EV_P_ int signum) EV_THROW
   /* it is permissible to try to feed a signal to the wrong loop */
   /* or, likely more useful, feeding a signal nobody is waiting for */
 
-  if (expect_false (signals [signum].loop != EV_A))
+  if (ecb_expect_false (signals [signum].loop != EV_A))
     return;
 #endif
 
@@ -2690,6 +3026,57 @@ childcb (EV_P_ ev_signal *sw, int revents)
 
 /*****************************************************************************/
 
+#if EV_USE_TIMERFD
+
+static void periodics_reschedule (EV_P);
+
+static void
+timerfdcb (EV_P_ ev_io *iow, int revents)
+{
+  struct itimerspec its = { 0 };
+
+  its.it_value.tv_sec = ev_rt_now + (int)MAX_BLOCKTIME2;
+  timerfd_settime (timerfd, TFD_TIMER_ABSTIME | TFD_TIMER_CANCEL_ON_SET, &its, 0);
+
+  ev_rt_now = ev_time ();
+  /* periodics_reschedule only needs ev_rt_now */
+  /* but maybe in the future we want the full treatment. */
+  /*
+  now_floor = EV_TS_CONST (0.);
+  time_update (EV_A_ EV_TSTAMP_HUGE);
+  */
+#if EV_PERIODIC_ENABLE
+  periodics_reschedule (EV_A);
+#endif
+}
+
+ecb_noinline ecb_cold
+static void
+evtimerfd_init (EV_P)
+{
+  if (!ev_is_active (&timerfd_w))
+    {
+      timerfd = timerfd_create (CLOCK_REALTIME, TFD_NONBLOCK | TFD_CLOEXEC);
+
+      if (timerfd >= 0)
+        {
+          fd_intern (timerfd); /* just to be sure */
+
+          ev_io_init (&timerfd_w, timerfdcb, timerfd, EV_READ);
+          ev_set_priority (&timerfd_w, EV_MINPRI);
+          ev_io_start (EV_A_ &timerfd_w);
+          ev_unref (EV_A); /* watcher should not keep loop alive */
+
+          /* (re-) arm timer */
+          timerfdcb (EV_A_ 0, 0);
+        }
+    }
+}
+
+#endif
+
+/*****************************************************************************/
+
 #if EV_USE_IOCP
 # include "ev_iocp.c"
 #endif
@@ -2702,6 +3089,12 @@ childcb (EV_P_ ev_signal *sw, int revents)
 #if EV_USE_EPOLL
 # include "ev_epoll.c"
 #endif
+#if EV_USE_LINUXAIO
+# include "ev_linuxaio.c"
+#endif
+#if EV_USE_IOURING
+# include "ev_iouring.c"
+#endif
 #if EV_USE_POLL
 # include "ev_poll.c"
 #endif
@@ -2710,13 +3103,13 @@ childcb (EV_P_ ev_signal *sw, int revents)
 #endif
 
 ecb_cold int
-ev_version_major (void) EV_THROW
+ev_version_major (void) EV_NOEXCEPT
 {
   return EV_VERSION_MAJOR;
 }
 
 ecb_cold int
-ev_version_minor (void) EV_THROW
+ev_version_minor (void) EV_NOEXCEPT
 {
   return EV_VERSION_MINOR;
 }
@@ -2735,22 +3128,24 @@ enable_secure (void)
 
 ecb_cold
 unsigned int
-ev_supported_backends (void) EV_THROW
+ev_supported_backends (void) EV_NOEXCEPT
 {
   unsigned int flags = 0;
 
-  if (EV_USE_PORT  ) flags |= EVBACKEND_PORT;
-  if (EV_USE_KQUEUE) flags |= EVBACKEND_KQUEUE;
-  if (EV_USE_EPOLL ) flags |= EVBACKEND_EPOLL;
-  if (EV_USE_POLL  ) flags |= EVBACKEND_POLL;
-  if (EV_USE_SELECT) flags |= EVBACKEND_SELECT;
-  
+  if (EV_USE_PORT                                      ) flags |= EVBACKEND_PORT;
+  if (EV_USE_KQUEUE                                    ) flags |= EVBACKEND_KQUEUE;
+  if (EV_USE_EPOLL                                     ) flags |= EVBACKEND_EPOLL;
+  if (EV_USE_LINUXAIO                                  ) flags |= EVBACKEND_LINUXAIO;
+  if (EV_USE_IOURING && ev_linux_version () >= 0x050601) flags |= EVBACKEND_IOURING; /* 5.6.1+ */
+  if (EV_USE_POLL                                      ) flags |= EVBACKEND_POLL;
+  if (EV_USE_SELECT                                    ) flags |= EVBACKEND_SELECT;
+
   return flags;
 }
 
 ecb_cold
 unsigned int
-ev_recommended_backends (void) EV_THROW
+ev_recommended_backends (void) EV_NOEXCEPT
 {
   unsigned int flags = ev_supported_backends ();
 
@@ -2768,73 +3163,84 @@ ev_recommended_backends (void) EV_THROW
   flags &= ~EVBACKEND_POLL;   /* poll return value is unusable (http://forums.freebsd.org/archive/index.php/t-10270.html) */
 #endif
 
+  /* TODO: linuxaio is very experimental */
+#if !EV_RECOMMEND_LINUXAIO
+  flags &= ~EVBACKEND_LINUXAIO;
+#endif
+  /* TODO: linuxaio is super experimental */
+#if !EV_RECOMMEND_IOURING
+  flags &= ~EVBACKEND_IOURING;
+#endif
+
   return flags;
 }
 
 ecb_cold
 unsigned int
-ev_embeddable_backends (void) EV_THROW
+ev_embeddable_backends (void) EV_NOEXCEPT
 {
-  int flags = EVBACKEND_EPOLL | EVBACKEND_KQUEUE | EVBACKEND_PORT;
+  int flags = EVBACKEND_EPOLL | EVBACKEND_KQUEUE | EVBACKEND_PORT | EVBACKEND_IOURING;
 
   /* epoll embeddability broken on all linux versions up to at least 2.6.23 */
   if (ev_linux_version () < 0x020620) /* disable it on linux < 2.6.32 */
     flags &= ~EVBACKEND_EPOLL;
 
+  /* EVBACKEND_LINUXAIO is theoretically embeddable, but suffers from a performance overhead */
+
   return flags;
 }
 
 unsigned int
-ev_backend (EV_P) EV_THROW
+ev_backend (EV_P) EV_NOEXCEPT
 {
   return backend;
 }
 
 #if EV_FEATURE_API
 unsigned int
-ev_iteration (EV_P) EV_THROW
+ev_iteration (EV_P) EV_NOEXCEPT
 {
   return loop_count;
 }
 
 unsigned int
-ev_depth (EV_P) EV_THROW
+ev_depth (EV_P) EV_NOEXCEPT
 {
   return loop_depth;
 }
 
 void
-ev_set_io_collect_interval (EV_P_ ev_tstamp interval) EV_THROW
+ev_set_io_collect_interval (EV_P_ ev_tstamp interval) EV_NOEXCEPT
 {
   io_blocktime = interval;
 }
 
 void
-ev_set_timeout_collect_interval (EV_P_ ev_tstamp interval) EV_THROW
+ev_set_timeout_collect_interval (EV_P_ ev_tstamp interval) EV_NOEXCEPT
 {
   timeout_blocktime = interval;
 }
 
 void
-ev_set_userdata (EV_P_ void *data) EV_THROW
+ev_set_userdata (EV_P_ void *data) EV_NOEXCEPT
 {
   userdata = data;
 }
 
 void *
-ev_userdata (EV_P) EV_THROW
+ev_userdata (EV_P) EV_NOEXCEPT
 {
   return userdata;
 }
 
 void
-ev_set_invoke_pending_cb (EV_P_ ev_loop_callback invoke_pending_cb) EV_THROW
+ev_set_invoke_pending_cb (EV_P_ ev_loop_callback invoke_pending_cb) EV_NOEXCEPT
 {
   invoke_cb = invoke_pending_cb;
 }
 
 void
-ev_set_loop_release_cb (EV_P_ void (*release)(EV_P) EV_THROW, void (*acquire)(EV_P) EV_THROW) EV_THROW
+ev_set_loop_release_cb (EV_P_ void (*release)(EV_P) EV_NOEXCEPT, void (*acquire)(EV_P) EV_NOEXCEPT) EV_NOEXCEPT
 {
   release_cb = release;
   acquire_cb = acquire;
@@ -2842,9 +3248,9 @@ ev_set_loop_release_cb (EV_P_ void (*release)(EV_P) EV_THROW, void (*acquire)(EV
 #endif
 
 /* initialise a loop structure, must be zero-initialised */
-noinline ecb_cold
+ecb_noinline ecb_cold
 static void
-loop_init (EV_P_ unsigned int flags) EV_THROW
+loop_init (EV_P_ unsigned int flags) EV_NOEXCEPT
 {
   if (!backend)
     {
@@ -2907,27 +3313,36 @@ loop_init (EV_P_ unsigned int flags) EV_THROW
 #if EV_USE_SIGNALFD
       sigfd              = flags & EVFLAG_SIGNALFD  ? -2 : -1;
 #endif
+#if EV_USE_TIMERFD
+      timerfd            = flags & EVFLAG_NOTIMERFD ? -1 : -2;
+#endif
 
       if (!(flags & EVBACKEND_MASK))
         flags |= ev_recommended_backends ();
 
 #if EV_USE_IOCP
-      if (!backend && (flags & EVBACKEND_IOCP  )) backend = iocp_init   (EV_A_ flags);
+      if (!backend && (flags & EVBACKEND_IOCP    )) backend = iocp_init      (EV_A_ flags);
 #endif
 #if EV_USE_PORT
-      if (!backend && (flags & EVBACKEND_PORT  )) backend = port_init   (EV_A_ flags);
+      if (!backend && (flags & EVBACKEND_PORT    )) backend = port_init      (EV_A_ flags);
 #endif
 #if EV_USE_KQUEUE
-      if (!backend && (flags & EVBACKEND_KQUEUE)) backend = kqueue_init (EV_A_ flags);
+      if (!backend && (flags & EVBACKEND_KQUEUE  )) backend = kqueue_init    (EV_A_ flags);
+#endif
+#if EV_USE_IOURING
+      if (!backend && (flags & EVBACKEND_IOURING )) backend = iouring_init   (EV_A_ flags);
+#endif
+#if EV_USE_LINUXAIO
+      if (!backend && (flags & EVBACKEND_LINUXAIO)) backend = linuxaio_init  (EV_A_ flags);
 #endif
 #if EV_USE_EPOLL
-      if (!backend && (flags & EVBACKEND_EPOLL )) backend = epoll_init  (EV_A_ flags);
+      if (!backend && (flags & EVBACKEND_EPOLL   )) backend = epoll_init     (EV_A_ flags);
 #endif
 #if EV_USE_POLL
-      if (!backend && (flags & EVBACKEND_POLL  )) backend = poll_init   (EV_A_ flags);
+      if (!backend && (flags & EVBACKEND_POLL    )) backend = poll_init      (EV_A_ flags);
 #endif
 #if EV_USE_SELECT
-      if (!backend && (flags & EVBACKEND_SELECT)) backend = select_init (EV_A_ flags);
+      if (!backend && (flags & EVBACKEND_SELECT  )) backend = select_init    (EV_A_ flags);
 #endif
 
       ev_prepare_init (&pending_w, pendingcb);
@@ -2954,7 +3369,7 @@ ev_loop_destroy (EV_P)
 
 #if EV_CLEANUP_ENABLE
   /* queue cleanup watchers (and execute them) */
-  if (expect_false (cleanupcnt))
+  if (ecb_expect_false (cleanupcnt))
     {
       queue_events (EV_A_ (W *)cleanups, cleanupcnt, EV_CLEANUP);
       EV_INVOKE_PENDING;
@@ -2983,6 +3398,11 @@ ev_loop_destroy (EV_P)
     close (sigfd);
 #endif
 
+#if EV_USE_TIMERFD
+  if (ev_is_active (&timerfd_w))
+    close (timerfd);
+#endif
+
 #if EV_USE_INOTIFY
   if (fs_fd >= 0)
     close (fs_fd);
@@ -2992,22 +3412,28 @@ ev_loop_destroy (EV_P)
     close (backend_fd);
 
 #if EV_USE_IOCP
-  if (backend == EVBACKEND_IOCP  ) iocp_destroy   (EV_A);
+  if (backend == EVBACKEND_IOCP    ) iocp_destroy     (EV_A);
 #endif
 #if EV_USE_PORT
-  if (backend == EVBACKEND_PORT  ) port_destroy   (EV_A);
+  if (backend == EVBACKEND_PORT    ) port_destroy     (EV_A);
 #endif
 #if EV_USE_KQUEUE
-  if (backend == EVBACKEND_KQUEUE) kqueue_destroy (EV_A);
+  if (backend == EVBACKEND_KQUEUE  ) kqueue_destroy   (EV_A);
+#endif
+#if EV_USE_IOURING
+  if (backend == EVBACKEND_IOURING ) iouring_destroy  (EV_A);
+#endif
+#if EV_USE_LINUXAIO
+  if (backend == EVBACKEND_LINUXAIO) linuxaio_destroy (EV_A);
 #endif
 #if EV_USE_EPOLL
-  if (backend == EVBACKEND_EPOLL ) epoll_destroy  (EV_A);
+  if (backend == EVBACKEND_EPOLL   ) epoll_destroy    (EV_A);
 #endif
 #if EV_USE_POLL
-  if (backend == EVBACKEND_POLL  ) poll_destroy   (EV_A);
+  if (backend == EVBACKEND_POLL    ) poll_destroy     (EV_A);
 #endif
 #if EV_USE_SELECT
-  if (backend == EVBACKEND_SELECT) select_destroy (EV_A);
+  if (backend == EVBACKEND_SELECT  ) select_destroy   (EV_A);
 #endif
 
   for (i = NUMPRI; i--; )
@@ -3059,34 +3485,62 @@ inline_size void
 loop_fork (EV_P)
 {
 #if EV_USE_PORT
-  if (backend == EVBACKEND_PORT  ) port_fork   (EV_A);
+  if (backend == EVBACKEND_PORT    ) port_fork     (EV_A);
 #endif
 #if EV_USE_KQUEUE
-  if (backend == EVBACKEND_KQUEUE) kqueue_fork (EV_A);
+  if (backend == EVBACKEND_KQUEUE  ) kqueue_fork   (EV_A);
+#endif
+#if EV_USE_IOURING
+  if (backend == EVBACKEND_IOURING ) iouring_fork  (EV_A);
+#endif
+#if EV_USE_LINUXAIO
+  if (backend == EVBACKEND_LINUXAIO) linuxaio_fork (EV_A);
 #endif
 #if EV_USE_EPOLL
-  if (backend == EVBACKEND_EPOLL ) epoll_fork  (EV_A);
+  if (backend == EVBACKEND_EPOLL   ) epoll_fork    (EV_A);
 #endif
 #if EV_USE_INOTIFY
   infy_fork (EV_A);
 #endif
 
-#if EV_SIGNAL_ENABLE || EV_ASYNC_ENABLE
-  if (ev_is_active (&pipe_w) && postfork != 2)
+  if (postfork != 2)
     {
-      /* pipe_write_wanted must be false now, so modifying fd vars should be safe */
-
-      ev_ref (EV_A);
-      ev_io_stop (EV_A_ &pipe_w);
-
-      if (evpipe [0] >= 0)
-        EV_WIN32_CLOSE_FD (evpipe [0]);
+      #if EV_USE_SIGNALFD
+        /* surprisingly, nothing needs to be done for signalfd, accoridng to docs, it does the right thing on fork */
+      #endif
+      
+      #if EV_USE_TIMERFD
+        if (ev_is_active (&timerfd_w))
+          {
+            ev_ref (EV_A);
+            ev_io_stop (EV_A_ &timerfd_w);
 
-      evpipe_init (EV_A);
-      /* iterate over everything, in case we missed something before */
-      ev_feed_event (EV_A_ &pipe_w, EV_CUSTOM);
+            close (timerfd);
+            timerfd = -2;
+      
+            evtimerfd_init (EV_A);
+            /* reschedule periodics, in case we missed something */
+            ev_feed_event (EV_A_ &timerfd_w, EV_CUSTOM);
+          }
+      #endif
+      
+      #if EV_SIGNAL_ENABLE || EV_ASYNC_ENABLE
+        if (ev_is_active (&pipe_w))
+          {
+            /* pipe_write_wanted must be false now, so modifying fd vars should be safe */
+      
+            ev_ref (EV_A);
+            ev_io_stop (EV_A_ &pipe_w);
+      
+            if (evpipe [0] >= 0)
+              EV_WIN32_CLOSE_FD (evpipe [0]);
+      
+            evpipe_init (EV_A);
+            /* iterate over everything, in case we missed something before */
+            ev_feed_event (EV_A_ &pipe_w, EV_CUSTOM);
+          }
+      #endif
     }
-#endif
 
   postfork = 0;
 }
@@ -3095,7 +3549,7 @@ loop_fork (EV_P)
 
 ecb_cold
 struct ev_loop *
-ev_loop_new (unsigned int flags) EV_THROW
+ev_loop_new (unsigned int flags) EV_NOEXCEPT
 {
   EV_P = (struct ev_loop *)ev_malloc (sizeof (struct ev_loop));
 
@@ -3112,7 +3566,7 @@ ev_loop_new (unsigned int flags) EV_THROW
 #endif /* multiplicity */
 
 #if EV_VERIFY
-noinline ecb_cold
+ecb_noinline ecb_cold
 static void
 verify_watcher (EV_P_ W w)
 {
@@ -3122,7 +3576,7 @@ verify_watcher (EV_P_ W w)
     assert (("libev: pending watcher not on pending queue", pendings [ABSPRI (w)][w->pending - 1].w == w));
 }
 
-noinline ecb_cold
+ecb_noinline ecb_cold
 static void
 verify_heap (EV_P_ ANHE *heap, int N)
 {
@@ -3138,7 +3592,7 @@ verify_heap (EV_P_ ANHE *heap, int N)
     }
 }
 
-noinline ecb_cold
+ecb_noinline ecb_cold
 static void
 array_verify (EV_P_ W *ws, int cnt)
 {
@@ -3152,7 +3606,7 @@ array_verify (EV_P_ W *ws, int cnt)
 
 #if EV_FEATURE_API
 void ecb_cold
-ev_verify (EV_P) EV_THROW
+ev_verify (EV_P) EV_NOEXCEPT
 {
 #if EV_VERIFY
   int i;
@@ -3243,7 +3697,7 @@ struct ev_loop *
 #else
 int
 #endif
-ev_default_loop (unsigned int flags) EV_THROW
+ev_default_loop (unsigned int flags) EV_NOEXCEPT
 {
   if (!ev_default_loop_ptr)
     {
@@ -3272,7 +3726,7 @@ ev_default_loop (unsigned int flags) EV_THROW
 }
 
 void
-ev_loop_fork (EV_P) EV_THROW
+ev_loop_fork (EV_P) EV_NOEXCEPT
 {
   postfork = 1;
 }
@@ -3286,7 +3740,7 @@ ev_invoke (EV_P_ void *w, int revents)
 }
 
 unsigned int
-ev_pending_count (EV_P) EV_THROW
+ev_pending_count (EV_P) EV_NOEXCEPT
 {
   int pri;
   unsigned int count = 0;
@@ -3297,16 +3751,17 @@ ev_pending_count (EV_P) EV_THROW
   return count;
 }
 
-noinline
+ecb_noinline
 void
 ev_invoke_pending (EV_P)
 {
   pendingpri = NUMPRI;
 
-  while (pendingpri) /* pendingpri possibly gets modified in the inner loop */
+  do
     {
       --pendingpri;
 
+      /* pendingpri possibly gets modified in the inner loop */
       while (pendingcnt [pendingpri])
         {
           ANPENDING *p = pendings [pendingpri] + --pendingcnt [pendingpri];
@@ -3316,6 +3771,7 @@ ev_invoke_pending (EV_P)
           EV_FREQUENT_CHECK;
         }
     }
+  while (pendingpri);
 }
 
 #if EV_IDLE_ENABLE
@@ -3324,7 +3780,7 @@ ev_invoke_pending (EV_P)
 inline_size void
 idle_reify (EV_P)
 {
-  if (expect_false (idleall))
+  if (ecb_expect_false (idleall))
     {
       int pri;
 
@@ -3364,7 +3820,7 @@ timers_reify (EV_P)
               if (ev_at (w) < mn_now)
                 ev_at (w) = mn_now;
 
-              assert (("libev: negative ev_timer repeat value found while processing timers", w->repeat > 0.));
+              assert (("libev: negative ev_timer repeat value found while processing timers", w->repeat > EV_TS_CONST (0.)));
 
               ANHE_at_cache (timers [HEAP0]);
               downheap (timers, timercnt, HEAP0);
@@ -3383,7 +3839,7 @@ timers_reify (EV_P)
 
 #if EV_PERIODIC_ENABLE
 
-noinline
+ecb_noinline
 static void
 periodic_recalc (EV_P_ ev_periodic *w)
 {
@@ -3396,7 +3852,7 @@ periodic_recalc (EV_P_ ev_periodic *w)
       ev_tstamp nat = at + w->interval;
 
       /* when resolution fails us, we use ev_rt_now */
-      if (expect_false (nat == at))
+      if (ecb_expect_false (nat == at))
         {
           at = ev_rt_now;
           break;
@@ -3452,7 +3908,7 @@ periodics_reify (EV_P)
 
 /* simply recalculate all periodics */
 /* TODO: maybe ensure that at least one event happens when jumping forward? */
-noinline ecb_cold
+ecb_noinline ecb_cold
 static void
 periodics_reschedule (EV_P)
 {
@@ -3476,7 +3932,7 @@ periodics_reschedule (EV_P)
 #endif
 
 /* adjust all timers by a given offset */
-noinline ecb_cold
+ecb_noinline ecb_cold
 static void
 timers_reschedule (EV_P_ ev_tstamp adjust)
 {
@@ -3496,7 +3952,7 @@ inline_speed void
 time_update (EV_P_ ev_tstamp max_block)
 {
 #if EV_USE_MONOTONIC
-  if (expect_true (have_monotonic))
+  if (ecb_expect_true (have_monotonic))
     {
       int i;
       ev_tstamp odiff = rtmn_diff;
@@ -3505,7 +3961,7 @@ time_update (EV_P_ ev_tstamp max_block)
 
       /* only fetch the realtime clock every 0.5*MIN_TIMEJUMP seconds */
       /* interpolate in the meantime */
-      if (expect_true (mn_now - now_floor < MIN_TIMEJUMP * .5))
+      if (ecb_expect_true (mn_now - now_floor < EV_TS_CONST (MIN_TIMEJUMP * .5)))
         {
           ev_rt_now = rtmn_diff + mn_now;
           return;
@@ -3529,7 +3985,7 @@ time_update (EV_P_ ev_tstamp max_block)
 
           diff = odiff - rtmn_diff;
 
-          if (expect_true ((diff < 0. ? -diff : diff) < MIN_TIMEJUMP))
+          if (ecb_expect_true ((diff < EV_TS_CONST (0.) ? -diff : diff) < EV_TS_CONST (MIN_TIMEJUMP)))
             return; /* all is well */
 
           ev_rt_now = ev_time ();
@@ -3548,7 +4004,7 @@ time_update (EV_P_ ev_tstamp max_block)
     {
       ev_rt_now = ev_time ();
 
-      if (expect_false (mn_now > ev_rt_now || ev_rt_now > mn_now + max_block + MIN_TIMEJUMP))
+      if (ecb_expect_false (mn_now > ev_rt_now || ev_rt_now > mn_now + max_block + EV_TS_CONST (MIN_TIMEJUMP)))
         {
           /* adjust timers. this is easy, as the offset is the same for all of them */
           timers_reschedule (EV_A_ ev_rt_now - mn_now);
@@ -3581,8 +4037,8 @@ ev_run (EV_P_ int flags)
 #endif
 
 #ifndef _WIN32
-      if (expect_false (curpid)) /* penalise the forking check even more */
-        if (expect_false (getpid () != curpid))
+      if (ecb_expect_false (curpid)) /* penalise the forking check even more */
+        if (ecb_expect_false (getpid () != curpid))
           {
             curpid = getpid ();
             postfork = 1;
@@ -3591,7 +4047,7 @@ ev_run (EV_P_ int flags)
 
 #if EV_FORK_ENABLE
       /* we might have forked, so queue fork handlers */
-      if (expect_false (postfork))
+      if (ecb_expect_false (postfork))
         if (forkcnt)
           {
             queue_events (EV_A_ (W *)forks, forkcnt, EV_FORK);
@@ -3601,18 +4057,18 @@ ev_run (EV_P_ int flags)
 
 #if EV_PREPARE_ENABLE
       /* queue prepare watchers (and execute them) */
-      if (expect_false (preparecnt))
+      if (ecb_expect_false (preparecnt))
         {
           queue_events (EV_A_ (W *)prepares, preparecnt, EV_PREPARE);
           EV_INVOKE_PENDING;
         }
 #endif
 
-      if (expect_false (loop_done))
+      if (ecb_expect_false (loop_done))
         break;
 
       /* we might have forked, so reify kernel state if necessary */
-      if (expect_false (postfork))
+      if (ecb_expect_false (postfork))
         loop_fork (EV_A);
 
       /* update fd-related kernel structures */
@@ -3627,16 +4083,28 @@ ev_run (EV_P_ int flags)
         ev_tstamp prev_mn_now = mn_now;
 
         /* update time to cancel out callback processing overhead */
-        time_update (EV_A_ 1e100);
+        time_update (EV_A_ EV_TS_CONST (EV_TSTAMP_HUGE));
 
         /* from now on, we want a pipe-wake-up */
         pipe_write_wanted = 1;
 
         ECB_MEMORY_FENCE; /* make sure pipe_write_wanted is visible before we check for potential skips */
 
-        if (expect_true (!(flags & EVRUN_NOWAIT || idleall || !activecnt || pipe_write_skipped)))
+        if (ecb_expect_true (!(flags & EVRUN_NOWAIT || idleall || !activecnt || pipe_write_skipped)))
           {
-            waittime = MAX_BLOCKTIME;
+            waittime = EV_TS_CONST (MAX_BLOCKTIME);
+
+#if EV_USE_TIMERFD
+            /* sleep a lot longer when we can reliably detect timejumps */
+            if (ecb_expect_true (timerfd >= 0))
+              waittime = EV_TS_CONST (MAX_BLOCKTIME2);
+#endif
+#if !EV_PERIODIC_ENABLE
+            /* without periodics but with monotonic clock there is no need */
+            /* for any time jump detection, so sleep longer */
+            if (ecb_expect_true (have_monotonic))
+              waittime = EV_TS_CONST (MAX_BLOCKTIME2);
+#endif
 
             if (timercnt)
               {
@@ -3653,23 +4121,28 @@ ev_run (EV_P_ int flags)
 #endif
 
             /* don't let timeouts decrease the waittime below timeout_blocktime */
-            if (expect_false (waittime < timeout_blocktime))
+            if (ecb_expect_false (waittime < timeout_blocktime))
               waittime = timeout_blocktime;
 
-            /* at this point, we NEED to wait, so we have to ensure */
-            /* to pass a minimum nonzero value to the backend */
-            if (expect_false (waittime < backend_mintime))
-              waittime = backend_mintime;
+            /* now there are two more special cases left, either we have
+             * already-expired timers, so we should not sleep, or we have timers
+             * that expire very soon, in which case we need to wait for a minimum
+             * amount of time for some event loop backends.
+             */
+            if (ecb_expect_false (waittime < backend_mintime))
+              waittime = waittime <= EV_TS_CONST (0.)
+                 ? EV_TS_CONST (0.)
+                 : backend_mintime;
 
             /* extra check because io_blocktime is commonly 0 */
-            if (expect_false (io_blocktime))
+            if (ecb_expect_false (io_blocktime))
               {
                 sleeptime = io_blocktime - (mn_now - prev_mn_now);
 
                 if (sleeptime > waittime - backend_mintime)
                   sleeptime = waittime - backend_mintime;
 
-                if (expect_true (sleeptime > 0.))
+                if (ecb_expect_true (sleeptime > EV_TS_CONST (0.)))
                   {
                     ev_sleep (sleeptime);
                     waittime -= sleeptime;
@@ -3693,7 +4166,6 @@ ev_run (EV_P_ int flags)
             ev_feed_event (EV_A_ &pipe_w, EV_CUSTOM);
           }
 
-
         /* update ev_rt_now, do magic */
         time_update (EV_A_ waittime + sleeptime);
       }
@@ -3711,13 +4183,13 @@ ev_run (EV_P_ int flags)
 
 #if EV_CHECK_ENABLE
       /* queue check watchers, to be executed first */
-      if (expect_false (checkcnt))
+      if (ecb_expect_false (checkcnt))
         queue_events (EV_A_ (W *)checks, checkcnt, EV_CHECK);
 #endif
 
       EV_INVOKE_PENDING;
     }
-  while (expect_true (
+  while (ecb_expect_true (
     activecnt
     && !loop_done
     && !(flags & (EVRUN_ONCE | EVRUN_NOWAIT))
@@ -3734,37 +4206,37 @@ ev_run (EV_P_ int flags)
 }
 
 void
-ev_break (EV_P_ int how) EV_THROW
+ev_break (EV_P_ int how) EV_NOEXCEPT
 {
   loop_done = how;
 }
 
 void
-ev_ref (EV_P) EV_THROW
+ev_ref (EV_P) EV_NOEXCEPT
 {
   ++activecnt;
 }
 
 void
-ev_unref (EV_P) EV_THROW
+ev_unref (EV_P) EV_NOEXCEPT
 {
   --activecnt;
 }
 
 void
-ev_now_update (EV_P) EV_THROW
+ev_now_update (EV_P) EV_NOEXCEPT
 {
-  time_update (EV_A_ 1e100);
+  time_update (EV_A_ EV_TSTAMP_HUGE);
 }
 
 void
-ev_suspend (EV_P) EV_THROW
+ev_suspend (EV_P) EV_NOEXCEPT
 {
   ev_now_update (EV_A);
 }
 
 void
-ev_resume (EV_P) EV_THROW
+ev_resume (EV_P) EV_NOEXCEPT
 {
   ev_tstamp mn_prev = mn_now;
 
@@ -3791,7 +4263,7 @@ wlist_del (WL *head, WL elem)
 {
   while (*head)
     {
-      if (expect_true (*head == elem))
+      if (ecb_expect_true (*head == elem))
         {
           *head = elem->next;
           break;
@@ -3813,12 +4285,12 @@ clear_pending (EV_P_ W w)
 }
 
 int
-ev_clear_pending (EV_P_ void *w) EV_THROW
+ev_clear_pending (EV_P_ void *w) EV_NOEXCEPT
 {
   W w_ = (W)w;
   int pending = w_->pending;
 
-  if (expect_true (pending))
+  if (ecb_expect_true (pending))
     {
       ANPENDING *p = pendings [ABSPRI (w_)] + pending - 1;
       p->w = (W)&pending_w;
@@ -3855,22 +4327,25 @@ ev_stop (EV_P_ W w)
 
 /*****************************************************************************/
 
-noinline
+ecb_noinline
 void
-ev_io_start (EV_P_ ev_io *w) EV_THROW
+ev_io_start (EV_P_ ev_io *w) EV_NOEXCEPT
 {
   int fd = w->fd;
 
-  if (expect_false (ev_is_active (w)))
+  if (ecb_expect_false (ev_is_active (w)))
     return;
 
   assert (("libev: ev_io_start called with negative fd", fd >= 0));
   assert (("libev: ev_io_start called with illegal event mask", !(w->events & ~(EV__IOFDSET | EV_READ | EV_WRITE))));
 
+#if EV_VERIFY >= 2
+  assert (("libev: ev_io_start called on watcher with invalid fd", fd_valid (fd)));
+#endif
   EV_FREQUENT_CHECK;
 
   ev_start (EV_A_ (W)w, 1);
-  array_needsize (ANFD, anfds, anfdmax, fd + 1, array_init_zero);
+  array_needsize (ANFD, anfds, anfdmax, fd + 1, array_needsize_zerofill);
   wlist_add (&anfds[fd].head, (WL)w);
 
   /* common bug, apparently */
@@ -3882,16 +4357,19 @@ ev_io_start (EV_P_ ev_io *w) EV_THROW
   EV_FREQUENT_CHECK;
 }
 
-noinline
+ecb_noinline
 void
-ev_io_stop (EV_P_ ev_io *w) EV_THROW
+ev_io_stop (EV_P_ ev_io *w) EV_NOEXCEPT
 {
   clear_pending (EV_A_ (W)w);
-  if (expect_false (!ev_is_active (w)))
+  if (ecb_expect_false (!ev_is_active (w)))
     return;
 
   assert (("libev: ev_io_stop called with illegal fd (must stay constant after start!)", w->fd >= 0 && w->fd < anfdmax));
 
+#if EV_VERIFY >= 2
+  assert (("libev: ev_io_stop called on watcher with invalid fd", fd_valid (w->fd)));
+#endif
   EV_FREQUENT_CHECK;
 
   wlist_del (&anfds[w->fd].head, (WL)w);
@@ -3902,11 +4380,11 @@ ev_io_stop (EV_P_ ev_io *w) EV_THROW
   EV_FREQUENT_CHECK;
 }
 
-noinline
+ecb_noinline
 void
-ev_timer_start (EV_P_ ev_timer *w) EV_THROW
+ev_timer_start (EV_P_ ev_timer *w) EV_NOEXCEPT
 {
-  if (expect_false (ev_is_active (w)))
+  if (ecb_expect_false (ev_is_active (w)))
     return;
 
   ev_at (w) += mn_now;
@@ -3917,7 +4395,7 @@ ev_timer_start (EV_P_ ev_timer *w) EV_THROW
 
   ++timercnt;
   ev_start (EV_A_ (W)w, timercnt + HEAP0 - 1);
-  array_needsize (ANHE, timers, timermax, ev_active (w) + 1, EMPTY2);
+  array_needsize (ANHE, timers, timermax, ev_active (w) + 1, array_needsize_noinit);
   ANHE_w (timers [ev_active (w)]) = (WT)w;
   ANHE_at_cache (timers [ev_active (w)]);
   upheap (timers, ev_active (w));
@@ -3927,12 +4405,12 @@ ev_timer_start (EV_P_ ev_timer *w) EV_THROW
   /*assert (("libev: internal timer heap corruption", timers [ev_active (w)] == (WT)w));*/
 }
 
-noinline
+ecb_noinline
 void
-ev_timer_stop (EV_P_ ev_timer *w) EV_THROW
+ev_timer_stop (EV_P_ ev_timer *w) EV_NOEXCEPT
 {
   clear_pending (EV_A_ (W)w);
-  if (expect_false (!ev_is_active (w)))
+  if (ecb_expect_false (!ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
@@ -3944,7 +4422,7 @@ ev_timer_stop (EV_P_ ev_timer *w) EV_THROW
 
     --timercnt;
 
-    if (expect_true (active < timercnt + HEAP0))
+    if (ecb_expect_true (active < timercnt + HEAP0))
       {
         timers [active] = timers [timercnt + HEAP0];
         adjustheap (timers, timercnt, active);
@@ -3958,9 +4436,9 @@ ev_timer_stop (EV_P_ ev_timer *w) EV_THROW
   EV_FREQUENT_CHECK;
 }
 
-noinline
+ecb_noinline
 void
-ev_timer_again (EV_P_ ev_timer *w) EV_THROW
+ev_timer_again (EV_P_ ev_timer *w) EV_NOEXCEPT
 {
   EV_FREQUENT_CHECK;
 
@@ -3987,19 +4465,24 @@ ev_timer_again (EV_P_ ev_timer *w) EV_THROW
 }
 
 ev_tstamp
-ev_timer_remaining (EV_P_ ev_timer *w) EV_THROW
+ev_timer_remaining (EV_P_ ev_timer *w) EV_NOEXCEPT
 {
-  return ev_at (w) - (ev_is_active (w) ? mn_now : 0.);
+  return ev_at (w) - (ev_is_active (w) ? mn_now : EV_TS_CONST (0.));
 }
 
 #if EV_PERIODIC_ENABLE
-noinline
+ecb_noinline
 void
-ev_periodic_start (EV_P_ ev_periodic *w) EV_THROW
+ev_periodic_start (EV_P_ ev_periodic *w) EV_NOEXCEPT
 {
-  if (expect_false (ev_is_active (w)))
+  if (ecb_expect_false (ev_is_active (w)))
     return;
 
+#if EV_USE_TIMERFD
+  if (timerfd == -2)
+    evtimerfd_init (EV_A);
+#endif
+
   if (w->reschedule_cb)
     ev_at (w) = w->reschedule_cb (w, ev_rt_now);
   else if (w->interval)
@@ -4014,7 +4497,7 @@ ev_periodic_start (EV_P_ ev_periodic *w) EV_THROW
 
   ++periodiccnt;
   ev_start (EV_A_ (W)w, periodiccnt + HEAP0 - 1);
-  array_needsize (ANHE, periodics, periodicmax, ev_active (w) + 1, EMPTY2);
+  array_needsize (ANHE, periodics, periodicmax, ev_active (w) + 1, array_needsize_noinit);
   ANHE_w (periodics [ev_active (w)]) = (WT)w;
   ANHE_at_cache (periodics [ev_active (w)]);
   upheap (periodics, ev_active (w));
@@ -4024,12 +4507,12 @@ ev_periodic_start (EV_P_ ev_periodic *w) EV_THROW
   /*assert (("libev: internal periodic heap corruption", ANHE_w (periodics [ev_active (w)]) == (WT)w));*/
 }
 
-noinline
+ecb_noinline
 void
-ev_periodic_stop (EV_P_ ev_periodic *w) EV_THROW
+ev_periodic_stop (EV_P_ ev_periodic *w) EV_NOEXCEPT
 {
   clear_pending (EV_A_ (W)w);
-  if (expect_false (!ev_is_active (w)))
+  if (ecb_expect_false (!ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
@@ -4041,7 +4524,7 @@ ev_periodic_stop (EV_P_ ev_periodic *w) EV_THROW
 
     --periodiccnt;
 
-    if (expect_true (active < periodiccnt + HEAP0))
+    if (ecb_expect_true (active < periodiccnt + HEAP0))
       {
         periodics [active] = periodics [periodiccnt + HEAP0];
         adjustheap (periodics, periodiccnt, active);
@@ -4053,9 +4536,9 @@ ev_periodic_stop (EV_P_ ev_periodic *w) EV_THROW
   EV_FREQUENT_CHECK;
 }
 
-noinline
+ecb_noinline
 void
-ev_periodic_again (EV_P_ ev_periodic *w) EV_THROW
+ev_periodic_again (EV_P_ ev_periodic *w) EV_NOEXCEPT
 {
   /* TODO: use adjustheap and recalculation */
   ev_periodic_stop (EV_A_ w);
@@ -4069,11 +4552,11 @@ ev_periodic_again (EV_P_ ev_periodic *w) EV_THROW
 
 #if EV_SIGNAL_ENABLE
 
-noinline
+ecb_noinline
 void
-ev_signal_start (EV_P_ ev_signal *w) EV_THROW
+ev_signal_start (EV_P_ ev_signal *w) EV_NOEXCEPT
 {
-  if (expect_false (ev_is_active (w)))
+  if (ecb_expect_false (ev_is_active (w)))
     return;
 
   assert (("libev: ev_signal_start called with illegal signal number", w->signum > 0 && w->signum < EV_NSIG));
@@ -4152,12 +4635,12 @@ ev_signal_start (EV_P_ ev_signal *w) EV_THROW
   EV_FREQUENT_CHECK;
 }
 
-noinline
+ecb_noinline
 void
-ev_signal_stop (EV_P_ ev_signal *w) EV_THROW
+ev_signal_stop (EV_P_ ev_signal *w) EV_NOEXCEPT
 {
   clear_pending (EV_A_ (W)w);
-  if (expect_false (!ev_is_active (w)))
+  if (ecb_expect_false (!ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
@@ -4195,12 +4678,12 @@ ev_signal_stop (EV_P_ ev_signal *w) EV_THROW
 #if EV_CHILD_ENABLE
 
 void
-ev_child_start (EV_P_ ev_child *w) EV_THROW
+ev_child_start (EV_P_ ev_child *w) EV_NOEXCEPT
 {
 #if EV_MULTIPLICITY
   assert (("libev: child watchers are only supported in the default loop", loop == ev_default_loop_ptr));
 #endif
-  if (expect_false (ev_is_active (w)))
+  if (ecb_expect_false (ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
@@ -4212,10 +4695,10 @@ ev_child_start (EV_P_ ev_child *w) EV_THROW
 }
 
 void
-ev_child_stop (EV_P_ ev_child *w) EV_THROW
+ev_child_stop (EV_P_ ev_child *w) EV_NOEXCEPT
 {
   clear_pending (EV_A_ (W)w);
-  if (expect_false (!ev_is_active (w)))
+  if (ecb_expect_false (!ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
@@ -4239,14 +4722,14 @@ ev_child_stop (EV_P_ ev_child *w) EV_THROW
 #define NFS_STAT_INTERVAL 30.1074891 /* for filesystems potentially failing inotify */
 #define MIN_STAT_INTERVAL  0.1074891
 
-noinline static void stat_timer_cb (EV_P_ ev_timer *w_, int revents);
+ecb_noinline static void stat_timer_cb (EV_P_ ev_timer *w_, int revents);
 
 #if EV_USE_INOTIFY
 
 /* the * 2 is to allow for alignment padding, which for some reason is >> 8 */
 # define EV_INOTIFY_BUFSIZE (sizeof (struct inotify_event) * 2 + NAME_MAX)
 
-noinline
+ecb_noinline
 static void
 infy_add (EV_P_ ev_stat *w)
 {
@@ -4321,7 +4804,7 @@ infy_add (EV_P_ ev_stat *w)
   if (ev_is_active (&w->timer)) ev_unref (EV_A);
 }
 
-noinline
+ecb_noinline
 static void
 infy_del (EV_P_ ev_stat *w)
 {
@@ -4339,7 +4822,7 @@ infy_del (EV_P_ ev_stat *w)
   inotify_rm_watch (fs_fd, wd);
 }
 
-noinline
+ecb_noinline
 static void
 infy_wd (EV_P_ int slot, int wd, struct inotify_event *ev)
 {
@@ -4487,7 +4970,7 @@ infy_fork (EV_P)
 #endif
 
 void
-ev_stat_stat (EV_P_ ev_stat *w) EV_THROW
+ev_stat_stat (EV_P_ ev_stat *w) EV_NOEXCEPT
 {
   if (lstat (w->path, &w->attr) < 0)
     w->attr.st_nlink = 0;
@@ -4495,7 +4978,7 @@ ev_stat_stat (EV_P_ ev_stat *w) EV_THROW
     w->attr.st_nlink = 1;
 }
 
-noinline
+ecb_noinline
 static void
 stat_timer_cb (EV_P_ ev_timer *w_, int revents)
 {
@@ -4537,9 +5020,9 @@ stat_timer_cb (EV_P_ ev_timer *w_, int revents)
 }
 
 void
-ev_stat_start (EV_P_ ev_stat *w) EV_THROW
+ev_stat_start (EV_P_ ev_stat *w) EV_NOEXCEPT
 {
-  if (expect_false (ev_is_active (w)))
+  if (ecb_expect_false (ev_is_active (w)))
     return;
 
   ev_stat_stat (EV_A_ w);
@@ -4568,10 +5051,10 @@ ev_stat_start (EV_P_ ev_stat *w) EV_THROW
 }
 
 void
-ev_stat_stop (EV_P_ ev_stat *w) EV_THROW
+ev_stat_stop (EV_P_ ev_stat *w) EV_NOEXCEPT
 {
   clear_pending (EV_A_ (W)w);
-  if (expect_false (!ev_is_active (w)))
+  if (ecb_expect_false (!ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
@@ -4594,9 +5077,9 @@ ev_stat_stop (EV_P_ ev_stat *w) EV_THROW
 
 #if EV_IDLE_ENABLE
 void
-ev_idle_start (EV_P_ ev_idle *w) EV_THROW
+ev_idle_start (EV_P_ ev_idle *w) EV_NOEXCEPT
 {
-  if (expect_false (ev_is_active (w)))
+  if (ecb_expect_false (ev_is_active (w)))
     return;
 
   pri_adjust (EV_A_ (W)w);
@@ -4609,7 +5092,7 @@ ev_idle_start (EV_P_ ev_idle *w) EV_THROW
     ++idleall;
     ev_start (EV_A_ (W)w, active);
 
-    array_needsize (ev_idle *, idles [ABSPRI (w)], idlemax [ABSPRI (w)], active, EMPTY2);
+    array_needsize (ev_idle *, idles [ABSPRI (w)], idlemax [ABSPRI (w)], active, array_needsize_noinit);
     idles [ABSPRI (w)][active - 1] = w;
   }
 
@@ -4617,10 +5100,10 @@ ev_idle_start (EV_P_ ev_idle *w) EV_THROW
 }
 
 void
-ev_idle_stop (EV_P_ ev_idle *w) EV_THROW
+ev_idle_stop (EV_P_ ev_idle *w) EV_NOEXCEPT
 {
   clear_pending (EV_A_ (W)w);
-  if (expect_false (!ev_is_active (w)))
+  if (ecb_expect_false (!ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
@@ -4641,25 +5124,25 @@ ev_idle_stop (EV_P_ ev_idle *w) EV_THROW
 
 #if EV_PREPARE_ENABLE
 void
-ev_prepare_start (EV_P_ ev_prepare *w) EV_THROW
+ev_prepare_start (EV_P_ ev_prepare *w) EV_NOEXCEPT
 {
-  if (expect_false (ev_is_active (w)))
+  if (ecb_expect_false (ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
 
   ev_start (EV_A_ (W)w, ++preparecnt);
-  array_needsize (ev_prepare *, prepares, preparemax, preparecnt, EMPTY2);
+  array_needsize (ev_prepare *, prepares, preparemax, preparecnt, array_needsize_noinit);
   prepares [preparecnt - 1] = w;
 
   EV_FREQUENT_CHECK;
 }
 
 void
-ev_prepare_stop (EV_P_ ev_prepare *w) EV_THROW
+ev_prepare_stop (EV_P_ ev_prepare *w) EV_NOEXCEPT
 {
   clear_pending (EV_A_ (W)w);
-  if (expect_false (!ev_is_active (w)))
+  if (ecb_expect_false (!ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
@@ -4679,25 +5162,25 @@ ev_prepare_stop (EV_P_ ev_prepare *w) EV_THROW
 
 #if EV_CHECK_ENABLE
 void
-ev_check_start (EV_P_ ev_check *w) EV_THROW
+ev_check_start (EV_P_ ev_check *w) EV_NOEXCEPT
 {
-  if (expect_false (ev_is_active (w)))
+  if (ecb_expect_false (ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
 
   ev_start (EV_A_ (W)w, ++checkcnt);
-  array_needsize (ev_check *, checks, checkmax, checkcnt, EMPTY2);
+  array_needsize (ev_check *, checks, checkmax, checkcnt, array_needsize_noinit);
   checks [checkcnt - 1] = w;
 
   EV_FREQUENT_CHECK;
 }
 
 void
-ev_check_stop (EV_P_ ev_check *w) EV_THROW
+ev_check_stop (EV_P_ ev_check *w) EV_NOEXCEPT
 {
   clear_pending (EV_A_ (W)w);
-  if (expect_false (!ev_is_active (w)))
+  if (ecb_expect_false (!ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
@@ -4716,9 +5199,9 @@ ev_check_stop (EV_P_ ev_check *w) EV_THROW
 #endif
 
 #if EV_EMBED_ENABLE
-noinline
+ecb_noinline
 void
-ev_embed_sweep (EV_P_ ev_embed *w) EV_THROW
+ev_embed_sweep (EV_P_ ev_embed *w) EV_NOEXCEPT
 {
   ev_run (w->other, EVRUN_NOWAIT);
 }
@@ -4750,6 +5233,7 @@ embed_prepare_cb (EV_P_ ev_prepare *prepare, int revents)
   }
 }
 
+#if EV_FORK_ENABLE
 static void
 embed_fork_cb (EV_P_ ev_fork *fork_w, int revents)
 {
@@ -4766,6 +5250,7 @@ embed_fork_cb (EV_P_ ev_fork *fork_w, int revents)
 
   ev_embed_start (EV_A_ w);
 }
+#endif
 
 #if 0
 static void
@@ -4776,9 +5261,9 @@ embed_idle_cb (EV_P_ ev_idle *idle, int revents)
 #endif
 
 void
-ev_embed_start (EV_P_ ev_embed *w) EV_THROW
+ev_embed_start (EV_P_ ev_embed *w) EV_NOEXCEPT
 {
-  if (expect_false (ev_is_active (w)))
+  if (ecb_expect_false (ev_is_active (w)))
     return;
 
   {
@@ -4796,8 +5281,10 @@ ev_embed_start (EV_P_ ev_embed *w) EV_THROW
   ev_set_priority (&w->prepare, EV_MINPRI);
   ev_prepare_start (EV_A_ &w->prepare);
 
+#if EV_FORK_ENABLE
   ev_fork_init (&w->fork, embed_fork_cb);
   ev_fork_start (EV_A_ &w->fork);
+#endif
 
   /*ev_idle_init (&w->idle, e,bed_idle_cb);*/
 
@@ -4807,17 +5294,19 @@ ev_embed_start (EV_P_ ev_embed *w) EV_THROW
 }
 
 void
-ev_embed_stop (EV_P_ ev_embed *w) EV_THROW
+ev_embed_stop (EV_P_ ev_embed *w) EV_NOEXCEPT
 {
   clear_pending (EV_A_ (W)w);
-  if (expect_false (!ev_is_active (w)))
+  if (ecb_expect_false (!ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
 
   ev_io_stop      (EV_A_ &w->io);
   ev_prepare_stop (EV_A_ &w->prepare);
+#if EV_FORK_ENABLE
   ev_fork_stop    (EV_A_ &w->fork);
+#endif
 
   ev_stop (EV_A_ (W)w);
 
@@ -4827,25 +5316,25 @@ ev_embed_stop (EV_P_ ev_embed *w) EV_THROW
 
 #if EV_FORK_ENABLE
 void
-ev_fork_start (EV_P_ ev_fork *w) EV_THROW
+ev_fork_start (EV_P_ ev_fork *w) EV_NOEXCEPT
 {
-  if (expect_false (ev_is_active (w)))
+  if (ecb_expect_false (ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
 
   ev_start (EV_A_ (W)w, ++forkcnt);
-  array_needsize (ev_fork *, forks, forkmax, forkcnt, EMPTY2);
+  array_needsize (ev_fork *, forks, forkmax, forkcnt, array_needsize_noinit);
   forks [forkcnt - 1] = w;
 
   EV_FREQUENT_CHECK;
 }
 
 void
-ev_fork_stop (EV_P_ ev_fork *w) EV_THROW
+ev_fork_stop (EV_P_ ev_fork *w) EV_NOEXCEPT
 {
   clear_pending (EV_A_ (W)w);
-  if (expect_false (!ev_is_active (w)))
+  if (ecb_expect_false (!ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
@@ -4865,15 +5354,15 @@ ev_fork_stop (EV_P_ ev_fork *w) EV_THROW
 
 #if EV_CLEANUP_ENABLE
 void
-ev_cleanup_start (EV_P_ ev_cleanup *w) EV_THROW
+ev_cleanup_start (EV_P_ ev_cleanup *w) EV_NOEXCEPT
 {
-  if (expect_false (ev_is_active (w)))
+  if (ecb_expect_false (ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
 
   ev_start (EV_A_ (W)w, ++cleanupcnt);
-  array_needsize (ev_cleanup *, cleanups, cleanupmax, cleanupcnt, EMPTY2);
+  array_needsize (ev_cleanup *, cleanups, cleanupmax, cleanupcnt, array_needsize_noinit);
   cleanups [cleanupcnt - 1] = w;
 
   /* cleanup watchers should never keep a refcount on the loop */
@@ -4882,10 +5371,10 @@ ev_cleanup_start (EV_P_ ev_cleanup *w) EV_THROW
 }
 
 void
-ev_cleanup_stop (EV_P_ ev_cleanup *w) EV_THROW
+ev_cleanup_stop (EV_P_ ev_cleanup *w) EV_NOEXCEPT
 {
   clear_pending (EV_A_ (W)w);
-  if (expect_false (!ev_is_active (w)))
+  if (ecb_expect_false (!ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
@@ -4906,9 +5395,9 @@ ev_cleanup_stop (EV_P_ ev_cleanup *w) EV_THROW
 
 #if EV_ASYNC_ENABLE
 void
-ev_async_start (EV_P_ ev_async *w) EV_THROW
+ev_async_start (EV_P_ ev_async *w) EV_NOEXCEPT
 {
-  if (expect_false (ev_is_active (w)))
+  if (ecb_expect_false (ev_is_active (w)))
     return;
 
   w->sent = 0;
@@ -4918,17 +5407,17 @@ ev_async_start (EV_P_ ev_async *w) EV_THROW
   EV_FREQUENT_CHECK;
 
   ev_start (EV_A_ (W)w, ++asynccnt);
-  array_needsize (ev_async *, asyncs, asyncmax, asynccnt, EMPTY2);
+  array_needsize (ev_async *, asyncs, asyncmax, asynccnt, array_needsize_noinit);
   asyncs [asynccnt - 1] = w;
 
   EV_FREQUENT_CHECK;
 }
 
 void
-ev_async_stop (EV_P_ ev_async *w) EV_THROW
+ev_async_stop (EV_P_ ev_async *w) EV_NOEXCEPT
 {
   clear_pending (EV_A_ (W)w);
-  if (expect_false (!ev_is_active (w)))
+  if (ecb_expect_false (!ev_is_active (w)))
     return;
 
   EV_FREQUENT_CHECK;
@@ -4946,7 +5435,7 @@ ev_async_stop (EV_P_ ev_async *w) EV_THROW
 }
 
 void
-ev_async_send (EV_P_ ev_async *w) EV_THROW
+ev_async_send (EV_P_ ev_async *w) EV_NOEXCEPT
 {
   w->sent = 1;
   evpipe_write (EV_A_ &async_pending);
@@ -4993,16 +5482,10 @@ once_cb_to (EV_P_ ev_timer *w, int revents)
 }
 
 void
-ev_once (EV_P_ int fd, int events, ev_tstamp timeout, void (*cb)(int revents, void *arg), void *arg) EV_THROW
+ev_once (EV_P_ int fd, int events, ev_tstamp timeout, void (*cb)(int revents, void *arg), void *arg) EV_NOEXCEPT
 {
   struct ev_once *once = (struct ev_once *)ev_malloc (sizeof (struct ev_once));
 
-  if (expect_false (!once))
-    {
-      cb (EV_ERROR | EV_READ | EV_WRITE | EV_TIMER, arg);
-      return;
-    }
-
   once->cb  = cb;
   once->arg = arg;
 
@@ -5026,7 +5509,7 @@ ev_once (EV_P_ int fd, int events, ev_tstamp timeout, void (*cb)(int revents, vo
 #if EV_WALK_ENABLE
 ecb_cold
 void
-ev_walk (EV_P_ int types, void (*cb)(EV_P_ int type, void *w)) EV_THROW
+ev_walk (EV_P_ int types, void (*cb)(EV_P_ int type, void *w)) EV_NOEXCEPT
 {
   int i, j;
   ev_watcher_list *wl, *wn;
diff --git a/libev/ev.h b/libev/ev.h
index db93777..4669c39 100644
--- a/libev/ev.h
+++ b/libev/ev.h
@@ -1,7 +1,7 @@
 /*
  * libev native API header
  *
- * Copyright (c) 2007,2008,2009,2010,2011,2012,2015 Marc Alexander Lehmann <libev@schmorp.de>
+ * Copyright (c) 2007-2020 Marc Alexander Lehmann <libev@schmorp.de>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modifica-
@@ -43,14 +43,15 @@
 #ifdef __cplusplus
 # define EV_CPP(x) x
 # if __cplusplus >= 201103L
-#  define EV_THROW noexcept
+#  define EV_NOEXCEPT noexcept
 # else
-#  define EV_THROW throw ()
+#  define EV_NOEXCEPT
 # endif
 #else
 # define EV_CPP(x)
-# define EV_THROW
+# define EV_NOEXCEPT
 #endif
+#define EV_THROW EV_NOEXCEPT /* pre-4.25, do not use in new code */
 
 EV_CPP(extern "C" {)
 
@@ -150,7 +151,10 @@ EV_CPP(extern "C" {)
 
 /*****************************************************************************/
 
-typedef double ev_tstamp;
+#ifndef EV_TSTAMP_T
+# define EV_TSTAMP_T double
+#endif
+typedef EV_TSTAMP_T ev_tstamp;
 
 #include <string.h> /* for memmove */
 
@@ -211,7 +215,7 @@ struct ev_loop;
 /*****************************************************************************/
 
 #define EV_VERSION_MAJOR 4
-#define EV_VERSION_MINOR 24
+#define EV_VERSION_MINOR 33
 
 /* eventmask, revents, events... */
 enum {
@@ -339,7 +343,7 @@ typedef struct ev_periodic
 
   ev_tstamp offset; /* rw */
   ev_tstamp interval; /* rw */
-  ev_tstamp (*reschedule_cb)(struct ev_periodic *w, ev_tstamp now) EV_THROW; /* rw */
+  ev_tstamp (*reschedule_cb)(struct ev_periodic *w, ev_tstamp now) EV_NOEXCEPT; /* rw */
 } ev_periodic;
 
 /* invoked when the given signal has been received */
@@ -388,14 +392,12 @@ typedef struct ev_stat
 } ev_stat;
 #endif
 
-#if EV_IDLE_ENABLE
 /* invoked when the nothing else needs to be done, keeps the process from blocking */
 /* revent EV_IDLE */
 typedef struct ev_idle
 {
   EV_WATCHER (ev_idle)
 } ev_idle;
-#endif
 
 /* invoked for each run of the mainloop, just before the blocking call */
 /* you can still change events in any way you like */
@@ -412,23 +414,19 @@ typedef struct ev_check
   EV_WATCHER (ev_check)
 } ev_check;
 
-#if EV_FORK_ENABLE
 /* the callback gets invoked before check in the child process when a fork was detected */
 /* revent EV_FORK */
 typedef struct ev_fork
 {
   EV_WATCHER (ev_fork)
 } ev_fork;
-#endif
 
-#if EV_CLEANUP_ENABLE
 /* is invoked just before the loop gets destroyed */
 /* revent EV_CLEANUP */
 typedef struct ev_cleanup
 {
   EV_WATCHER (ev_cleanup)
 } ev_cleanup;
-#endif
 
 #if EV_EMBED_ENABLE
 /* used to embed an event loop inside another */
@@ -438,16 +436,18 @@ typedef struct ev_embed
   EV_WATCHER (ev_embed)
 
   struct ev_loop *other; /* ro */
+#undef EV_IO_ENABLE
+#define EV_IO_ENABLE 1
   ev_io io;              /* private */
+#undef EV_PREPARE_ENABLE
+#define EV_PREPARE_ENABLE 1
   ev_prepare prepare;    /* private */
   ev_check check;        /* unused */
   ev_timer timer;        /* unused */
   ev_periodic periodic;  /* unused */
   ev_idle idle;          /* unused */
   ev_fork fork;          /* private */
-#if EV_CLEANUP_ENABLE
   ev_cleanup cleanup;    /* unused */
-#endif
 } ev_embed;
 #endif
 
@@ -500,41 +500,44 @@ union ev_any_watcher
 /* flag bits for ev_default_loop and ev_loop_new */
 enum {
   /* the default */
-  EVFLAG_AUTO      = 0x00000000U, /* not quite a mask */
+  EVFLAG_AUTO       = 0x00000000U, /* not quite a mask */
   /* flag bits */
-  EVFLAG_NOENV     = 0x01000000U, /* do NOT consult environment */
-  EVFLAG_FORKCHECK = 0x02000000U, /* check for a fork in each iteration */
+  EVFLAG_NOENV      = 0x01000000U, /* do NOT consult environment */
+  EVFLAG_FORKCHECK  = 0x02000000U, /* check for a fork in each iteration */
   /* debugging/feature disable */
-  EVFLAG_NOINOTIFY = 0x00100000U, /* do not attempt to use inotify */
+  EVFLAG_NOINOTIFY  = 0x00100000U, /* do not attempt to use inotify */
 #if EV_COMPAT3
-  EVFLAG_NOSIGFD   = 0, /* compatibility to pre-3.9 */
+  EVFLAG_NOSIGFD    = 0, /* compatibility to pre-3.9 */
 #endif
-  EVFLAG_SIGNALFD  = 0x00200000U, /* attempt to use signalfd */
-  EVFLAG_NOSIGMASK = 0x00400000U  /* avoid modifying the signal mask */
+  EVFLAG_SIGNALFD   = 0x00200000U, /* attempt to use signalfd */
+  EVFLAG_NOSIGMASK  = 0x00400000U, /* avoid modifying the signal mask */
+  EVFLAG_NOTIMERFD  = 0x00800000U  /* avoid creating a timerfd */
 };
 
 /* method bits to be ored together */
 enum {
-  EVBACKEND_SELECT  = 0x00000001U, /* available just about anywhere */
-  EVBACKEND_POLL    = 0x00000002U, /* !win, !aix, broken on osx */
-  EVBACKEND_EPOLL   = 0x00000004U, /* linux */
-  EVBACKEND_KQUEUE  = 0x00000008U, /* bsd, broken on osx */
-  EVBACKEND_DEVPOLL = 0x00000010U, /* solaris 8 */ /* NYI */
-  EVBACKEND_PORT    = 0x00000020U, /* solaris 10 */
-  EVBACKEND_ALL     = 0x0000003FU, /* all known backends */
-  EVBACKEND_MASK    = 0x0000FFFFU  /* all future backends */
+  EVBACKEND_SELECT   = 0x00000001U, /* available just about anywhere */
+  EVBACKEND_POLL     = 0x00000002U, /* !win, !aix, broken on osx */
+  EVBACKEND_EPOLL    = 0x00000004U, /* linux */
+  EVBACKEND_KQUEUE   = 0x00000008U, /* bsd, broken on osx */
+  EVBACKEND_DEVPOLL  = 0x00000010U, /* solaris 8 */ /* NYI */
+  EVBACKEND_PORT     = 0x00000020U, /* solaris 10 */
+  EVBACKEND_LINUXAIO = 0x00000040U, /* linux AIO, 4.19+ */
+  EVBACKEND_IOURING  = 0x00000080U, /* linux io_uring, 5.1+ */
+  EVBACKEND_ALL      = 0x000000FFU, /* all known backends */
+  EVBACKEND_MASK     = 0x0000FFFFU  /* all future backends */
 };
 
 #if EV_PROTOTYPES
-EV_API_DECL int ev_version_major (void) EV_THROW;
-EV_API_DECL int ev_version_minor (void) EV_THROW;
+EV_API_DECL int ev_version_major (void) EV_NOEXCEPT;
+EV_API_DECL int ev_version_minor (void) EV_NOEXCEPT;
 
-EV_API_DECL unsigned int ev_supported_backends (void) EV_THROW;
-EV_API_DECL unsigned int ev_recommended_backends (void) EV_THROW;
-EV_API_DECL unsigned int ev_embeddable_backends (void) EV_THROW;
+EV_API_DECL unsigned int ev_supported_backends (void) EV_NOEXCEPT;
+EV_API_DECL unsigned int ev_recommended_backends (void) EV_NOEXCEPT;
+EV_API_DECL unsigned int ev_embeddable_backends (void) EV_NOEXCEPT;
 
-EV_API_DECL ev_tstamp ev_time (void) EV_THROW;
-EV_API_DECL void ev_sleep (ev_tstamp delay) EV_THROW; /* sleep for a while */
+EV_API_DECL ev_tstamp ev_time (void) EV_NOEXCEPT;
+EV_API_DECL void ev_sleep (ev_tstamp delay) EV_NOEXCEPT; /* sleep for a while */
 
 /* Sets the allocation function to use, works like realloc.
  * It is used to allocate and free memory.
@@ -542,26 +545,26 @@ EV_API_DECL void ev_sleep (ev_tstamp delay) EV_THROW; /* sleep for a while */
  * or take some potentially destructive action.
  * The default is your system realloc function.
  */
-EV_API_DECL void ev_set_allocator (void *(*cb)(void *ptr, long size) EV_THROW) EV_THROW;
+EV_API_DECL void ev_set_allocator (void *(*cb)(void *ptr, long size) EV_NOEXCEPT) EV_NOEXCEPT;
 
 /* set the callback function to call on a
  * retryable syscall error
  * (such as failed select, poll, epoll_wait)
  */
-EV_API_DECL void ev_set_syserr_cb (void (*cb)(const char *msg) EV_THROW) EV_THROW;
+EV_API_DECL void ev_set_syserr_cb (void (*cb)(const char *msg) EV_NOEXCEPT) EV_NOEXCEPT;
 
 #if EV_MULTIPLICITY
 
 /* the default loop is the only one that handles signals and child watchers */
 /* you can call this as often as you like */
-EV_API_DECL struct ev_loop *ev_default_loop (unsigned int flags EV_CPP (= 0)) EV_THROW;
+EV_API_DECL struct ev_loop *ev_default_loop (unsigned int flags EV_CPP (= 0)) EV_NOEXCEPT;
 
 #ifdef EV_API_STATIC
 EV_API_DECL struct ev_loop *ev_default_loop_ptr;
 #endif
 
 EV_INLINE struct ev_loop *
-ev_default_loop_uc_ (void) EV_THROW
+ev_default_loop_uc_ (void) EV_NOEXCEPT
 {
   extern struct ev_loop *ev_default_loop_ptr;
 
@@ -569,31 +572,31 @@ ev_default_loop_uc_ (void) EV_THROW
 }
 
 EV_INLINE int
-ev_is_default_loop (EV_P) EV_THROW
+ev_is_default_loop (EV_P) EV_NOEXCEPT
 {
   return EV_A == EV_DEFAULT_UC;
 }
 
 /* create and destroy alternative loops that don't handle signals */
-EV_API_DECL struct ev_loop *ev_loop_new (unsigned int flags EV_CPP (= 0)) EV_THROW;
+EV_API_DECL struct ev_loop *ev_loop_new (unsigned int flags EV_CPP (= 0)) EV_NOEXCEPT;
 
-EV_API_DECL ev_tstamp ev_now (EV_P) EV_THROW; /* time w.r.t. timers and the eventloop, updated after each poll */
+EV_API_DECL ev_tstamp ev_now (EV_P) EV_NOEXCEPT; /* time w.r.t. timers and the eventloop, updated after each poll */
 
 #else
 
-EV_API_DECL int ev_default_loop (unsigned int flags EV_CPP (= 0)) EV_THROW; /* returns true when successful */
+EV_API_DECL int ev_default_loop (unsigned int flags EV_CPP (= 0)) EV_NOEXCEPT; /* returns true when successful */
 
 EV_API_DECL ev_tstamp ev_rt_now;
 
 EV_INLINE ev_tstamp
-ev_now (void) EV_THROW
+ev_now (void) EV_NOEXCEPT
 {
   return ev_rt_now;
 }
 
 /* looks weird, but ev_is_default_loop (EV_A) still works if this exists */
 EV_INLINE int
-ev_is_default_loop (void) EV_THROW
+ev_is_default_loop (void) EV_NOEXCEPT
 {
   return 1;
 }
@@ -607,17 +610,17 @@ EV_API_DECL void ev_loop_destroy (EV_P);
 /* when you want to re-use it in the child */
 /* you can call it in either the parent or the child */
 /* you can actually call it at any time, anywhere :) */
-EV_API_DECL void ev_loop_fork (EV_P) EV_THROW;
+EV_API_DECL void ev_loop_fork (EV_P) EV_NOEXCEPT;
 
-EV_API_DECL unsigned int ev_backend (EV_P) EV_THROW; /* backend in use by loop */
+EV_API_DECL unsigned int ev_backend (EV_P) EV_NOEXCEPT; /* backend in use by loop */
 
-EV_API_DECL void ev_now_update (EV_P) EV_THROW; /* update event loop time */
+EV_API_DECL void ev_now_update (EV_P) EV_NOEXCEPT; /* update event loop time */
 
 #if EV_WALK_ENABLE
 /* walk (almost) all watchers in the loop of a given type, invoking the */
 /* callback on every such watcher. The callback might stop the watcher, */
 /* but do nothing else with the loop */
-EV_API_DECL void ev_walk (EV_P_ int types, void (*cb)(EV_P_ int type, void *w)) EV_THROW;
+EV_API_DECL void ev_walk (EV_P_ int types, void (*cb)(EV_P_ int type, void *w)) EV_NOEXCEPT;
 #endif
 
 #endif /* prototypes */
@@ -637,46 +640,47 @@ enum {
 
 #if EV_PROTOTYPES
 EV_API_DECL int  ev_run (EV_P_ int flags EV_CPP (= 0));
-EV_API_DECL void ev_break (EV_P_ int how EV_CPP (= EVBREAK_ONE)) EV_THROW; /* break out of the loop */
+EV_API_DECL void ev_break (EV_P_ int how EV_CPP (= EVBREAK_ONE)) EV_NOEXCEPT; /* break out of the loop */
 
 /*
  * ref/unref can be used to add or remove a refcount on the mainloop. every watcher
  * keeps one reference. if you have a long-running watcher you never unregister that
  * should not keep ev_loop from running, unref() after starting, and ref() before stopping.
  */
-EV_API_DECL void ev_ref   (EV_P) EV_THROW;
-EV_API_DECL void ev_unref (EV_P) EV_THROW;
+EV_API_DECL void ev_ref   (EV_P) EV_NOEXCEPT;
+EV_API_DECL void ev_unref (EV_P) EV_NOEXCEPT;
 
 /*
  * convenience function, wait for a single event, without registering an event watcher
  * if timeout is < 0, do wait indefinitely
  */
-EV_API_DECL void ev_once (EV_P_ int fd, int events, ev_tstamp timeout, void (*cb)(int revents, void *arg), void *arg) EV_THROW;
+EV_API_DECL void ev_once (EV_P_ int fd, int events, ev_tstamp timeout, void (*cb)(int revents, void *arg), void *arg) EV_NOEXCEPT;
+
+EV_API_DECL void ev_invoke_pending (EV_P); /* invoke all pending watchers */
 
 # if EV_FEATURE_API
-EV_API_DECL unsigned int ev_iteration (EV_P) EV_THROW; /* number of loop iterations */
-EV_API_DECL unsigned int ev_depth     (EV_P) EV_THROW; /* #ev_loop enters - #ev_loop leaves */
-EV_API_DECL void         ev_verify    (EV_P) EV_THROW; /* abort if loop data corrupted */
+EV_API_DECL unsigned int ev_iteration (EV_P) EV_NOEXCEPT; /* number of loop iterations */
+EV_API_DECL unsigned int ev_depth     (EV_P) EV_NOEXCEPT; /* #ev_loop enters - #ev_loop leaves */
+EV_API_DECL void         ev_verify    (EV_P) EV_NOEXCEPT; /* abort if loop data corrupted */
 
-EV_API_DECL void ev_set_io_collect_interval (EV_P_ ev_tstamp interval) EV_THROW; /* sleep at least this time, default 0 */
-EV_API_DECL void ev_set_timeout_collect_interval (EV_P_ ev_tstamp interval) EV_THROW; /* sleep at least this time, default 0 */
+EV_API_DECL void ev_set_io_collect_interval (EV_P_ ev_tstamp interval) EV_NOEXCEPT; /* sleep at least this time, default 0 */
+EV_API_DECL void ev_set_timeout_collect_interval (EV_P_ ev_tstamp interval) EV_NOEXCEPT; /* sleep at least this time, default 0 */
 
 /* advanced stuff for threading etc. support, see docs */
-EV_API_DECL void ev_set_userdata (EV_P_ void *data) EV_THROW;
-EV_API_DECL void *ev_userdata (EV_P) EV_THROW;
+EV_API_DECL void ev_set_userdata (EV_P_ void *data) EV_NOEXCEPT;
+EV_API_DECL void *ev_userdata (EV_P) EV_NOEXCEPT;
 typedef void (*ev_loop_callback)(EV_P);
-EV_API_DECL void ev_set_invoke_pending_cb (EV_P_ ev_loop_callback invoke_pending_cb) EV_THROW;
+EV_API_DECL void ev_set_invoke_pending_cb (EV_P_ ev_loop_callback invoke_pending_cb) EV_NOEXCEPT;
 /* C++ doesn't allow the use of the ev_loop_callback typedef here, so we need to spell it out */
-EV_API_DECL void ev_set_loop_release_cb (EV_P_ void (*release)(EV_P) EV_THROW, void (*acquire)(EV_P) EV_THROW) EV_THROW;
+EV_API_DECL void ev_set_loop_release_cb (EV_P_ void (*release)(EV_P) EV_NOEXCEPT, void (*acquire)(EV_P) EV_NOEXCEPT) EV_NOEXCEPT;
 
-EV_API_DECL unsigned int ev_pending_count (EV_P) EV_THROW; /* number of pending events, if any */
-EV_API_DECL void ev_invoke_pending (EV_P); /* invoke all pending watchers */
+EV_API_DECL unsigned int ev_pending_count (EV_P) EV_NOEXCEPT; /* number of pending events, if any */
 
 /*
  * stop/start the timer handling.
  */
-EV_API_DECL void ev_suspend (EV_P) EV_THROW;
-EV_API_DECL void ev_resume  (EV_P) EV_THROW;
+EV_API_DECL void ev_suspend (EV_P) EV_NOEXCEPT;
+EV_API_DECL void ev_resume  (EV_P) EV_NOEXCEPT;
 #endif
 
 #endif
@@ -690,6 +694,7 @@ EV_API_DECL void ev_resume  (EV_P) EV_THROW;
   ev_set_cb ((ev), cb_);			\
 } while (0)
 
+#define ev_io_modify(ev,events_)             do { (ev)->events = (ev)->events & EV__IOFDSET | (events_); } while (0)
 #define ev_io_set(ev,fd_,events_)            do { (ev)->fd = (fd_); (ev)->events = (events_) | EV__IOFDSET; } while (0)
 #define ev_timer_set(ev,after_,repeat_)      do { ((ev_watcher_time *)(ev))->at = (after_); (ev)->repeat = (repeat_); } while (0)
 #define ev_periodic_set(ev,ofs_,ival_,rcb_)  do { (ev)->offset = (ofs_); (ev)->interval = (ival_); (ev)->reschedule_cb = (rcb_); } while (0)
@@ -735,6 +740,7 @@ EV_API_DECL void ev_resume  (EV_P) EV_THROW;
 #define ev_periodic_at(ev)                   (+((ev_watcher_time *)(ev))->at)
 
 #ifndef ev_set_cb
+/* memmove is used here to avoid strict aliasing violations, and hopefully is optimized out by any reasonable compiler */
 # define ev_set_cb(ev,cb_)                   (ev_cb_ (ev) = (cb_), memmove (&((ev_watcher *)(ev))->cb, &ev_cb_ (ev), sizeof (ev_cb_ (ev))))
 #endif
 
@@ -744,85 +750,85 @@ EV_API_DECL void ev_resume  (EV_P) EV_THROW;
 
 /* feeds an event into a watcher as if the event actually occurred */
 /* accepts any ev_watcher type */
-EV_API_DECL void ev_feed_event     (EV_P_ void *w, int revents) EV_THROW;
-EV_API_DECL void ev_feed_fd_event  (EV_P_ int fd, int revents) EV_THROW;
+EV_API_DECL void ev_feed_event     (EV_P_ void *w, int revents) EV_NOEXCEPT;
+EV_API_DECL void ev_feed_fd_event  (EV_P_ int fd, int revents) EV_NOEXCEPT;
 #if EV_SIGNAL_ENABLE
-EV_API_DECL void ev_feed_signal    (int signum) EV_THROW;
-EV_API_DECL void ev_feed_signal_event (EV_P_ int signum) EV_THROW;
+EV_API_DECL void ev_feed_signal    (int signum) EV_NOEXCEPT;
+EV_API_DECL void ev_feed_signal_event (EV_P_ int signum) EV_NOEXCEPT;
 #endif
 EV_API_DECL void ev_invoke         (EV_P_ void *w, int revents);
-EV_API_DECL int  ev_clear_pending  (EV_P_ void *w) EV_THROW;
+EV_API_DECL int  ev_clear_pending  (EV_P_ void *w) EV_NOEXCEPT;
 
-EV_API_DECL void ev_io_start       (EV_P_ ev_io *w) EV_THROW;
-EV_API_DECL void ev_io_stop        (EV_P_ ev_io *w) EV_THROW;
+EV_API_DECL void ev_io_start       (EV_P_ ev_io *w) EV_NOEXCEPT;
+EV_API_DECL void ev_io_stop        (EV_P_ ev_io *w) EV_NOEXCEPT;
 
-EV_API_DECL void ev_timer_start    (EV_P_ ev_timer *w) EV_THROW;
-EV_API_DECL void ev_timer_stop     (EV_P_ ev_timer *w) EV_THROW;
+EV_API_DECL void ev_timer_start    (EV_P_ ev_timer *w) EV_NOEXCEPT;
+EV_API_DECL void ev_timer_stop     (EV_P_ ev_timer *w) EV_NOEXCEPT;
 /* stops if active and no repeat, restarts if active and repeating, starts if inactive and repeating */
-EV_API_DECL void ev_timer_again    (EV_P_ ev_timer *w) EV_THROW;
+EV_API_DECL void ev_timer_again    (EV_P_ ev_timer *w) EV_NOEXCEPT;
 /* return remaining time */
-EV_API_DECL ev_tstamp ev_timer_remaining (EV_P_ ev_timer *w) EV_THROW;
+EV_API_DECL ev_tstamp ev_timer_remaining (EV_P_ ev_timer *w) EV_NOEXCEPT;
 
 #if EV_PERIODIC_ENABLE
-EV_API_DECL void ev_periodic_start (EV_P_ ev_periodic *w) EV_THROW;
-EV_API_DECL void ev_periodic_stop  (EV_P_ ev_periodic *w) EV_THROW;
-EV_API_DECL void ev_periodic_again (EV_P_ ev_periodic *w) EV_THROW;
+EV_API_DECL void ev_periodic_start (EV_P_ ev_periodic *w) EV_NOEXCEPT;
+EV_API_DECL void ev_periodic_stop  (EV_P_ ev_periodic *w) EV_NOEXCEPT;
+EV_API_DECL void ev_periodic_again (EV_P_ ev_periodic *w) EV_NOEXCEPT;
 #endif
 
 /* only supported in the default loop */
 #if EV_SIGNAL_ENABLE
-EV_API_DECL void ev_signal_start   (EV_P_ ev_signal *w) EV_THROW;
-EV_API_DECL void ev_signal_stop    (EV_P_ ev_signal *w) EV_THROW;
+EV_API_DECL void ev_signal_start   (EV_P_ ev_signal *w) EV_NOEXCEPT;
+EV_API_DECL void ev_signal_stop    (EV_P_ ev_signal *w) EV_NOEXCEPT;
 #endif
 
 /* only supported in the default loop */
 # if EV_CHILD_ENABLE
-EV_API_DECL void ev_child_start    (EV_P_ ev_child *w) EV_THROW;
-EV_API_DECL void ev_child_stop     (EV_P_ ev_child *w) EV_THROW;
+EV_API_DECL void ev_child_start    (EV_P_ ev_child *w) EV_NOEXCEPT;
+EV_API_DECL void ev_child_stop     (EV_P_ ev_child *w) EV_NOEXCEPT;
 # endif
 
 # if EV_STAT_ENABLE
-EV_API_DECL void ev_stat_start     (EV_P_ ev_stat *w) EV_THROW;
-EV_API_DECL void ev_stat_stop      (EV_P_ ev_stat *w) EV_THROW;
-EV_API_DECL void ev_stat_stat      (EV_P_ ev_stat *w) EV_THROW;
+EV_API_DECL void ev_stat_start     (EV_P_ ev_stat *w) EV_NOEXCEPT;
+EV_API_DECL void ev_stat_stop      (EV_P_ ev_stat *w) EV_NOEXCEPT;
+EV_API_DECL void ev_stat_stat      (EV_P_ ev_stat *w) EV_NOEXCEPT;
 # endif
 
 # if EV_IDLE_ENABLE
-EV_API_DECL void ev_idle_start     (EV_P_ ev_idle *w) EV_THROW;
-EV_API_DECL void ev_idle_stop      (EV_P_ ev_idle *w) EV_THROW;
+EV_API_DECL void ev_idle_start     (EV_P_ ev_idle *w) EV_NOEXCEPT;
+EV_API_DECL void ev_idle_stop      (EV_P_ ev_idle *w) EV_NOEXCEPT;
 # endif
 
 #if EV_PREPARE_ENABLE
-EV_API_DECL void ev_prepare_start  (EV_P_ ev_prepare *w) EV_THROW;
-EV_API_DECL void ev_prepare_stop   (EV_P_ ev_prepare *w) EV_THROW;
+EV_API_DECL void ev_prepare_start  (EV_P_ ev_prepare *w) EV_NOEXCEPT;
+EV_API_DECL void ev_prepare_stop   (EV_P_ ev_prepare *w) EV_NOEXCEPT;
 #endif
 
 #if EV_CHECK_ENABLE
-EV_API_DECL void ev_check_start    (EV_P_ ev_check *w) EV_THROW;
-EV_API_DECL void ev_check_stop     (EV_P_ ev_check *w) EV_THROW;
+EV_API_DECL void ev_check_start    (EV_P_ ev_check *w) EV_NOEXCEPT;
+EV_API_DECL void ev_check_stop     (EV_P_ ev_check *w) EV_NOEXCEPT;
 #endif
 
 # if EV_FORK_ENABLE
-EV_API_DECL void ev_fork_start     (EV_P_ ev_fork *w) EV_THROW;
-EV_API_DECL void ev_fork_stop      (EV_P_ ev_fork *w) EV_THROW;
+EV_API_DECL void ev_fork_start     (EV_P_ ev_fork *w) EV_NOEXCEPT;
+EV_API_DECL void ev_fork_stop      (EV_P_ ev_fork *w) EV_NOEXCEPT;
 # endif
 
 # if EV_CLEANUP_ENABLE
-EV_API_DECL void ev_cleanup_start  (EV_P_ ev_cleanup *w) EV_THROW;
-EV_API_DECL void ev_cleanup_stop   (EV_P_ ev_cleanup *w) EV_THROW;
+EV_API_DECL void ev_cleanup_start  (EV_P_ ev_cleanup *w) EV_NOEXCEPT;
+EV_API_DECL void ev_cleanup_stop   (EV_P_ ev_cleanup *w) EV_NOEXCEPT;
 # endif
 
 # if EV_EMBED_ENABLE
 /* only supported when loop to be embedded is in fact embeddable */
-EV_API_DECL void ev_embed_start    (EV_P_ ev_embed *w) EV_THROW;
-EV_API_DECL void ev_embed_stop     (EV_P_ ev_embed *w) EV_THROW;
-EV_API_DECL void ev_embed_sweep    (EV_P_ ev_embed *w) EV_THROW;
+EV_API_DECL void ev_embed_start    (EV_P_ ev_embed *w) EV_NOEXCEPT;
+EV_API_DECL void ev_embed_stop     (EV_P_ ev_embed *w) EV_NOEXCEPT;
+EV_API_DECL void ev_embed_sweep    (EV_P_ ev_embed *w) EV_NOEXCEPT;
 # endif
 
 # if EV_ASYNC_ENABLE
-EV_API_DECL void ev_async_start    (EV_P_ ev_async *w) EV_THROW;
-EV_API_DECL void ev_async_stop     (EV_P_ ev_async *w) EV_THROW;
-EV_API_DECL void ev_async_send     (EV_P_ ev_async *w) EV_THROW;
+EV_API_DECL void ev_async_start    (EV_P_ ev_async *w) EV_NOEXCEPT;
+EV_API_DECL void ev_async_stop     (EV_P_ ev_async *w) EV_NOEXCEPT;
+EV_API_DECL void ev_async_send     (EV_P_ ev_async *w) EV_NOEXCEPT;
 # endif
 
 #if EV_COMPAT3
diff --git a/libev/ev.pod b/libev/ev.pod
deleted file mode 100644
index 429fe58..0000000
--- a/libev/ev.pod
+++ /dev/null
@@ -1,5570 +0,0 @@
-=encoding utf-8
-
-=head1 NAME
-
-libev - a high performance full-featured event loop written in C
-
-=head1 SYNOPSIS
-
-   #include <ev.h>
-
-=head2 EXAMPLE PROGRAM
-
-   // a single header file is required
-   #include <ev.h>
-
-   #include <stdio.h> // for puts
-
-   // every watcher type has its own typedef'd struct
-   // with the name ev_TYPE
-   ev_io stdin_watcher;
-   ev_timer timeout_watcher;
-
-   // all watcher callbacks have a similar signature
-   // this callback is called when data is readable on stdin
-   static void
-   stdin_cb (EV_P_ ev_io *w, int revents)
-   {
-     puts ("stdin ready");
-     // for one-shot events, one must manually stop the watcher
-     // with its corresponding stop function.
-     ev_io_stop (EV_A_ w);
-
-     // this causes all nested ev_run's to stop iterating
-     ev_break (EV_A_ EVBREAK_ALL);
-   }
-
-   // another callback, this time for a time-out
-   static void
-   timeout_cb (EV_P_ ev_timer *w, int revents)
-   {
-     puts ("timeout");
-     // this causes the innermost ev_run to stop iterating
-     ev_break (EV_A_ EVBREAK_ONE);
-   }
-
-   int
-   main (void)
-   {
-     // use the default event loop unless you have special needs
-     struct ev_loop *loop = EV_DEFAULT;
-
-     // initialise an io watcher, then start it
-     // this one will watch for stdin to become readable
-     ev_io_init (&stdin_watcher, stdin_cb, /*STDIN_FILENO*/ 0, EV_READ);
-     ev_io_start (loop, &stdin_watcher);
-
-     // initialise a timer watcher, then start it
-     // simple non-repeating 5.5 second timeout
-     ev_timer_init (&timeout_watcher, timeout_cb, 5.5, 0.);
-     ev_timer_start (loop, &timeout_watcher);
-
-     // now wait for events to arrive
-     ev_run (loop, 0);
-
-     // break was called, so exit
-     return 0;
-   }
-
-=head1 ABOUT THIS DOCUMENT
-
-This document documents the libev software package.
-
-The newest version of this document is also available as an html-formatted
-web page you might find easier to navigate when reading it for the first
-time: L<http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod>.
-
-While this document tries to be as complete as possible in documenting
-libev, its usage and the rationale behind its design, it is not a tutorial
-on event-based programming, nor will it introduce event-based programming
-with libev.
-
-Familiarity with event based programming techniques in general is assumed
-throughout this document.
-
-=head1 WHAT TO READ WHEN IN A HURRY
-
-This manual tries to be very detailed, but unfortunately, this also makes
-it very long. If you just want to know the basics of libev, I suggest
-reading L</ANATOMY OF A WATCHER>, then the L</EXAMPLE PROGRAM> above and
-look up the missing functions in L</GLOBAL FUNCTIONS> and the C<ev_io> and
-C<ev_timer> sections in L</WATCHER TYPES>.
-
-=head1 ABOUT LIBEV
-
-Libev is an event loop: you register interest in certain events (such as a
-file descriptor being readable or a timeout occurring), and it will manage
-these event sources and provide your program with events.
-
-To do this, it must take more or less complete control over your process
-(or thread) by executing the I<event loop> handler, and will then
-communicate events via a callback mechanism.
-
-You register interest in certain events by registering so-called I<event
-watchers>, which are relatively small C structures you initialise with the
-details of the event, and then hand it over to libev by I<starting> the
-watcher.
-
-=head2 FEATURES
-
-Libev supports C<select>, C<poll>, the Linux-specific C<epoll>, the
-BSD-specific C<kqueue> and the Solaris-specific event port mechanisms
-for file descriptor events (C<ev_io>), the Linux C<inotify> interface
-(for C<ev_stat>), Linux eventfd/signalfd (for faster and cleaner
-inter-thread wakeup (C<ev_async>)/signal handling (C<ev_signal>)) relative
-timers (C<ev_timer>), absolute timers with customised rescheduling
-(C<ev_periodic>), synchronous signals (C<ev_signal>), process status
-change events (C<ev_child>), and event watchers dealing with the event
-loop mechanism itself (C<ev_idle>, C<ev_embed>, C<ev_prepare> and
-C<ev_check> watchers) as well as file watchers (C<ev_stat>) and even
-limited support for fork events (C<ev_fork>).
-
-It also is quite fast (see this
-L<benchmark|http://libev.schmorp.de/bench.html> comparing it to libevent
-for example).
-
-=head2 CONVENTIONS
-
-Libev is very configurable. In this manual the default (and most common)
-configuration will be described, which supports multiple event loops. For
-more info about various configuration options please have a look at
-B<EMBED> section in this manual. If libev was configured without support
-for multiple event loops, then all functions taking an initial argument of
-name C<loop> (which is always of type C<struct ev_loop *>) will not have
-this argument.
-
-=head2 TIME REPRESENTATION
-
-Libev represents time as a single floating point number, representing
-the (fractional) number of seconds since the (POSIX) epoch (in practice
-somewhere near the beginning of 1970, details are complicated, don't
-ask). This type is called C<ev_tstamp>, which is what you should use
-too. It usually aliases to the C<double> type in C. When you need to do
-any calculations on it, you should treat it as some floating point value.
-
-Unlike the name component C<stamp> might indicate, it is also used for
-time differences (e.g. delays) throughout libev.
-
-=head1 ERROR HANDLING
-
-Libev knows three classes of errors: operating system errors, usage errors
-and internal errors (bugs).
-
-When libev catches an operating system error it cannot handle (for example
-a system call indicating a condition libev cannot fix), it calls the callback
-set via C<ev_set_syserr_cb>, which is supposed to fix the problem or
-abort. The default is to print a diagnostic message and to call C<abort
-()>.
-
-When libev detects a usage error such as a negative timer interval, then
-it will print a diagnostic message and abort (via the C<assert> mechanism,
-so C<NDEBUG> will disable this checking): these are programming errors in
-the libev caller and need to be fixed there.
-
-Libev also has a few internal error-checking C<assert>ions, and also has
-extensive consistency checking code. These do not trigger under normal
-circumstances, as they indicate either a bug in libev or worse.
-
-
-=head1 GLOBAL FUNCTIONS
-
-These functions can be called anytime, even before initialising the
-library in any way.
-
-=over 4
-
-=item ev_tstamp ev_time ()
-
-Returns the current time as libev would use it. Please note that the
-C<ev_now> function is usually faster and also often returns the timestamp
-you actually want to know. Also interesting is the combination of
-C<ev_now_update> and C<ev_now>.
-
-=item ev_sleep (ev_tstamp interval)
-
-Sleep for the given interval: The current thread will be blocked
-until either it is interrupted or the given time interval has
-passed (approximately - it might return a bit earlier even if not
-interrupted). Returns immediately if C<< interval <= 0 >>.
-
-Basically this is a sub-second-resolution C<sleep ()>.
-
-The range of the C<interval> is limited - libev only guarantees to work
-with sleep times of up to one day (C<< interval <= 86400 >>).
-
-=item int ev_version_major ()
-
-=item int ev_version_minor ()
-
-You can find out the major and minor ABI version numbers of the library
-you linked against by calling the functions C<ev_version_major> and
-C<ev_version_minor>. If you want, you can compare against the global
-symbols C<EV_VERSION_MAJOR> and C<EV_VERSION_MINOR>, which specify the
-version of the library your program was compiled against.
-
-These version numbers refer to the ABI version of the library, not the
-release version.
-
-Usually, it's a good idea to terminate if the major versions mismatch,
-as this indicates an incompatible change. Minor versions are usually
-compatible to older versions, so a larger minor version alone is usually
-not a problem.
-
-Example: Make sure we haven't accidentally been linked against the wrong
-version (note, however, that this will not detect other ABI mismatches,
-such as LFS or reentrancy).
-
-   assert (("libev version mismatch",
-            ev_version_major () == EV_VERSION_MAJOR
-            && ev_version_minor () >= EV_VERSION_MINOR));
-
-=item unsigned int ev_supported_backends ()
-
-Return the set of all backends (i.e. their corresponding C<EV_BACKEND_*>
-value) compiled into this binary of libev (independent of their
-availability on the system you are running on). See C<ev_default_loop> for
-a description of the set values.
-
-Example: make sure we have the epoll method, because yeah this is cool and
-a must have and can we have a torrent of it please!!!11
-
-   assert (("sorry, no epoll, no sex",
-            ev_supported_backends () & EVBACKEND_EPOLL));
-
-=item unsigned int ev_recommended_backends ()
-
-Return the set of all backends compiled into this binary of libev and
-also recommended for this platform, meaning it will work for most file
-descriptor types. This set is often smaller than the one returned by
-C<ev_supported_backends>, as for example kqueue is broken on most BSDs
-and will not be auto-detected unless you explicitly request it (assuming
-you know what you are doing). This is the set of backends that libev will
-probe for if you specify no backends explicitly.
-
-=item unsigned int ev_embeddable_backends ()
-
-Returns the set of backends that are embeddable in other event loops. This
-value is platform-specific but can include backends not available on the
-current system. To find which embeddable backends might be supported on
-the current system, you would need to look at C<ev_embeddable_backends ()
-& ev_supported_backends ()>, likewise for recommended ones.
-
-See the description of C<ev_embed> watchers for more info.
-
-=item ev_set_allocator (void *(*cb)(void *ptr, long size) throw ())
-
-Sets the allocation function to use (the prototype is similar - the
-semantics are identical to the C<realloc> C89/SuS/POSIX function). It is
-used to allocate and free memory (no surprises here). If it returns zero
-when memory needs to be allocated (C<size != 0>), the library might abort
-or take some potentially destructive action.
-
-Since some systems (at least OpenBSD and Darwin) fail to implement
-correct C<realloc> semantics, libev will use a wrapper around the system
-C<realloc> and C<free> functions by default.
-
-You could override this function in high-availability programs to, say,
-free some memory if it cannot allocate memory, to use a special allocator,
-or even to sleep a while and retry until some memory is available.
-
-Example: Replace the libev allocator with one that waits a bit and then
-retries (example requires a standards-compliant C<realloc>).
-
-   static void *
-   persistent_realloc (void *ptr, size_t size)
-   {
-     for (;;)
-       {
-         void *newptr = realloc (ptr, size);
-
-         if (newptr)
-           return newptr;
-
-         sleep (60);
-       }
-   }
-
-   ...
-   ev_set_allocator (persistent_realloc);
-
-=item ev_set_syserr_cb (void (*cb)(const char *msg) throw ())
-
-Set the callback function to call on a retryable system call error (such
-as failed select, poll, epoll_wait). The message is a printable string
-indicating the system call or subsystem causing the problem. If this
-callback is set, then libev will expect it to remedy the situation, no
-matter what, when it returns. That is, libev will generally retry the
-requested operation, or, if the condition doesn't go away, do bad stuff
-(such as abort).
-
-Example: This is basically the same thing that libev does internally, too.
-
-   static void
-   fatal_error (const char *msg)
-   {
-     perror (msg);
-     abort ();
-   }
-
-   ...
-   ev_set_syserr_cb (fatal_error);
-
-=item ev_feed_signal (int signum)
-
-This function can be used to "simulate" a signal receive. It is completely
-safe to call this function at any time, from any context, including signal
-handlers or random threads.
-
-Its main use is to customise signal handling in your process, especially
-in the presence of threads. For example, you could block signals
-by default in all threads (and specifying C<EVFLAG_NOSIGMASK> when
-creating any loops), and in one thread, use C<sigwait> or any other
-mechanism to wait for signals, then "deliver" them to libev by calling
-C<ev_feed_signal>.
-
-=back
-
-=head1 FUNCTIONS CONTROLLING EVENT LOOPS
-
-An event loop is described by a C<struct ev_loop *> (the C<struct> is
-I<not> optional in this case unless libev 3 compatibility is disabled, as
-libev 3 had an C<ev_loop> function colliding with the struct name).
-
-The library knows two types of such loops, the I<default> loop, which
-supports child process events, and dynamically created event loops which
-do not.
-
-=over 4
-
-=item struct ev_loop *ev_default_loop (unsigned int flags)
-
-This returns the "default" event loop object, which is what you should
-normally use when you just need "the event loop". Event loop objects and
-the C<flags> parameter are described in more detail in the entry for
-C<ev_loop_new>.
-
-If the default loop is already initialised then this function simply
-returns it (and ignores the flags. If that is troubling you, check
-C<ev_backend ()> afterwards). Otherwise it will create it with the given
-flags, which should almost always be C<0>, unless the caller is also the
-one calling C<ev_run> or otherwise qualifies as "the main program".
-
-If you don't know what event loop to use, use the one returned from this
-function (or via the C<EV_DEFAULT> macro).
-
-Note that this function is I<not> thread-safe, so if you want to use it
-from multiple threads, you have to employ some kind of mutex (note also
-that this case is unlikely, as loops cannot be shared easily between
-threads anyway).
-
-The default loop is the only loop that can handle C<ev_child> watchers,
-and to do this, it always registers a handler for C<SIGCHLD>. If this is
-a problem for your application you can either create a dynamic loop with
-C<ev_loop_new> which doesn't do that, or you can simply overwrite the
-C<SIGCHLD> signal handler I<after> calling C<ev_default_init>.
-
-Example: This is the most typical usage.
-
-   if (!ev_default_loop (0))
-     fatal ("could not initialise libev, bad $LIBEV_FLAGS in environment?");
-
-Example: Restrict libev to the select and poll backends, and do not allow
-environment settings to be taken into account:
-
-   ev_default_loop (EVBACKEND_POLL | EVBACKEND_SELECT | EVFLAG_NOENV);
-
-=item struct ev_loop *ev_loop_new (unsigned int flags)
-
-This will create and initialise a new event loop object. If the loop
-could not be initialised, returns false.
-
-This function is thread-safe, and one common way to use libev with
-threads is indeed to create one loop per thread, and using the default
-loop in the "main" or "initial" thread.
-
-The flags argument can be used to specify special behaviour or specific
-backends to use, and is usually specified as C<0> (or C<EVFLAG_AUTO>).
-
-The following flags are supported:
-
-=over 4
-
-=item C<EVFLAG_AUTO>
-
-The default flags value. Use this if you have no clue (it's the right
-thing, believe me).
-
-=item C<EVFLAG_NOENV>
-
-If this flag bit is or'ed into the flag value (or the program runs setuid
-or setgid) then libev will I<not> look at the environment variable
-C<LIBEV_FLAGS>. Otherwise (the default), this environment variable will
-override the flags completely if it is found in the environment. This is
-useful to try out specific backends to test their performance, to work
-around bugs, or to make libev threadsafe (accessing environment variables
-cannot be done in a threadsafe way, but usually it works if no other
-thread modifies them).
-
-=item C<EVFLAG_FORKCHECK>
-
-Instead of calling C<ev_loop_fork> manually after a fork, you can also
-make libev check for a fork in each iteration by enabling this flag.
-
-This works by calling C<getpid ()> on every iteration of the loop,
-and thus this might slow down your event loop if you do a lot of loop
-iterations and little real work, but is usually not noticeable (on my
-GNU/Linux system for example, C<getpid> is actually a simple 5-insn
-sequence without a system call and thus I<very> fast, but my GNU/Linux
-system also has C<pthread_atfork> which is even faster). (Update: glibc
-versions 2.25 apparently removed the C<getpid> optimisation again).
-
-The big advantage of this flag is that you can forget about fork (and
-forget about forgetting to tell libev about forking, although you still
-have to ignore C<SIGPIPE>) when you use this flag.
-
-This flag setting cannot be overridden or specified in the C<LIBEV_FLAGS>
-environment variable.
-
-=item C<EVFLAG_NOINOTIFY>
-
-When this flag is specified, then libev will not attempt to use the
-I<inotify> API for its C<ev_stat> watchers. Apart from debugging and
-testing, this flag can be useful to conserve inotify file descriptors, as
-otherwise each loop using C<ev_stat> watchers consumes one inotify handle.
-
-=item C<EVFLAG_SIGNALFD>
-
-When this flag is specified, then libev will attempt to use the
-I<signalfd> API for its C<ev_signal> (and C<ev_child>) watchers. This API
-delivers signals synchronously, which makes it both faster and might make
-it possible to get the queued signal data. It can also simplify signal
-handling with threads, as long as you properly block signals in your
-threads that are not interested in handling them.
-
-Signalfd will not be used by default as this changes your signal mask, and
-there are a lot of shoddy libraries and programs (glib's threadpool for
-example) that can't properly initialise their signal masks.
-
-=item C<EVFLAG_NOSIGMASK>
-
-When this flag is specified, then libev will avoid to modify the signal
-mask. Specifically, this means you have to make sure signals are unblocked
-when you want to receive them.
-
-This behaviour is useful when you want to do your own signal handling, or
-want to handle signals only in specific threads and want to avoid libev
-unblocking the signals.
-
-It's also required by POSIX in a threaded program, as libev calls
-C<sigprocmask>, whose behaviour is officially unspecified.
-
-This flag's behaviour will become the default in future versions of libev.
-
-=item C<EVBACKEND_SELECT>  (value 1, portable select backend)
-
-This is your standard select(2) backend. Not I<completely> standard, as
-libev tries to roll its own fd_set with no limits on the number of fds,
-but if that fails, expect a fairly low limit on the number of fds when
-using this backend. It doesn't scale too well (O(highest_fd)), but its
-usually the fastest backend for a low number of (low-numbered :) fds.
-
-To get good performance out of this backend you need a high amount of
-parallelism (most of the file descriptors should be busy). If you are
-writing a server, you should C<accept ()> in a loop to accept as many
-connections as possible during one iteration. You might also want to have
-a look at C<ev_set_io_collect_interval ()> to increase the amount of
-readiness notifications you get per iteration.
-
-This backend maps C<EV_READ> to the C<readfds> set and C<EV_WRITE> to the
-C<writefds> set (and to work around Microsoft Windows bugs, also onto the
-C<exceptfds> set on that platform).
-
-=item C<EVBACKEND_POLL>    (value 2, poll backend, available everywhere except on windows)
-
-And this is your standard poll(2) backend. It's more complicated
-than select, but handles sparse fds better and has no artificial
-limit on the number of fds you can use (except it will slow down
-considerably with a lot of inactive fds). It scales similarly to select,
-i.e. O(total_fds). See the entry for C<EVBACKEND_SELECT>, above, for
-performance tips.
-
-This backend maps C<EV_READ> to C<POLLIN | POLLERR | POLLHUP>, and
-C<EV_WRITE> to C<POLLOUT | POLLERR | POLLHUP>.
-
-=item C<EVBACKEND_EPOLL>   (value 4, Linux)
-
-Use the linux-specific epoll(7) interface (for both pre- and post-2.6.9
-kernels).
-
-For few fds, this backend is a bit little slower than poll and select, but
-it scales phenomenally better. While poll and select usually scale like
-O(total_fds) where total_fds is the total number of fds (or the highest
-fd), epoll scales either O(1) or O(active_fds).
-
-The epoll mechanism deserves honorable mention as the most misdesigned
-of the more advanced event mechanisms: mere annoyances include silently
-dropping file descriptors, requiring a system call per change per file
-descriptor (and unnecessary guessing of parameters), problems with dup,
-returning before the timeout value, resulting in additional iterations
-(and only giving 5ms accuracy while select on the same platform gives
-0.1ms) and so on. The biggest issue is fork races, however - if a program
-forks then I<both> parent and child process have to recreate the epoll
-set, which can take considerable time (one syscall per file descriptor)
-and is of course hard to detect.
-
-Epoll is also notoriously buggy - embedding epoll fds I<should> work,
-but of course I<doesn't>, and epoll just loves to report events for
-totally I<different> file descriptors (even already closed ones, so
-one cannot even remove them from the set) than registered in the set
-(especially on SMP systems). Libev tries to counter these spurious
-notifications by employing an additional generation counter and comparing
-that against the events to filter out spurious ones, recreating the set
-when required. Epoll also erroneously rounds down timeouts, but gives you
-no way to know when and by how much, so sometimes you have to busy-wait
-because epoll returns immediately despite a nonzero timeout. And last
-not least, it also refuses to work with some file descriptors which work
-perfectly fine with C<select> (files, many character devices...).
-
-Epoll is truly the train wreck among event poll mechanisms, a frankenpoll,
-cobbled together in a hurry, no thought to design or interaction with
-others. Oh, the pain, will it ever stop...
-
-While stopping, setting and starting an I/O watcher in the same iteration
-will result in some caching, there is still a system call per such
-incident (because the same I<file descriptor> could point to a different
-I<file description> now), so its best to avoid that. Also, C<dup ()>'ed
-file descriptors might not work very well if you register events for both
-file descriptors.
-
-Best performance from this backend is achieved by not unregistering all
-watchers for a file descriptor until it has been closed, if possible,
-i.e. keep at least one watcher active per fd at all times. Stopping and
-starting a watcher (without re-setting it) also usually doesn't cause
-extra overhead. A fork can both result in spurious notifications as well
-as in libev having to destroy and recreate the epoll object, which can
-take considerable time and thus should be avoided.
-
-All this means that, in practice, C<EVBACKEND_SELECT> can be as fast or
-faster than epoll for maybe up to a hundred file descriptors, depending on
-the usage. So sad.
-
-While nominally embeddable in other event loops, this feature is broken in
-all kernel versions tested so far.
-
-This backend maps C<EV_READ> and C<EV_WRITE> in the same way as
-C<EVBACKEND_POLL>.
-
-=item C<EVBACKEND_KQUEUE>  (value 8, most BSD clones)
-
-Kqueue deserves special mention, as at the time of this writing, it
-was broken on all BSDs except NetBSD (usually it doesn't work reliably
-with anything but sockets and pipes, except on Darwin, where of course
-it's completely useless). Unlike epoll, however, whose brokenness
-is by design, these kqueue bugs can (and eventually will) be fixed
-without API changes to existing programs. For this reason it's not being
-"auto-detected" unless you explicitly specify it in the flags (i.e. using
-C<EVBACKEND_KQUEUE>) or libev was compiled on a known-to-be-good (-enough)
-system like NetBSD.
-
-You still can embed kqueue into a normal poll or select backend and use it
-only for sockets (after having made sure that sockets work with kqueue on
-the target platform). See C<ev_embed> watchers for more info.
-
-It scales in the same way as the epoll backend, but the interface to the
-kernel is more efficient (which says nothing about its actual speed, of
-course). While stopping, setting and starting an I/O watcher does never
-cause an extra system call as with C<EVBACKEND_EPOLL>, it still adds up to
-two event changes per incident. Support for C<fork ()> is very bad (you
-might have to leak fd's on fork, but it's more sane than epoll) and it
-drops fds silently in similarly hard-to-detect cases.
-
-This backend usually performs well under most conditions.
-
-While nominally embeddable in other event loops, this doesn't work
-everywhere, so you might need to test for this. And since it is broken
-almost everywhere, you should only use it when you have a lot of sockets
-(for which it usually works), by embedding it into another event loop
-(e.g. C<EVBACKEND_SELECT> or C<EVBACKEND_POLL> (but C<poll> is of course
-also broken on OS X)) and, did I mention it, using it only for sockets.
-
-This backend maps C<EV_READ> into an C<EVFILT_READ> kevent with
-C<NOTE_EOF>, and C<EV_WRITE> into an C<EVFILT_WRITE> kevent with
-C<NOTE_EOF>.
-
-=item C<EVBACKEND_DEVPOLL> (value 16, Solaris 8)
-
-This is not implemented yet (and might never be, unless you send me an
-implementation). According to reports, C</dev/poll> only supports sockets
-and is not embeddable, which would limit the usefulness of this backend
-immensely.
-
-=item C<EVBACKEND_PORT>    (value 32, Solaris 10)
-
-This uses the Solaris 10 event port mechanism. As with everything on Solaris,
-it's really slow, but it still scales very well (O(active_fds)).
-
-While this backend scales well, it requires one system call per active
-file descriptor per loop iteration. For small and medium numbers of file
-descriptors a "slow" C<EVBACKEND_SELECT> or C<EVBACKEND_POLL> backend
-might perform better.
-
-On the positive side, this backend actually performed fully to
-specification in all tests and is fully embeddable, which is a rare feat
-among the OS-specific backends (I vastly prefer correctness over speed
-hacks).
-
-On the negative side, the interface is I<bizarre> - so bizarre that
-even sun itself gets it wrong in their code examples: The event polling
-function sometimes returns events to the caller even though an error
-occurred, but with no indication whether it has done so or not (yes, it's
-even documented that way) - deadly for edge-triggered interfaces where you
-absolutely have to know whether an event occurred or not because you have
-to re-arm the watcher.
-
-Fortunately libev seems to be able to work around these idiocies.
-
-This backend maps C<EV_READ> and C<EV_WRITE> in the same way as
-C<EVBACKEND_POLL>.
-
-=item C<EVBACKEND_ALL>
-
-Try all backends (even potentially broken ones that wouldn't be tried
-with C<EVFLAG_AUTO>). Since this is a mask, you can do stuff such as
-C<EVBACKEND_ALL & ~EVBACKEND_KQUEUE>.
-
-It is definitely not recommended to use this flag, use whatever
-C<ev_recommended_backends ()> returns, or simply do not specify a backend
-at all.
-
-=item C<EVBACKEND_MASK>
-
-Not a backend at all, but a mask to select all backend bits from a
-C<flags> value, in case you want to mask out any backends from a flags
-value (e.g. when modifying the C<LIBEV_FLAGS> environment variable).
-
-=back
-
-If one or more of the backend flags are or'ed into the flags value,
-then only these backends will be tried (in the reverse order as listed
-here). If none are specified, all backends in C<ev_recommended_backends
-()> will be tried.
-
-Example: Try to create a event loop that uses epoll and nothing else.
-
-   struct ev_loop *epoller = ev_loop_new (EVBACKEND_EPOLL | EVFLAG_NOENV);
-   if (!epoller)
-     fatal ("no epoll found here, maybe it hides under your chair");
-
-Example: Use whatever libev has to offer, but make sure that kqueue is
-used if available.
-
-   struct ev_loop *loop = ev_loop_new (ev_recommended_backends () | EVBACKEND_KQUEUE);
-
-=item ev_loop_destroy (loop)
-
-Destroys an event loop object (frees all memory and kernel state
-etc.). None of the active event watchers will be stopped in the normal
-sense, so e.g. C<ev_is_active> might still return true. It is your
-responsibility to either stop all watchers cleanly yourself I<before>
-calling this function, or cope with the fact afterwards (which is usually
-the easiest thing, you can just ignore the watchers and/or C<free ()> them
-for example).
-
-Note that certain global state, such as signal state (and installed signal
-handlers), will not be freed by this function, and related watchers (such
-as signal and child watchers) would need to be stopped manually.
-
-This function is normally used on loop objects allocated by
-C<ev_loop_new>, but it can also be used on the default loop returned by
-C<ev_default_loop>, in which case it is not thread-safe.
-
-Note that it is not advisable to call this function on the default loop
-except in the rare occasion where you really need to free its resources.
-If you need dynamically allocated loops it is better to use C<ev_loop_new>
-and C<ev_loop_destroy>.
-
-=item ev_loop_fork (loop)
-
-This function sets a flag that causes subsequent C<ev_run> iterations
-to reinitialise the kernel state for backends that have one. Despite
-the name, you can call it anytime you are allowed to start or stop
-watchers (except inside an C<ev_prepare> callback), but it makes most
-sense after forking, in the child process. You I<must> call it (or use
-C<EVFLAG_FORKCHECK>) in the child before resuming or calling C<ev_run>.
-
-In addition, if you want to reuse a loop (via this function or
-C<EVFLAG_FORKCHECK>), you I<also> have to ignore C<SIGPIPE>.
-
-Again, you I<have> to call it on I<any> loop that you want to re-use after
-a fork, I<even if you do not plan to use the loop in the parent>. This is
-because some kernel interfaces *cough* I<kqueue> *cough* do funny things
-during fork.
-
-On the other hand, you only need to call this function in the child
-process if and only if you want to use the event loop in the child. If
-you just fork+exec or create a new loop in the child, you don't have to
-call it at all (in fact, C<epoll> is so badly broken that it makes a
-difference, but libev will usually detect this case on its own and do a
-costly reset of the backend).
-
-The function itself is quite fast and it's usually not a problem to call
-it just in case after a fork.
-
-Example: Automate calling C<ev_loop_fork> on the default loop when
-using pthreads.
-
-   static void
-   post_fork_child (void)
-   {
-     ev_loop_fork (EV_DEFAULT);
-   }
-
-   ...
-   pthread_atfork (0, 0, post_fork_child);
-
-=item int ev_is_default_loop (loop)
-
-Returns true when the given loop is, in fact, the default loop, and false
-otherwise.
-
-=item unsigned int ev_iteration (loop)
-
-Returns the current iteration count for the event loop, which is identical
-to the number of times libev did poll for new events. It starts at C<0>
-and happily wraps around with enough iterations.
-
-This value can sometimes be useful as a generation counter of sorts (it
-"ticks" the number of loop iterations), as it roughly corresponds with
-C<ev_prepare> and C<ev_check> calls - and is incremented between the
-prepare and check phases.
-
-=item unsigned int ev_depth (loop)
-
-Returns the number of times C<ev_run> was entered minus the number of
-times C<ev_run> was exited normally, in other words, the recursion depth.
-
-Outside C<ev_run>, this number is zero. In a callback, this number is
-C<1>, unless C<ev_run> was invoked recursively (or from another thread),
-in which case it is higher.
-
-Leaving C<ev_run> abnormally (setjmp/longjmp, cancelling the thread,
-throwing an exception etc.), doesn't count as "exit" - consider this
-as a hint to avoid such ungentleman-like behaviour unless it's really
-convenient, in which case it is fully supported.
-
-=item unsigned int ev_backend (loop)
-
-Returns one of the C<EVBACKEND_*> flags indicating the event backend in
-use.
-
-=item ev_tstamp ev_now (loop)
-
-Returns the current "event loop time", which is the time the event loop
-received events and started processing them. This timestamp does not
-change as long as callbacks are being processed, and this is also the base
-time used for relative timers. You can treat it as the timestamp of the
-event occurring (or more correctly, libev finding out about it).
-
-=item ev_now_update (loop)
-
-Establishes the current time by querying the kernel, updating the time
-returned by C<ev_now ()> in the progress. This is a costly operation and
-is usually done automatically within C<ev_run ()>.
-
-This function is rarely useful, but when some event callback runs for a
-very long time without entering the event loop, updating libev's idea of
-the current time is a good idea.
-
-See also L</The special problem of time updates> in the C<ev_timer> section.
-
-=item ev_suspend (loop)
-
-=item ev_resume (loop)
-
-These two functions suspend and resume an event loop, for use when the
-loop is not used for a while and timeouts should not be processed.
-
-A typical use case would be an interactive program such as a game:  When
-the user presses C<^Z> to suspend the game and resumes it an hour later it
-would be best to handle timeouts as if no time had actually passed while
-the program was suspended. This can be achieved by calling C<ev_suspend>
-in your C<SIGTSTP> handler, sending yourself a C<SIGSTOP> and calling
-C<ev_resume> directly afterwards to resume timer processing.
-
-Effectively, all C<ev_timer> watchers will be delayed by the time spend
-between C<ev_suspend> and C<ev_resume>, and all C<ev_periodic> watchers
-will be rescheduled (that is, they will lose any events that would have
-occurred while suspended).
-
-After calling C<ev_suspend> you B<must not> call I<any> function on the
-given loop other than C<ev_resume>, and you B<must not> call C<ev_resume>
-without a previous call to C<ev_suspend>.
-
-Calling C<ev_suspend>/C<ev_resume> has the side effect of updating the
-event loop time (see C<ev_now_update>).
-
-=item bool ev_run (loop, int flags)
-
-Finally, this is it, the event handler. This function usually is called
-after you have initialised all your watchers and you want to start
-handling events. It will ask the operating system for any new events, call
-the watcher callbacks, and then repeat the whole process indefinitely: This
-is why event loops are called I<loops>.
-
-If the flags argument is specified as C<0>, it will keep handling events
-until either no event watchers are active anymore or C<ev_break> was
-called.
-
-The return value is false if there are no more active watchers (which
-usually means "all jobs done" or "deadlock"), and true in all other cases
-(which usually means " you should call C<ev_run> again").
-
-Please note that an explicit C<ev_break> is usually better than
-relying on all watchers to be stopped when deciding when a program has
-finished (especially in interactive programs), but having a program
-that automatically loops as long as it has to and no longer by virtue
-of relying on its watchers stopping correctly, that is truly a thing of
-beauty.
-
-This function is I<mostly> exception-safe - you can break out of a
-C<ev_run> call by calling C<longjmp> in a callback, throwing a C++
-exception and so on. This does not decrement the C<ev_depth> value, nor
-will it clear any outstanding C<EVBREAK_ONE> breaks.
-
-A flags value of C<EVRUN_NOWAIT> will look for new events, will handle
-those events and any already outstanding ones, but will not wait and
-block your process in case there are no events and will return after one
-iteration of the loop. This is sometimes useful to poll and handle new
-events while doing lengthy calculations, to keep the program responsive.
-
-A flags value of C<EVRUN_ONCE> will look for new events (waiting if
-necessary) and will handle those and any already outstanding ones. It
-will block your process until at least one new event arrives (which could
-be an event internal to libev itself, so there is no guarantee that a
-user-registered callback will be called), and will return after one
-iteration of the loop.
-
-This is useful if you are waiting for some external event in conjunction
-with something not expressible using other libev watchers (i.e. "roll your
-own C<ev_run>"). However, a pair of C<ev_prepare>/C<ev_check> watchers is
-usually a better approach for this kind of thing.
-
-Here are the gory details of what C<ev_run> does (this is for your
-understanding, not a guarantee that things will work exactly like this in
-future versions):
-
-   - Increment loop depth.
-   - Reset the ev_break status.
-   - Before the first iteration, call any pending watchers.
-   LOOP:
-   - If EVFLAG_FORKCHECK was used, check for a fork.
-   - If a fork was detected (by any means), queue and call all fork watchers.
-   - Queue and call all prepare watchers.
-   - If ev_break was called, goto FINISH.
-   - If we have been forked, detach and recreate the kernel state
-     as to not disturb the other process.
-   - Update the kernel state with all outstanding changes.
-   - Update the "event loop time" (ev_now ()).
-   - Calculate for how long to sleep or block, if at all
-     (active idle watchers, EVRUN_NOWAIT or not having
-     any active watchers at all will result in not sleeping).
-   - Sleep if the I/O and timer collect interval say so.
-   - Increment loop iteration counter.
-   - Block the process, waiting for any events.
-   - Queue all outstanding I/O (fd) events.
-   - Update the "event loop time" (ev_now ()), and do time jump adjustments.
-   - Queue all expired timers.
-   - Queue all expired periodics.
-   - Queue all idle watchers with priority higher than that of pending events.
-   - Queue all check watchers.
-   - Call all queued watchers in reverse order (i.e. check watchers first).
-     Signals and child watchers are implemented as I/O watchers, and will
-     be handled here by queueing them when their watcher gets executed.
-   - If ev_break has been called, or EVRUN_ONCE or EVRUN_NOWAIT
-     were used, or there are no active watchers, goto FINISH, otherwise
-     continue with step LOOP.
-   FINISH:
-   - Reset the ev_break status iff it was EVBREAK_ONE.
-   - Decrement the loop depth.
-   - Return.
-
-Example: Queue some jobs and then loop until no events are outstanding
-anymore.
-
-   ... queue jobs here, make sure they register event watchers as long
-   ... as they still have work to do (even an idle watcher will do..)
-   ev_run (my_loop, 0);
-   ... jobs done or somebody called break. yeah!
-
-=item ev_break (loop, how)
-
-Can be used to make a call to C<ev_run> return early (but only after it
-has processed all outstanding events). The C<how> argument must be either
-C<EVBREAK_ONE>, which will make the innermost C<ev_run> call return, or
-C<EVBREAK_ALL>, which will make all nested C<ev_run> calls return.
-
-This "break state" will be cleared on the next call to C<ev_run>.
-
-It is safe to call C<ev_break> from outside any C<ev_run> calls, too, in
-which case it will have no effect.
-
-=item ev_ref (loop)
-
-=item ev_unref (loop)
-
-Ref/unref can be used to add or remove a reference count on the event
-loop: Every watcher keeps one reference, and as long as the reference
-count is nonzero, C<ev_run> will not return on its own.
-
-This is useful when you have a watcher that you never intend to
-unregister, but that nevertheless should not keep C<ev_run> from
-returning. In such a case, call C<ev_unref> after starting, and C<ev_ref>
-before stopping it.
-
-As an example, libev itself uses this for its internal signal pipe: It
-is not visible to the libev user and should not keep C<ev_run> from
-exiting if no event watchers registered by it are active. It is also an
-excellent way to do this for generic recurring timers or from within
-third-party libraries. Just remember to I<unref after start> and I<ref
-before stop> (but only if the watcher wasn't active before, or was active
-before, respectively. Note also that libev might stop watchers itself
-(e.g. non-repeating timers) in which case you have to C<ev_ref>
-in the callback).
-
-Example: Create a signal watcher, but keep it from keeping C<ev_run>
-running when nothing else is active.
-
-   ev_signal exitsig;
-   ev_signal_init (&exitsig, sig_cb, SIGINT);
-   ev_signal_start (loop, &exitsig);
-   ev_unref (loop);
-
-Example: For some weird reason, unregister the above signal handler again.
-
-   ev_ref (loop);
-   ev_signal_stop (loop, &exitsig);
-
-=item ev_set_io_collect_interval (loop, ev_tstamp interval)
-
-=item ev_set_timeout_collect_interval (loop, ev_tstamp interval)
-
-These advanced functions influence the time that libev will spend waiting
-for events. Both time intervals are by default C<0>, meaning that libev
-will try to invoke timer/periodic callbacks and I/O callbacks with minimum
-latency.
-
-Setting these to a higher value (the C<interval> I<must> be >= C<0>)
-allows libev to delay invocation of I/O and timer/periodic callbacks
-to increase efficiency of loop iterations (or to increase power-saving
-opportunities).
-
-The idea is that sometimes your program runs just fast enough to handle
-one (or very few) event(s) per loop iteration. While this makes the
-program responsive, it also wastes a lot of CPU time to poll for new
-events, especially with backends like C<select ()> which have a high
-overhead for the actual polling but can deliver many events at once.
-
-By setting a higher I<io collect interval> you allow libev to spend more
-time collecting I/O events, so you can handle more events per iteration,
-at the cost of increasing latency. Timeouts (both C<ev_periodic> and
-C<ev_timer>) will not be affected. Setting this to a non-null value will
-introduce an additional C<ev_sleep ()> call into most loop iterations. The
-sleep time ensures that libev will not poll for I/O events more often then
-once per this interval, on average (as long as the host time resolution is
-good enough).
-
-Likewise, by setting a higher I<timeout collect interval> you allow libev
-to spend more time collecting timeouts, at the expense of increased
-latency/jitter/inexactness (the watcher callback will be called
-later). C<ev_io> watchers will not be affected. Setting this to a non-null
-value will not introduce any overhead in libev.
-
-Many (busy) programs can usually benefit by setting the I/O collect
-interval to a value near C<0.1> or so, which is often enough for
-interactive servers (of course not for games), likewise for timeouts. It
-usually doesn't make much sense to set it to a lower value than C<0.01>,
-as this approaches the timing granularity of most systems. Note that if
-you do transactions with the outside world and you can't increase the
-parallelity, then this setting will limit your transaction rate (if you
-need to poll once per transaction and the I/O collect interval is 0.01,
-then you can't do more than 100 transactions per second).
-
-Setting the I<timeout collect interval> can improve the opportunity for
-saving power, as the program will "bundle" timer callback invocations that
-are "near" in time together, by delaying some, thus reducing the number of
-times the process sleeps and wakes up again. Another useful technique to
-reduce iterations/wake-ups is to use C<ev_periodic> watchers and make sure
-they fire on, say, one-second boundaries only.
-
-Example: we only need 0.1s timeout granularity, and we wish not to poll
-more often than 100 times per second:
-
-   ev_set_timeout_collect_interval (EV_DEFAULT_UC_ 0.1);
-   ev_set_io_collect_interval (EV_DEFAULT_UC_ 0.01);
-
-=item ev_invoke_pending (loop)
-
-This call will simply invoke all pending watchers while resetting their
-pending state. Normally, C<ev_run> does this automatically when required,
-but when overriding the invoke callback this call comes handy. This
-function can be invoked from a watcher - this can be useful for example
-when you want to do some lengthy calculation and want to pass further
-event handling to another thread (you still have to make sure only one
-thread executes within C<ev_invoke_pending> or C<ev_run> of course).
-
-=item int ev_pending_count (loop)
-
-Returns the number of pending watchers - zero indicates that no watchers
-are pending.
-
-=item ev_set_invoke_pending_cb (loop, void (*invoke_pending_cb)(EV_P))
-
-This overrides the invoke pending functionality of the loop: Instead of
-invoking all pending watchers when there are any, C<ev_run> will call
-this callback instead. This is useful, for example, when you want to
-invoke the actual watchers inside another context (another thread etc.).
-
-If you want to reset the callback, use C<ev_invoke_pending> as new
-callback.
-
-=item ev_set_loop_release_cb (loop, void (*release)(EV_P) throw (), void (*acquire)(EV_P) throw ())
-
-Sometimes you want to share the same loop between multiple threads. This
-can be done relatively simply by putting mutex_lock/unlock calls around
-each call to a libev function.
-
-However, C<ev_run> can run an indefinite time, so it is not feasible
-to wait for it to return. One way around this is to wake up the event
-loop via C<ev_break> and C<ev_async_send>, another way is to set these
-I<release> and I<acquire> callbacks on the loop.
-
-When set, then C<release> will be called just before the thread is
-suspended waiting for new events, and C<acquire> is called just
-afterwards.
-
-Ideally, C<release> will just call your mutex_unlock function, and
-C<acquire> will just call the mutex_lock function again.
-
-While event loop modifications are allowed between invocations of
-C<release> and C<acquire> (that's their only purpose after all), no
-modifications done will affect the event loop, i.e. adding watchers will
-have no effect on the set of file descriptors being watched, or the time
-waited. Use an C<ev_async> watcher to wake up C<ev_run> when you want it
-to take note of any changes you made.
-
-In theory, threads executing C<ev_run> will be async-cancel safe between
-invocations of C<release> and C<acquire>.
-
-See also the locking example in the C<THREADS> section later in this
-document.
-
-=item ev_set_userdata (loop, void *data)
-
-=item void *ev_userdata (loop)
-
-Set and retrieve a single C<void *> associated with a loop. When
-C<ev_set_userdata> has never been called, then C<ev_userdata> returns
-C<0>.
-
-These two functions can be used to associate arbitrary data with a loop,
-and are intended solely for the C<invoke_pending_cb>, C<release> and
-C<acquire> callbacks described above, but of course can be (ab-)used for
-any other purpose as well.
-
-=item ev_verify (loop)
-
-This function only does something when C<EV_VERIFY> support has been
-compiled in, which is the default for non-minimal builds. It tries to go
-through all internal structures and checks them for validity. If anything
-is found to be inconsistent, it will print an error message to standard
-error and call C<abort ()>.
-
-This can be used to catch bugs inside libev itself: under normal
-circumstances, this function will never abort as of course libev keeps its
-data structures consistent.
-
-=back
-
-
-=head1 ANATOMY OF A WATCHER
-
-In the following description, uppercase C<TYPE> in names stands for the
-watcher type, e.g. C<ev_TYPE_start> can mean C<ev_timer_start> for timer
-watchers and C<ev_io_start> for I/O watchers.
-
-A watcher is an opaque structure that you allocate and register to record
-your interest in some event. To make a concrete example, imagine you want
-to wait for STDIN to become readable, you would create an C<ev_io> watcher
-for that:
-
-   static void my_cb (struct ev_loop *loop, ev_io *w, int revents)
-   {
-     ev_io_stop (w);
-     ev_break (loop, EVBREAK_ALL);
-   }
-
-   struct ev_loop *loop = ev_default_loop (0);
-
-   ev_io stdin_watcher;
-
-   ev_init (&stdin_watcher, my_cb);
-   ev_io_set (&stdin_watcher, STDIN_FILENO, EV_READ);
-   ev_io_start (loop, &stdin_watcher);
-
-   ev_run (loop, 0);
-
-As you can see, you are responsible for allocating the memory for your
-watcher structures (and it is I<usually> a bad idea to do this on the
-stack).
-
-Each watcher has an associated watcher structure (called C<struct ev_TYPE>
-or simply C<ev_TYPE>, as typedefs are provided for all watcher structs).
-
-Each watcher structure must be initialised by a call to C<ev_init (watcher
-*, callback)>, which expects a callback to be provided. This callback is
-invoked each time the event occurs (or, in the case of I/O watchers, each
-time the event loop detects that the file descriptor given is readable
-and/or writable).
-
-Each watcher type further has its own C<< ev_TYPE_set (watcher *, ...) >>
-macro to configure it, with arguments specific to the watcher type. There
-is also a macro to combine initialisation and setting in one call: C<<
-ev_TYPE_init (watcher *, callback, ...) >>.
-
-To make the watcher actually watch out for events, you have to start it
-with a watcher-specific start function (C<< ev_TYPE_start (loop, watcher
-*) >>), and you can stop watching for events at any time by calling the
-corresponding stop function (C<< ev_TYPE_stop (loop, watcher *) >>.
-
-As long as your watcher is active (has been started but not stopped) you
-must not touch the values stored in it. Most specifically you must never
-reinitialise it or call its C<ev_TYPE_set> macro.
-
-Each and every callback receives the event loop pointer as first, the
-registered watcher structure as second, and a bitset of received events as
-third argument.
-
-The received events usually include a single bit per event type received
-(you can receive multiple events at the same time). The possible bit masks
-are:
-
-=over 4
-
-=item C<EV_READ>
-
-=item C<EV_WRITE>
-
-The file descriptor in the C<ev_io> watcher has become readable and/or
-writable.
-
-=item C<EV_TIMER>
-
-The C<ev_timer> watcher has timed out.
-
-=item C<EV_PERIODIC>
-
-The C<ev_periodic> watcher has timed out.
-
-=item C<EV_SIGNAL>
-
-The signal specified in the C<ev_signal> watcher has been received by a thread.
-
-=item C<EV_CHILD>
-
-The pid specified in the C<ev_child> watcher has received a status change.
-
-=item C<EV_STAT>
-
-The path specified in the C<ev_stat> watcher changed its attributes somehow.
-
-=item C<EV_IDLE>
-
-The C<ev_idle> watcher has determined that you have nothing better to do.
-
-=item C<EV_PREPARE>
-
-=item C<EV_CHECK>
-
-All C<ev_prepare> watchers are invoked just I<before> C<ev_run> starts to
-gather new events, and all C<ev_check> watchers are queued (not invoked)
-just after C<ev_run> has gathered them, but before it queues any callbacks
-for any received events. That means C<ev_prepare> watchers are the last
-watchers invoked before the event loop sleeps or polls for new events, and
-C<ev_check> watchers will be invoked before any other watchers of the same
-or lower priority within an event loop iteration.
-
-Callbacks of both watcher types can start and stop as many watchers as
-they want, and all of them will be taken into account (for example, a
-C<ev_prepare> watcher might start an idle watcher to keep C<ev_run> from
-blocking).
-
-=item C<EV_EMBED>
-
-The embedded event loop specified in the C<ev_embed> watcher needs attention.
-
-=item C<EV_FORK>
-
-The event loop has been resumed in the child process after fork (see
-C<ev_fork>).
-
-=item C<EV_CLEANUP>
-
-The event loop is about to be destroyed (see C<ev_cleanup>).
-
-=item C<EV_ASYNC>
-
-The given async watcher has been asynchronously notified (see C<ev_async>).
-
-=item C<EV_CUSTOM>
-
-Not ever sent (or otherwise used) by libev itself, but can be freely used
-by libev users to signal watchers (e.g. via C<ev_feed_event>).
-
-=item C<EV_ERROR>
-
-An unspecified error has occurred, the watcher has been stopped. This might
-happen because the watcher could not be properly started because libev
-ran out of memory, a file descriptor was found to be closed or any other
-problem. Libev considers these application bugs.
-
-You best act on it by reporting the problem and somehow coping with the
-watcher being stopped. Note that well-written programs should not receive
-an error ever, so when your watcher receives it, this usually indicates a
-bug in your program.
-
-Libev will usually signal a few "dummy" events together with an error, for
-example it might indicate that a fd is readable or writable, and if your
-callbacks is well-written it can just attempt the operation and cope with
-the error from read() or write(). This will not work in multi-threaded
-programs, though, as the fd could already be closed and reused for another
-thing, so beware.
-
-=back
-
-=head2 GENERIC WATCHER FUNCTIONS
-
-=over 4
-
-=item C<ev_init> (ev_TYPE *watcher, callback)
-
-This macro initialises the generic portion of a watcher. The contents
-of the watcher object can be arbitrary (so C<malloc> will do). Only
-the generic parts of the watcher are initialised, you I<need> to call
-the type-specific C<ev_TYPE_set> macro afterwards to initialise the
-type-specific parts. For each type there is also a C<ev_TYPE_init> macro
-which rolls both calls into one.
-
-You can reinitialise a watcher at any time as long as it has been stopped
-(or never started) and there are no pending events outstanding.
-
-The callback is always of type C<void (*)(struct ev_loop *loop, ev_TYPE *watcher,
-int revents)>.
-
-Example: Initialise an C<ev_io> watcher in two steps.
-
-   ev_io w;
-   ev_init (&w, my_cb);
-   ev_io_set (&w, STDIN_FILENO, EV_READ);
-
-=item C<ev_TYPE_set> (ev_TYPE *watcher, [args])
-
-This macro initialises the type-specific parts of a watcher. You need to
-call C<ev_init> at least once before you call this macro, but you can
-call C<ev_TYPE_set> any number of times. You must not, however, call this
-macro on a watcher that is active (it can be pending, however, which is a
-difference to the C<ev_init> macro).
-
-Although some watcher types do not have type-specific arguments
-(e.g. C<ev_prepare>) you still need to call its C<set> macro.
-
-See C<ev_init>, above, for an example.
-
-=item C<ev_TYPE_init> (ev_TYPE *watcher, callback, [args])
-
-This convenience macro rolls both C<ev_init> and C<ev_TYPE_set> macro
-calls into a single call. This is the most convenient method to initialise
-a watcher. The same limitations apply, of course.
-
-Example: Initialise and set an C<ev_io> watcher in one step.
-
-   ev_io_init (&w, my_cb, STDIN_FILENO, EV_READ);
-
-=item C<ev_TYPE_start> (loop, ev_TYPE *watcher)
-
-Starts (activates) the given watcher. Only active watchers will receive
-events. If the watcher is already active nothing will happen.
-
-Example: Start the C<ev_io> watcher that is being abused as example in this
-whole section.
-
-   ev_io_start (EV_DEFAULT_UC, &w);
-
-=item C<ev_TYPE_stop> (loop, ev_TYPE *watcher)
-
-Stops the given watcher if active, and clears the pending status (whether
-the watcher was active or not).
-
-It is possible that stopped watchers are pending - for example,
-non-repeating timers are being stopped when they become pending - but
-calling C<ev_TYPE_stop> ensures that the watcher is neither active nor
-pending. If you want to free or reuse the memory used by the watcher it is
-therefore a good idea to always call its C<ev_TYPE_stop> function.
-
-=item bool ev_is_active (ev_TYPE *watcher)
-
-Returns a true value iff the watcher is active (i.e. it has been started
-and not yet been stopped). As long as a watcher is active you must not modify
-it.
-
-=item bool ev_is_pending (ev_TYPE *watcher)
-
-Returns a true value iff the watcher is pending, (i.e. it has outstanding
-events but its callback has not yet been invoked). As long as a watcher
-is pending (but not active) you must not call an init function on it (but
-C<ev_TYPE_set> is safe), you must not change its priority, and you must
-make sure the watcher is available to libev (e.g. you cannot C<free ()>
-it).
-
-=item callback ev_cb (ev_TYPE *watcher)
-
-Returns the callback currently set on the watcher.
-
-=item ev_set_cb (ev_TYPE *watcher, callback)
-
-Change the callback. You can change the callback at virtually any time
-(modulo threads).
-
-=item ev_set_priority (ev_TYPE *watcher, int priority)
-
-=item int ev_priority (ev_TYPE *watcher)
-
-Set and query the priority of the watcher. The priority is a small
-integer between C<EV_MAXPRI> (default: C<2>) and C<EV_MINPRI>
-(default: C<-2>). Pending watchers with higher priority will be invoked
-before watchers with lower priority, but priority will not keep watchers
-from being executed (except for C<ev_idle> watchers).
-
-If you need to suppress invocation when higher priority events are pending
-you need to look at C<ev_idle> watchers, which provide this functionality.
-
-You I<must not> change the priority of a watcher as long as it is active or
-pending.
-
-Setting a priority outside the range of C<EV_MINPRI> to C<EV_MAXPRI> is
-fine, as long as you do not mind that the priority value you query might
-or might not have been clamped to the valid range.
-
-The default priority used by watchers when no priority has been set is
-always C<0>, which is supposed to not be too high and not be too low :).
-
-See L</WATCHER PRIORITY MODELS>, below, for a more thorough treatment of
-priorities.
-
-=item ev_invoke (loop, ev_TYPE *watcher, int revents)
-
-Invoke the C<watcher> with the given C<loop> and C<revents>. Neither
-C<loop> nor C<revents> need to be valid as long as the watcher callback
-can deal with that fact, as both are simply passed through to the
-callback.
-
-=item int ev_clear_pending (loop, ev_TYPE *watcher)
-
-If the watcher is pending, this function clears its pending status and
-returns its C<revents> bitset (as if its callback was invoked). If the
-watcher isn't pending it does nothing and returns C<0>.
-
-Sometimes it can be useful to "poll" a watcher instead of waiting for its
-callback to be invoked, which can be accomplished with this function.
-
-=item ev_feed_event (loop, ev_TYPE *watcher, int revents)
-
-Feeds the given event set into the event loop, as if the specified event
-had happened for the specified watcher (which must be a pointer to an
-initialised but not necessarily started event watcher). Obviously you must
-not free the watcher as long as it has pending events.
-
-Stopping the watcher, letting libev invoke it, or calling
-C<ev_clear_pending> will clear the pending event, even if the watcher was
-not started in the first place.
-
-See also C<ev_feed_fd_event> and C<ev_feed_signal_event> for related
-functions that do not need a watcher.
-
-=back
-
-See also the L</ASSOCIATING CUSTOM DATA WITH A WATCHER> and L</BUILDING YOUR
-OWN COMPOSITE WATCHERS> idioms.
-
-=head2 WATCHER STATES
-
-There are various watcher states mentioned throughout this manual -
-active, pending and so on. In this section these states and the rules to
-transition between them will be described in more detail - and while these
-rules might look complicated, they usually do "the right thing".
-
-=over 4
-
-=item initialised
-
-Before a watcher can be registered with the event loop it has to be
-initialised. This can be done with a call to C<ev_TYPE_init>, or calls to
-C<ev_init> followed by the watcher-specific C<ev_TYPE_set> function.
-
-In this state it is simply some block of memory that is suitable for
-use in an event loop. It can be moved around, freed, reused etc. at
-will - as long as you either keep the memory contents intact, or call
-C<ev_TYPE_init> again.
-
-=item started/running/active
-
-Once a watcher has been started with a call to C<ev_TYPE_start> it becomes
-property of the event loop, and is actively waiting for events. While in
-this state it cannot be accessed (except in a few documented ways), moved,
-freed or anything else - the only legal thing is to keep a pointer to it,
-and call libev functions on it that are documented to work on active watchers.
-
-=item pending
-
-If a watcher is active and libev determines that an event it is interested
-in has occurred (such as a timer expiring), it will become pending. It will
-stay in this pending state until either it is stopped or its callback is
-about to be invoked, so it is not normally pending inside the watcher
-callback.
-
-The watcher might or might not be active while it is pending (for example,
-an expired non-repeating timer can be pending but no longer active). If it
-is stopped, it can be freely accessed (e.g. by calling C<ev_TYPE_set>),
-but it is still property of the event loop at this time, so cannot be
-moved, freed or reused. And if it is active the rules described in the
-previous item still apply.
-
-It is also possible to feed an event on a watcher that is not active (e.g.
-via C<ev_feed_event>), in which case it becomes pending without being
-active.
-
-=item stopped
-
-A watcher can be stopped implicitly by libev (in which case it might still
-be pending), or explicitly by calling its C<ev_TYPE_stop> function. The
-latter will clear any pending state the watcher might be in, regardless
-of whether it was active or not, so stopping a watcher explicitly before
-freeing it is often a good idea.
-
-While stopped (and not pending) the watcher is essentially in the
-initialised state, that is, it can be reused, moved, modified in any way
-you wish (but when you trash the memory block, you need to C<ev_TYPE_init>
-it again).
-
-=back
-
-=head2 WATCHER PRIORITY MODELS
-
-Many event loops support I<watcher priorities>, which are usually small
-integers that influence the ordering of event callback invocation
-between watchers in some way, all else being equal.
-
-In libev, Watcher priorities can be set using C<ev_set_priority>. See its
-description for the more technical details such as the actual priority
-range.
-
-There are two common ways how these these priorities are being interpreted
-by event loops:
-
-In the more common lock-out model, higher priorities "lock out" invocation
-of lower priority watchers, which means as long as higher priority
-watchers receive events, lower priority watchers are not being invoked.
-
-The less common only-for-ordering model uses priorities solely to order
-callback invocation within a single event loop iteration: Higher priority
-watchers are invoked before lower priority ones, but they all get invoked
-before polling for new events.
-
-Libev uses the second (only-for-ordering) model for all its watchers
-except for idle watchers (which use the lock-out model).
-
-The rationale behind this is that implementing the lock-out model for
-watchers is not well supported by most kernel interfaces, and most event
-libraries will just poll for the same events again and again as long as
-their callbacks have not been executed, which is very inefficient in the
-common case of one high-priority watcher locking out a mass of lower
-priority ones.
-
-Static (ordering) priorities are most useful when you have two or more
-watchers handling the same resource: a typical usage example is having an
-C<ev_io> watcher to receive data, and an associated C<ev_timer> to handle
-timeouts. Under load, data might be received while the program handles
-other jobs, but since timers normally get invoked first, the timeout
-handler will be executed before checking for data. In that case, giving
-the timer a lower priority than the I/O watcher ensures that I/O will be
-handled first even under adverse conditions (which is usually, but not
-always, what you want).
-
-Since idle watchers use the "lock-out" model, meaning that idle watchers
-will only be executed when no same or higher priority watchers have
-received events, they can be used to implement the "lock-out" model when
-required.
-
-For example, to emulate how many other event libraries handle priorities,
-you can associate an C<ev_idle> watcher to each such watcher, and in
-the normal watcher callback, you just start the idle watcher. The real
-processing is done in the idle watcher callback. This causes libev to
-continuously poll and process kernel event data for the watcher, but when
-the lock-out case is known to be rare (which in turn is rare :), this is
-workable.
-
-Usually, however, the lock-out model implemented that way will perform
-miserably under the type of load it was designed to handle. In that case,
-it might be preferable to stop the real watcher before starting the
-idle watcher, so the kernel will not have to process the event in case
-the actual processing will be delayed for considerable time.
-
-Here is an example of an I/O watcher that should run at a strictly lower
-priority than the default, and which should only process data when no
-other events are pending:
-
-   ev_idle idle; // actual processing watcher
-   ev_io io;     // actual event watcher
-
-   static void
-   io_cb (EV_P_ ev_io *w, int revents)
-   {
-     // stop the I/O watcher, we received the event, but
-     // are not yet ready to handle it.
-     ev_io_stop (EV_A_ w);
-
-     // start the idle watcher to handle the actual event.
-     // it will not be executed as long as other watchers
-     // with the default priority are receiving events.
-     ev_idle_start (EV_A_ &idle);
-   }
-
-   static void
-   idle_cb (EV_P_ ev_idle *w, int revents)
-   {
-     // actual processing
-     read (STDIN_FILENO, ...);
-
-     // have to start the I/O watcher again, as
-     // we have handled the event
-     ev_io_start (EV_P_ &io);
-   }
-
-   // initialisation
-   ev_idle_init (&idle, idle_cb);
-   ev_io_init (&io, io_cb, STDIN_FILENO, EV_READ);
-   ev_io_start (EV_DEFAULT_ &io);
-
-In the "real" world, it might also be beneficial to start a timer, so that
-low-priority connections can not be locked out forever under load. This
-enables your program to keep a lower latency for important connections
-during short periods of high load, while not completely locking out less
-important ones.
-
-
-=head1 WATCHER TYPES
-
-This section describes each watcher in detail, but will not repeat
-information given in the last section. Any initialisation/set macros,
-functions and members specific to the watcher type are explained.
-
-Members are additionally marked with either I<[read-only]>, meaning that,
-while the watcher is active, you can look at the member and expect some
-sensible content, but you must not modify it (you can modify it while the
-watcher is stopped to your hearts content), or I<[read-write]>, which
-means you can expect it to have some sensible content while the watcher
-is active, but you can also modify it. Modifying it may not do something
-sensible or take immediate effect (or do anything at all), but libev will
-not crash or malfunction in any way.
-
-
-=head2 C<ev_io> - is this file descriptor readable or writable?
-
-I/O watchers check whether a file descriptor is readable or writable
-in each iteration of the event loop, or, more precisely, when reading
-would not block the process and writing would at least be able to write
-some data. This behaviour is called level-triggering because you keep
-receiving events as long as the condition persists. Remember you can stop
-the watcher if you don't want to act on the event and neither want to
-receive future events.
-
-In general you can register as many read and/or write event watchers per
-fd as you want (as long as you don't confuse yourself). Setting all file
-descriptors to non-blocking mode is also usually a good idea (but not
-required if you know what you are doing).
-
-Another thing you have to watch out for is that it is quite easy to
-receive "spurious" readiness notifications, that is, your callback might
-be called with C<EV_READ> but a subsequent C<read>(2) will actually block
-because there is no data. It is very easy to get into this situation even
-with a relatively standard program structure. Thus it is best to always
-use non-blocking I/O: An extra C<read>(2) returning C<EAGAIN> is far
-preferable to a program hanging until some data arrives.
-
-If you cannot run the fd in non-blocking mode (for example you should
-not play around with an Xlib connection), then you have to separately
-re-test whether a file descriptor is really ready with a known-to-be good
-interface such as poll (fortunately in the case of Xlib, it already does
-this on its own, so its quite safe to use). Some people additionally
-use C<SIGALRM> and an interval timer, just to be sure you won't block
-indefinitely.
-
-But really, best use non-blocking mode.
-
-=head3 The special problem of disappearing file descriptors
-
-Some backends (e.g. kqueue, epoll) need to be told about closing a file
-descriptor (either due to calling C<close> explicitly or any other means,
-such as C<dup2>). The reason is that you register interest in some file
-descriptor, but when it goes away, the operating system will silently drop
-this interest. If another file descriptor with the same number then is
-registered with libev, there is no efficient way to see that this is, in
-fact, a different file descriptor.
-
-To avoid having to explicitly tell libev about such cases, libev follows
-the following policy:  Each time C<ev_io_set> is being called, libev
-will assume that this is potentially a new file descriptor, otherwise
-it is assumed that the file descriptor stays the same. That means that
-you I<have> to call C<ev_io_set> (or C<ev_io_init>) when you change the
-descriptor even if the file descriptor number itself did not change.
-
-This is how one would do it normally anyway, the important point is that
-the libev application should not optimise around libev but should leave
-optimisations to libev.
-
-=head3 The special problem of dup'ed file descriptors
-
-Some backends (e.g. epoll), cannot register events for file descriptors,
-but only events for the underlying file descriptions. That means when you
-have C<dup ()>'ed file descriptors or weirder constellations, and register
-events for them, only one file descriptor might actually receive events.
-
-There is no workaround possible except not registering events
-for potentially C<dup ()>'ed file descriptors, or to resort to
-C<EVBACKEND_SELECT> or C<EVBACKEND_POLL>.
-
-=head3 The special problem of files
-
-Many people try to use C<select> (or libev) on file descriptors
-representing files, and expect it to become ready when their program
-doesn't block on disk accesses (which can take a long time on their own).
-
-However, this cannot ever work in the "expected" way - you get a readiness
-notification as soon as the kernel knows whether and how much data is
-there, and in the case of open files, that's always the case, so you
-always get a readiness notification instantly, and your read (or possibly
-write) will still block on the disk I/O.
-
-Another way to view it is that in the case of sockets, pipes, character
-devices and so on, there is another party (the sender) that delivers data
-on its own, but in the case of files, there is no such thing: the disk
-will not send data on its own, simply because it doesn't know what you
-wish to read - you would first have to request some data.
-
-Since files are typically not-so-well supported by advanced notification
-mechanism, libev tries hard to emulate POSIX behaviour with respect
-to files, even though you should not use it. The reason for this is
-convenience: sometimes you want to watch STDIN or STDOUT, which is
-usually a tty, often a pipe, but also sometimes files or special devices
-(for example, C<epoll> on Linux works with F</dev/random> but not with
-F</dev/urandom>), and even though the file might better be served with
-asynchronous I/O instead of with non-blocking I/O, it is still useful when
-it "just works" instead of freezing.
-
-So avoid file descriptors pointing to files when you know it (e.g. use
-libeio), but use them when it is convenient, e.g. for STDIN/STDOUT, or
-when you rarely read from a file instead of from a socket, and want to
-reuse the same code path.
-
-=head3 The special problem of fork
-
-Some backends (epoll, kqueue) do not support C<fork ()> at all or exhibit
-useless behaviour. Libev fully supports fork, but needs to be told about
-it in the child if you want to continue to use it in the child.
-
-To support fork in your child processes, you have to call C<ev_loop_fork
-()> after a fork in the child, enable C<EVFLAG_FORKCHECK>, or resort to
-C<EVBACKEND_SELECT> or C<EVBACKEND_POLL>.
-
-=head3 The special problem of SIGPIPE
-
-While not really specific to libev, it is easy to forget about C<SIGPIPE>:
-when writing to a pipe whose other end has been closed, your program gets
-sent a SIGPIPE, which, by default, aborts your program. For most programs
-this is sensible behaviour, for daemons, this is usually undesirable.
-
-So when you encounter spurious, unexplained daemon exits, make sure you
-ignore SIGPIPE (and maybe make sure you log the exit status of your daemon
-somewhere, as that would have given you a big clue).
-
-=head3 The special problem of accept()ing when you can't
-
-Many implementations of the POSIX C<accept> function (for example,
-found in post-2004 Linux) have the peculiar behaviour of not removing a
-connection from the pending queue in all error cases.
-
-For example, larger servers often run out of file descriptors (because
-of resource limits), causing C<accept> to fail with C<ENFILE> but not
-rejecting the connection, leading to libev signalling readiness on
-the next iteration again (the connection still exists after all), and
-typically causing the program to loop at 100% CPU usage.
-
-Unfortunately, the set of errors that cause this issue differs between
-operating systems, there is usually little the app can do to remedy the
-situation, and no known thread-safe method of removing the connection to
-cope with overload is known (to me).
-
-One of the easiest ways to handle this situation is to just ignore it
-- when the program encounters an overload, it will just loop until the
-situation is over. While this is a form of busy waiting, no OS offers an
-event-based way to handle this situation, so it's the best one can do.
-
-A better way to handle the situation is to log any errors other than
-C<EAGAIN> and C<EWOULDBLOCK>, making sure not to flood the log with such
-messages, and continue as usual, which at least gives the user an idea of
-what could be wrong ("raise the ulimit!"). For extra points one could stop
-the C<ev_io> watcher on the listening fd "for a while", which reduces CPU
-usage.
-
-If your program is single-threaded, then you could also keep a dummy file
-descriptor for overload situations (e.g. by opening F</dev/null>), and
-when you run into C<ENFILE> or C<EMFILE>, close it, run C<accept>,
-close that fd, and create a new dummy fd. This will gracefully refuse
-clients under typical overload conditions.
-
-The last way to handle it is to simply log the error and C<exit>, as
-is often done with C<malloc> failures, but this results in an easy
-opportunity for a DoS attack.
-
-=head3 Watcher-Specific Functions
-
-=over 4
-
-=item ev_io_init (ev_io *, callback, int fd, int events)
-
-=item ev_io_set (ev_io *, int fd, int events)
-
-Configures an C<ev_io> watcher. The C<fd> is the file descriptor to
-receive events for and C<events> is either C<EV_READ>, C<EV_WRITE> or
-C<EV_READ | EV_WRITE>, to express the desire to receive the given events.
-
-=item int fd [read-only]
-
-The file descriptor being watched.
-
-=item int events [read-only]
-
-The events being watched.
-
-=back
-
-=head3 Examples
-
-Example: Call C<stdin_readable_cb> when STDIN_FILENO has become, well
-readable, but only once. Since it is likely line-buffered, you could
-attempt to read a whole line in the callback.
-
-   static void
-   stdin_readable_cb (struct ev_loop *loop, ev_io *w, int revents)
-   {
-      ev_io_stop (loop, w);
-     .. read from stdin here (or from w->fd) and handle any I/O errors
-   }
-
-   ...
-   struct ev_loop *loop = ev_default_init (0);
-   ev_io stdin_readable;
-   ev_io_init (&stdin_readable, stdin_readable_cb, STDIN_FILENO, EV_READ);
-   ev_io_start (loop, &stdin_readable);
-   ev_run (loop, 0);
-
-
-=head2 C<ev_timer> - relative and optionally repeating timeouts
-
-Timer watchers are simple relative timers that generate an event after a
-given time, and optionally repeating in regular intervals after that.
-
-The timers are based on real time, that is, if you register an event that
-times out after an hour and you reset your system clock to January last
-year, it will still time out after (roughly) one hour. "Roughly" because
-detecting time jumps is hard, and some inaccuracies are unavoidable (the
-monotonic clock option helps a lot here).
-
-The callback is guaranteed to be invoked only I<after> its timeout has
-passed (not I<at>, so on systems with very low-resolution clocks this
-might introduce a small delay, see "the special problem of being too
-early", below). If multiple timers become ready during the same loop
-iteration then the ones with earlier time-out values are invoked before
-ones of the same priority with later time-out values (but this is no
-longer true when a callback calls C<ev_run> recursively).
-
-=head3 Be smart about timeouts
-
-Many real-world problems involve some kind of timeout, usually for error
-recovery. A typical example is an HTTP request - if the other side hangs,
-you want to raise some error after a while.
-
-What follows are some ways to handle this problem, from obvious and
-inefficient to smart and efficient.
-
-In the following, a 60 second activity timeout is assumed - a timeout that
-gets reset to 60 seconds each time there is activity (e.g. each time some
-data or other life sign was received).
-
-=over 4
-
-=item 1. Use a timer and stop, reinitialise and start it on activity.
-
-This is the most obvious, but not the most simple way: In the beginning,
-start the watcher:
-
-   ev_timer_init (timer, callback, 60., 0.);
-   ev_timer_start (loop, timer);
-
-Then, each time there is some activity, C<ev_timer_stop> it, initialise it
-and start it again:
-
-   ev_timer_stop (loop, timer);
-   ev_timer_set (timer, 60., 0.);
-   ev_timer_start (loop, timer);
-
-This is relatively simple to implement, but means that each time there is
-some activity, libev will first have to remove the timer from its internal
-data structure and then add it again. Libev tries to be fast, but it's
-still not a constant-time operation.
-
-=item 2. Use a timer and re-start it with C<ev_timer_again> inactivity.
-
-This is the easiest way, and involves using C<ev_timer_again> instead of
-C<ev_timer_start>.
-
-To implement this, configure an C<ev_timer> with a C<repeat> value
-of C<60> and then call C<ev_timer_again> at start and each time you
-successfully read or write some data. If you go into an idle state where
-you do not expect data to travel on the socket, you can C<ev_timer_stop>
-the timer, and C<ev_timer_again> will automatically restart it if need be.
-
-That means you can ignore both the C<ev_timer_start> function and the
-C<after> argument to C<ev_timer_set>, and only ever use the C<repeat>
-member and C<ev_timer_again>.
-
-At start:
-
-   ev_init (timer, callback);
-   timer->repeat = 60.;
-   ev_timer_again (loop, timer);
-
-Each time there is some activity:
-
-   ev_timer_again (loop, timer);
-
-It is even possible to change the time-out on the fly, regardless of
-whether the watcher is active or not:
-
-   timer->repeat = 30.;
-   ev_timer_again (loop, timer);
-
-This is slightly more efficient then stopping/starting the timer each time
-you want to modify its timeout value, as libev does not have to completely
-remove and re-insert the timer from/into its internal data structure.
-
-It is, however, even simpler than the "obvious" way to do it.
-
-=item 3. Let the timer time out, but then re-arm it as required.
-
-This method is more tricky, but usually most efficient: Most timeouts are
-relatively long compared to the intervals between other activity - in
-our example, within 60 seconds, there are usually many I/O events with
-associated activity resets.
-
-In this case, it would be more efficient to leave the C<ev_timer> alone,
-but remember the time of last activity, and check for a real timeout only
-within the callback:
-
-   ev_tstamp timeout = 60.;
-   ev_tstamp last_activity; // time of last activity
-   ev_timer timer;
-
-   static void
-   callback (EV_P_ ev_timer *w, int revents)
-   {
-     // calculate when the timeout would happen
-     ev_tstamp after = last_activity - ev_now (EV_A) + timeout;
-
-     // if negative, it means we the timeout already occurred
-     if (after < 0.)
-       {
-         // timeout occurred, take action
-       }
-     else
-       {
-         // callback was invoked, but there was some recent 
-         // activity. simply restart the timer to time out
-         // after "after" seconds, which is the earliest time
-         // the timeout can occur.
-         ev_timer_set (w, after, 0.);
-         ev_timer_start (EV_A_ w);
-       }
-   }
-
-To summarise the callback: first calculate in how many seconds the
-timeout will occur (by calculating the absolute time when it would occur,
-C<last_activity + timeout>, and subtracting the current time, C<ev_now
-(EV_A)> from that).
-
-If this value is negative, then we are already past the timeout, i.e. we
-timed out, and need to do whatever is needed in this case.
-
-Otherwise, we now the earliest time at which the timeout would trigger,
-and simply start the timer with this timeout value.
-
-In other words, each time the callback is invoked it will check whether
-the timeout occurred. If not, it will simply reschedule itself to check
-again at the earliest time it could time out. Rinse. Repeat.
-
-This scheme causes more callback invocations (about one every 60 seconds
-minus half the average time between activity), but virtually no calls to
-libev to change the timeout.
-
-To start the machinery, simply initialise the watcher and set
-C<last_activity> to the current time (meaning there was some activity just
-now), then call the callback, which will "do the right thing" and start
-the timer:
-
-   last_activity = ev_now (EV_A);
-   ev_init (&timer, callback);
-   callback (EV_A_ &timer, 0);
-
-When there is some activity, simply store the current time in
-C<last_activity>, no libev calls at all:
-
-   if (activity detected)
-     last_activity = ev_now (EV_A);
-
-When your timeout value changes, then the timeout can be changed by simply
-providing a new value, stopping the timer and calling the callback, which
-will again do the right thing (for example, time out immediately :).
-
-   timeout = new_value;
-   ev_timer_stop (EV_A_ &timer);
-   callback (EV_A_ &timer, 0);
-
-This technique is slightly more complex, but in most cases where the
-time-out is unlikely to be triggered, much more efficient.
-
-=item 4. Wee, just use a double-linked list for your timeouts.
-
-If there is not one request, but many thousands (millions...), all
-employing some kind of timeout with the same timeout value, then one can
-do even better:
-
-When starting the timeout, calculate the timeout value and put the timeout
-at the I<end> of the list.
-
-Then use an C<ev_timer> to fire when the timeout at the I<beginning> of
-the list is expected to fire (for example, using the technique #3).
-
-When there is some activity, remove the timer from the list, recalculate
-the timeout, append it to the end of the list again, and make sure to
-update the C<ev_timer> if it was taken from the beginning of the list.
-
-This way, one can manage an unlimited number of timeouts in O(1) time for
-starting, stopping and updating the timers, at the expense of a major
-complication, and having to use a constant timeout. The constant timeout
-ensures that the list stays sorted.
-
-=back
-
-So which method the best?
-
-Method #2 is a simple no-brain-required solution that is adequate in most
-situations. Method #3 requires a bit more thinking, but handles many cases
-better, and isn't very complicated either. In most case, choosing either
-one is fine, with #3 being better in typical situations.
-
-Method #1 is almost always a bad idea, and buys you nothing. Method #4 is
-rather complicated, but extremely efficient, something that really pays
-off after the first million or so of active timers, i.e. it's usually
-overkill :)
-
-=head3 The special problem of being too early
-
-If you ask a timer to call your callback after three seconds, then
-you expect it to be invoked after three seconds - but of course, this
-cannot be guaranteed to infinite precision. Less obviously, it cannot be
-guaranteed to any precision by libev - imagine somebody suspending the
-process with a STOP signal for a few hours for example.
-
-So, libev tries to invoke your callback as soon as possible I<after> the
-delay has occurred, but cannot guarantee this.
-
-A less obvious failure mode is calling your callback too early: many event
-loops compare timestamps with a "elapsed delay >= requested delay", but
-this can cause your callback to be invoked much earlier than you would
-expect.
-
-To see why, imagine a system with a clock that only offers full second
-resolution (think windows if you can't come up with a broken enough OS
-yourself). If you schedule a one-second timer at the time 500.9, then the
-event loop will schedule your timeout to elapse at a system time of 500
-(500.9 truncated to the resolution) + 1, or 501.
-
-If an event library looks at the timeout 0.1s later, it will see "501 >=
-501" and invoke the callback 0.1s after it was started, even though a
-one-second delay was requested - this is being "too early", despite best
-intentions.
-
-This is the reason why libev will never invoke the callback if the elapsed
-delay equals the requested delay, but only when the elapsed delay is
-larger than the requested delay. In the example above, libev would only invoke
-the callback at system time 502, or 1.1s after the timer was started.
-
-So, while libev cannot guarantee that your callback will be invoked
-exactly when requested, it I<can> and I<does> guarantee that the requested
-delay has actually elapsed, or in other words, it always errs on the "too
-late" side of things.
-
-=head3 The special problem of time updates
-
-Establishing the current time is a costly operation (it usually takes
-at least one system call): EV therefore updates its idea of the current
-time only before and after C<ev_run> collects new events, which causes a
-growing difference between C<ev_now ()> and C<ev_time ()> when handling
-lots of events in one iteration.
-
-The relative timeouts are calculated relative to the C<ev_now ()>
-time. This is usually the right thing as this timestamp refers to the time
-of the event triggering whatever timeout you are modifying/starting. If
-you suspect event processing to be delayed and you I<need> to base the
-timeout on the current time, use something like the following to adjust
-for it:
-
-   ev_timer_set (&timer, after + (ev_time () - ev_now ()), 0.);
-
-If the event loop is suspended for a long time, you can also force an
-update of the time returned by C<ev_now ()> by calling C<ev_now_update
-()>, although that will push the event time of all outstanding events
-further into the future.
-
-=head3 The special problem of unsynchronised clocks
-
-Modern systems have a variety of clocks - libev itself uses the normal
-"wall clock" clock and, if available, the monotonic clock (to avoid time
-jumps).
-
-Neither of these clocks is synchronised with each other or any other clock
-on the system, so C<ev_time ()> might return a considerably different time
-than C<gettimeofday ()> or C<time ()>. On a GNU/Linux system, for example,
-a call to C<gettimeofday> might return a second count that is one higher
-than a directly following call to C<time>.
-
-The moral of this is to only compare libev-related timestamps with
-C<ev_time ()> and C<ev_now ()>, at least if you want better precision than
-a second or so.
-
-One more problem arises due to this lack of synchronisation: if libev uses
-the system monotonic clock and you compare timestamps from C<ev_time>
-or C<ev_now> from when you started your timer and when your callback is
-invoked, you will find that sometimes the callback is a bit "early".
-
-This is because C<ev_timer>s work in real time, not wall clock time, so
-libev makes sure your callback is not invoked before the delay happened,
-I<measured according to the real time>, not the system clock.
-
-If your timeouts are based on a physical timescale (e.g. "time out this
-connection after 100 seconds") then this shouldn't bother you as it is
-exactly the right behaviour.
-
-If you want to compare wall clock/system timestamps to your timers, then
-you need to use C<ev_periodic>s, as these are based on the wall clock
-time, where your comparisons will always generate correct results.
-
-=head3 The special problems of suspended animation
-
-When you leave the server world it is quite customary to hit machines that
-can suspend/hibernate - what happens to the clocks during such a suspend?
-
-Some quick tests made with a Linux 2.6.28 indicate that a suspend freezes
-all processes, while the clocks (C<times>, C<CLOCK_MONOTONIC>) continue
-to run until the system is suspended, but they will not advance while the
-system is suspended. That means, on resume, it will be as if the program
-was frozen for a few seconds, but the suspend time will not be counted
-towards C<ev_timer> when a monotonic clock source is used. The real time
-clock advanced as expected, but if it is used as sole clocksource, then a
-long suspend would be detected as a time jump by libev, and timers would
-be adjusted accordingly.
-
-I would not be surprised to see different behaviour in different between
-operating systems, OS versions or even different hardware.
-
-The other form of suspend (job control, or sending a SIGSTOP) will see a
-time jump in the monotonic clocks and the realtime clock. If the program
-is suspended for a very long time, and monotonic clock sources are in use,
-then you can expect C<ev_timer>s to expire as the full suspension time
-will be counted towards the timers. When no monotonic clock source is in
-use, then libev will again assume a timejump and adjust accordingly.
-
-It might be beneficial for this latter case to call C<ev_suspend>
-and C<ev_resume> in code that handles C<SIGTSTP>, to at least get
-deterministic behaviour in this case (you can do nothing against
-C<SIGSTOP>).
-
-=head3 Watcher-Specific Functions and Data Members
-
-=over 4
-
-=item ev_timer_init (ev_timer *, callback, ev_tstamp after, ev_tstamp repeat)
-
-=item ev_timer_set (ev_timer *, ev_tstamp after, ev_tstamp repeat)
-
-Configure the timer to trigger after C<after> seconds. If C<repeat>
-is C<0.>, then it will automatically be stopped once the timeout is
-reached. If it is positive, then the timer will automatically be
-configured to trigger again C<repeat> seconds later, again, and again,
-until stopped manually.
-
-The timer itself will do a best-effort at avoiding drift, that is, if
-you configure a timer to trigger every 10 seconds, then it will normally
-trigger at exactly 10 second intervals. If, however, your program cannot
-keep up with the timer (because it takes longer than those 10 seconds to
-do stuff) the timer will not fire more than once per event loop iteration.
-
-=item ev_timer_again (loop, ev_timer *)
-
-This will act as if the timer timed out, and restarts it again if it is
-repeating. It basically works like calling C<ev_timer_stop>, updating the
-timeout to the C<repeat> value and calling C<ev_timer_start>.
-
-The exact semantics are as in the following rules, all of which will be
-applied to the watcher:
-
-=over 4
-
-=item If the timer is pending, the pending status is always cleared.
-
-=item If the timer is started but non-repeating, stop it (as if it timed
-out, without invoking it).
-
-=item If the timer is repeating, make the C<repeat> value the new timeout
-and start the timer, if necessary.
-
-=back
-
-This sounds a bit complicated, see L</Be smart about timeouts>, above, for a
-usage example.
-
-=item ev_tstamp ev_timer_remaining (loop, ev_timer *)
-
-Returns the remaining time until a timer fires. If the timer is active,
-then this time is relative to the current event loop time, otherwise it's
-the timeout value currently configured.
-
-That is, after an C<ev_timer_set (w, 5, 7)>, C<ev_timer_remaining> returns
-C<5>. When the timer is started and one second passes, C<ev_timer_remaining>
-will return C<4>. When the timer expires and is restarted, it will return
-roughly C<7> (likely slightly less as callback invocation takes some time,
-too), and so on.
-
-=item ev_tstamp repeat [read-write]
-
-The current C<repeat> value. Will be used each time the watcher times out
-or C<ev_timer_again> is called, and determines the next timeout (if any),
-which is also when any modifications are taken into account.
-
-=back
-
-=head3 Examples
-
-Example: Create a timer that fires after 60 seconds.
-
-   static void
-   one_minute_cb (struct ev_loop *loop, ev_timer *w, int revents)
-   {
-     .. one minute over, w is actually stopped right here
-   }
-
-   ev_timer mytimer;
-   ev_timer_init (&mytimer, one_minute_cb, 60., 0.);
-   ev_timer_start (loop, &mytimer);
-
-Example: Create a timeout timer that times out after 10 seconds of
-inactivity.
-
-   static void
-   timeout_cb (struct ev_loop *loop, ev_timer *w, int revents)
-   {
-     .. ten seconds without any activity
-   }
-
-   ev_timer mytimer;
-   ev_timer_init (&mytimer, timeout_cb, 0., 10.); /* note, only repeat used */
-   ev_timer_again (&mytimer); /* start timer */
-   ev_run (loop, 0);
-
-   // and in some piece of code that gets executed on any "activity":
-   // reset the timeout to start ticking again at 10 seconds
-   ev_timer_again (&mytimer);
-
-
-=head2 C<ev_periodic> - to cron or not to cron?
-
-Periodic watchers are also timers of a kind, but they are very versatile
-(and unfortunately a bit complex).
-
-Unlike C<ev_timer>, periodic watchers are not based on real time (or
-relative time, the physical time that passes) but on wall clock time
-(absolute time, the thing you can read on your calendar or clock). The
-difference is that wall clock time can run faster or slower than real
-time, and time jumps are not uncommon (e.g. when you adjust your
-wrist-watch).
-
-You can tell a periodic watcher to trigger after some specific point
-in time: for example, if you tell a periodic watcher to trigger "in 10
-seconds" (by specifying e.g. C<ev_now () + 10.>, that is, an absolute time
-not a delay) and then reset your system clock to January of the previous
-year, then it will take a year or more to trigger the event (unlike an
-C<ev_timer>, which would still trigger roughly 10 seconds after starting
-it, as it uses a relative timeout).
-
-C<ev_periodic> watchers can also be used to implement vastly more complex
-timers, such as triggering an event on each "midnight, local time", or
-other complicated rules. This cannot be done with C<ev_timer> watchers, as
-those cannot react to time jumps.
-
-As with timers, the callback is guaranteed to be invoked only when the
-point in time where it is supposed to trigger has passed. If multiple
-timers become ready during the same loop iteration then the ones with
-earlier time-out values are invoked before ones with later time-out values
-(but this is no longer true when a callback calls C<ev_run> recursively).
-
-=head3 Watcher-Specific Functions and Data Members
-
-=over 4
-
-=item ev_periodic_init (ev_periodic *, callback, ev_tstamp offset, ev_tstamp interval, reschedule_cb)
-
-=item ev_periodic_set (ev_periodic *, ev_tstamp offset, ev_tstamp interval, reschedule_cb)
-
-Lots of arguments, let's sort it out... There are basically three modes of
-operation, and we will explain them from simplest to most complex:
-
-=over 4
-
-=item * absolute timer (offset = absolute time, interval = 0, reschedule_cb = 0)
-
-In this configuration the watcher triggers an event after the wall clock
-time C<offset> has passed. It will not repeat and will not adjust when a
-time jump occurs, that is, if it is to be run at January 1st 2011 then it
-will be stopped and invoked when the system clock reaches or surpasses
-this point in time.
-
-=item * repeating interval timer (offset = offset within interval, interval > 0, reschedule_cb = 0)
-
-In this mode the watcher will always be scheduled to time out at the next
-C<offset + N * interval> time (for some integer N, which can also be
-negative) and then repeat, regardless of any time jumps. The C<offset>
-argument is merely an offset into the C<interval> periods.
-
-This can be used to create timers that do not drift with respect to the
-system clock, for example, here is an C<ev_periodic> that triggers each
-hour, on the hour (with respect to UTC):
-
-   ev_periodic_set (&periodic, 0., 3600., 0);
-
-This doesn't mean there will always be 3600 seconds in between triggers,
-but only that the callback will be called when the system time shows a
-full hour (UTC), or more correctly, when the system time is evenly divisible
-by 3600.
-
-Another way to think about it (for the mathematically inclined) is that
-C<ev_periodic> will try to run the callback in this mode at the next possible
-time where C<time = offset (mod interval)>, regardless of any time jumps.
-
-The C<interval> I<MUST> be positive, and for numerical stability, the
-interval value should be higher than C<1/8192> (which is around 100
-microseconds) and C<offset> should be higher than C<0> and should have
-at most a similar magnitude as the current time (say, within a factor of
-ten). Typical values for offset are, in fact, C<0> or something between
-C<0> and C<interval>, which is also the recommended range.
-
-Note also that there is an upper limit to how often a timer can fire (CPU
-speed for example), so if C<interval> is very small then timing stability
-will of course deteriorate. Libev itself tries to be exact to be about one
-millisecond (if the OS supports it and the machine is fast enough).
-
-=item * manual reschedule mode (offset ignored, interval ignored, reschedule_cb = callback)
-
-In this mode the values for C<interval> and C<offset> are both being
-ignored. Instead, each time the periodic watcher gets scheduled, the
-reschedule callback will be called with the watcher as first, and the
-current time as second argument.
-
-NOTE: I<This callback MUST NOT stop or destroy any periodic watcher, ever,
-or make ANY other event loop modifications whatsoever, unless explicitly
-allowed by documentation here>.
-
-If you need to stop it, return C<now + 1e30> (or so, fudge fudge) and stop
-it afterwards (e.g. by starting an C<ev_prepare> watcher, which is the
-only event loop modification you are allowed to do).
-
-The callback prototype is C<ev_tstamp (*reschedule_cb)(ev_periodic
-*w, ev_tstamp now)>, e.g.:
-
-   static ev_tstamp
-   my_rescheduler (ev_periodic *w, ev_tstamp now)
-   {
-     return now + 60.;
-   }
-
-It must return the next time to trigger, based on the passed time value
-(that is, the lowest time value larger than to the second argument). It
-will usually be called just before the callback will be triggered, but
-might be called at other times, too.
-
-NOTE: I<< This callback must always return a time that is higher than or
-equal to the passed C<now> value >>.
-
-This can be used to create very complex timers, such as a timer that
-triggers on "next midnight, local time". To do this, you would calculate the
-next midnight after C<now> and return the timestamp value for this. How
-you do this is, again, up to you (but it is not trivial, which is the main
-reason I omitted it as an example).
-
-=back
-
-=item ev_periodic_again (loop, ev_periodic *)
-
-Simply stops and restarts the periodic watcher again. This is only useful
-when you changed some parameters or the reschedule callback would return
-a different time than the last time it was called (e.g. in a crond like
-program when the crontabs have changed).
-
-=item ev_tstamp ev_periodic_at (ev_periodic *)
-
-When active, returns the absolute time that the watcher is supposed
-to trigger next. This is not the same as the C<offset> argument to
-C<ev_periodic_set>, but indeed works even in interval and manual
-rescheduling modes.
-
-=item ev_tstamp offset [read-write]
-
-When repeating, this contains the offset value, otherwise this is the
-absolute point in time (the C<offset> value passed to C<ev_periodic_set>,
-although libev might modify this value for better numerical stability).
-
-Can be modified any time, but changes only take effect when the periodic
-timer fires or C<ev_periodic_again> is being called.
-
-=item ev_tstamp interval [read-write]
-
-The current interval value. Can be modified any time, but changes only
-take effect when the periodic timer fires or C<ev_periodic_again> is being
-called.
-
-=item ev_tstamp (*reschedule_cb)(ev_periodic *w, ev_tstamp now) [read-write]
-
-The current reschedule callback, or C<0>, if this functionality is
-switched off. Can be changed any time, but changes only take effect when
-the periodic timer fires or C<ev_periodic_again> is being called.
-
-=back
-
-=head3 Examples
-
-Example: Call a callback every hour, or, more precisely, whenever the
-system time is divisible by 3600. The callback invocation times have
-potentially a lot of jitter, but good long-term stability.
-
-   static void
-   clock_cb (struct ev_loop *loop, ev_periodic *w, int revents)
-   {
-     ... its now a full hour (UTC, or TAI or whatever your clock follows)
-   }
-
-   ev_periodic hourly_tick;
-   ev_periodic_init (&hourly_tick, clock_cb, 0., 3600., 0);
-   ev_periodic_start (loop, &hourly_tick);
-
-Example: The same as above, but use a reschedule callback to do it:
-
-   #include <math.h>
-
-   static ev_tstamp
-   my_scheduler_cb (ev_periodic *w, ev_tstamp now)
-   {
-     return now + (3600. - fmod (now, 3600.));
-   }
-
-   ev_periodic_init (&hourly_tick, clock_cb, 0., 0., my_scheduler_cb);
-
-Example: Call a callback every hour, starting now:
-
-   ev_periodic hourly_tick;
-   ev_periodic_init (&hourly_tick, clock_cb,
-                     fmod (ev_now (loop), 3600.), 3600., 0);
-   ev_periodic_start (loop, &hourly_tick);
-
-
-=head2 C<ev_signal> - signal me when a signal gets signalled!
-
-Signal watchers will trigger an event when the process receives a specific
-signal one or more times. Even though signals are very asynchronous, libev
-will try its best to deliver signals synchronously, i.e. as part of the
-normal event processing, like any other event.
-
-If you want signals to be delivered truly asynchronously, just use
-C<sigaction> as you would do without libev and forget about sharing
-the signal. You can even use C<ev_async> from a signal handler to
-synchronously wake up an event loop.
-
-You can configure as many watchers as you like for the same signal, but
-only within the same loop, i.e. you can watch for C<SIGINT> in your
-default loop and for C<SIGIO> in another loop, but you cannot watch for
-C<SIGINT> in both the default loop and another loop at the same time. At
-the moment, C<SIGCHLD> is permanently tied to the default loop.
-
-Only after the first watcher for a signal is started will libev actually
-register something with the kernel. It thus coexists with your own signal
-handlers as long as you don't register any with libev for the same signal.
-
-If possible and supported, libev will install its handlers with
-C<SA_RESTART> (or equivalent) behaviour enabled, so system calls should
-not be unduly interrupted. If you have a problem with system calls getting
-interrupted by signals you can block all signals in an C<ev_check> watcher
-and unblock them in an C<ev_prepare> watcher.
-
-=head3 The special problem of inheritance over fork/execve/pthread_create
-
-Both the signal mask (C<sigprocmask>) and the signal disposition
-(C<sigaction>) are unspecified after starting a signal watcher (and after
-stopping it again), that is, libev might or might not block the signal,
-and might or might not set or restore the installed signal handler (but
-see C<EVFLAG_NOSIGMASK>).
-
-While this does not matter for the signal disposition (libev never
-sets signals to C<SIG_IGN>, so handlers will be reset to C<SIG_DFL> on
-C<execve>), this matters for the signal mask: many programs do not expect
-certain signals to be blocked.
-
-This means that before calling C<exec> (from the child) you should reset
-the signal mask to whatever "default" you expect (all clear is a good
-choice usually).
-
-The simplest way to ensure that the signal mask is reset in the child is
-to install a fork handler with C<pthread_atfork> that resets it. That will
-catch fork calls done by libraries (such as the libc) as well.
-
-In current versions of libev, the signal will not be blocked indefinitely
-unless you use the C<signalfd> API (C<EV_SIGNALFD>). While this reduces
-the window of opportunity for problems, it will not go away, as libev
-I<has> to modify the signal mask, at least temporarily.
-
-So I can't stress this enough: I<If you do not reset your signal mask when
-you expect it to be empty, you have a race condition in your code>. This
-is not a libev-specific thing, this is true for most event libraries.
-
-=head3 The special problem of threads signal handling
-
-POSIX threads has problematic signal handling semantics, specifically,
-a lot of functionality (sigfd, sigwait etc.) only really works if all
-threads in a process block signals, which is hard to achieve.
-
-When you want to use sigwait (or mix libev signal handling with your own
-for the same signals), you can tackle this problem by globally blocking
-all signals before creating any threads (or creating them with a fully set
-sigprocmask) and also specifying the C<EVFLAG_NOSIGMASK> when creating
-loops. Then designate one thread as "signal receiver thread" which handles
-these signals. You can pass on any signals that libev might be interested
-in by calling C<ev_feed_signal>.
-
-=head3 Watcher-Specific Functions and Data Members
-
-=over 4
-
-=item ev_signal_init (ev_signal *, callback, int signum)
-
-=item ev_signal_set (ev_signal *, int signum)
-
-Configures the watcher to trigger on the given signal number (usually one
-of the C<SIGxxx> constants).
-
-=item int signum [read-only]
-
-The signal the watcher watches out for.
-
-=back
-
-=head3 Examples
-
-Example: Try to exit cleanly on SIGINT.
-
-   static void
-   sigint_cb (struct ev_loop *loop, ev_signal *w, int revents)
-   {
-     ev_break (loop, EVBREAK_ALL);
-   }
-
-   ev_signal signal_watcher;
-   ev_signal_init (&signal_watcher, sigint_cb, SIGINT);
-   ev_signal_start (loop, &signal_watcher);
-
-
-=head2 C<ev_child> - watch out for process status changes
-
-Child watchers trigger when your process receives a SIGCHLD in response to
-some child status changes (most typically when a child of yours dies or
-exits). It is permissible to install a child watcher I<after> the child
-has been forked (which implies it might have already exited), as long
-as the event loop isn't entered (or is continued from a watcher), i.e.,
-forking and then immediately registering a watcher for the child is fine,
-but forking and registering a watcher a few event loop iterations later or
-in the next callback invocation is not.
-
-Only the default event loop is capable of handling signals, and therefore
-you can only register child watchers in the default event loop.
-
-Due to some design glitches inside libev, child watchers will always be
-handled at maximum priority (their priority is set to C<EV_MAXPRI> by
-libev)
-
-=head3 Process Interaction
-
-Libev grabs C<SIGCHLD> as soon as the default event loop is
-initialised. This is necessary to guarantee proper behaviour even if the
-first child watcher is started after the child exits. The occurrence
-of C<SIGCHLD> is recorded asynchronously, but child reaping is done
-synchronously as part of the event loop processing. Libev always reaps all
-children, even ones not watched.
-
-=head3 Overriding the Built-In Processing
-
-Libev offers no special support for overriding the built-in child
-processing, but if your application collides with libev's default child
-handler, you can override it easily by installing your own handler for
-C<SIGCHLD> after initialising the default loop, and making sure the
-default loop never gets destroyed. You are encouraged, however, to use an
-event-based approach to child reaping and thus use libev's support for
-that, so other libev users can use C<ev_child> watchers freely.
-
-=head3 Stopping the Child Watcher
-
-Currently, the child watcher never gets stopped, even when the
-child terminates, so normally one needs to stop the watcher in the
-callback. Future versions of libev might stop the watcher automatically
-when a child exit is detected (calling C<ev_child_stop> twice is not a
-problem).
-
-=head3 Watcher-Specific Functions and Data Members
-
-=over 4
-
-=item ev_child_init (ev_child *, callback, int pid, int trace)
-
-=item ev_child_set (ev_child *, int pid, int trace)
-
-Configures the watcher to wait for status changes of process C<pid> (or
-I<any> process if C<pid> is specified as C<0>). The callback can look
-at the C<rstatus> member of the C<ev_child> watcher structure to see
-the status word (use the macros from C<sys/wait.h> and see your systems
-C<waitpid> documentation). The C<rpid> member contains the pid of the
-process causing the status change. C<trace> must be either C<0> (only
-activate the watcher when the process terminates) or C<1> (additionally
-activate the watcher when the process is stopped or continued).
-
-=item int pid [read-only]
-
-The process id this watcher watches out for, or C<0>, meaning any process id.
-
-=item int rpid [read-write]
-
-The process id that detected a status change.
-
-=item int rstatus [read-write]
-
-The process exit/trace status caused by C<rpid> (see your systems
-C<waitpid> and C<sys/wait.h> documentation for details).
-
-=back
-
-=head3 Examples
-
-Example: C<fork()> a new process and install a child handler to wait for
-its completion.
-
-   ev_child cw;
-
-   static void
-   child_cb (EV_P_ ev_child *w, int revents)
-   {
-     ev_child_stop (EV_A_ w);
-     printf ("process %d exited with status %x\n", w->rpid, w->rstatus);
-   }
-
-   pid_t pid = fork ();
-
-   if (pid < 0)
-     // error
-   else if (pid == 0)
-     {
-       // the forked child executes here
-       exit (1);
-     }
-   else
-     {
-       ev_child_init (&cw, child_cb, pid, 0);
-       ev_child_start (EV_DEFAULT_ &cw);
-     }
-
-
-=head2 C<ev_stat> - did the file attributes just change?
-
-This watches a file system path for attribute changes. That is, it calls
-C<stat> on that path in regular intervals (or when the OS says it changed)
-and sees if it changed compared to the last time, invoking the callback
-if it did. Starting the watcher C<stat>'s the file, so only changes that
-happen after the watcher has been started will be reported.
-
-The path does not need to exist: changing from "path exists" to "path does
-not exist" is a status change like any other. The condition "path does not
-exist" (or more correctly "path cannot be stat'ed") is signified by the
-C<st_nlink> field being zero (which is otherwise always forced to be at
-least one) and all the other fields of the stat buffer having unspecified
-contents.
-
-The path I<must not> end in a slash or contain special components such as
-C<.> or C<..>. The path I<should> be absolute: If it is relative and
-your working directory changes, then the behaviour is undefined.
-
-Since there is no portable change notification interface available, the
-portable implementation simply calls C<stat(2)> regularly on the path
-to see if it changed somehow. You can specify a recommended polling
-interval for this case. If you specify a polling interval of C<0> (highly
-recommended!) then a I<suitable, unspecified default> value will be used
-(which you can expect to be around five seconds, although this might
-change dynamically). Libev will also impose a minimum interval which is
-currently around C<0.1>, but that's usually overkill.
-
-This watcher type is not meant for massive numbers of stat watchers,
-as even with OS-supported change notifications, this can be
-resource-intensive.
-
-At the time of this writing, the only OS-specific interface implemented
-is the Linux inotify interface (implementing kqueue support is left as an
-exercise for the reader. Note, however, that the author sees no way of
-implementing C<ev_stat> semantics with kqueue, except as a hint).
-
-=head3 ABI Issues (Largefile Support)
-
-Libev by default (unless the user overrides this) uses the default
-compilation environment, which means that on systems with large file
-support disabled by default, you get the 32 bit version of the stat
-structure. When using the library from programs that change the ABI to
-use 64 bit file offsets the programs will fail. In that case you have to
-compile libev with the same flags to get binary compatibility. This is
-obviously the case with any flags that change the ABI, but the problem is
-most noticeably displayed with ev_stat and large file support.
-
-The solution for this is to lobby your distribution maker to make large
-file interfaces available by default (as e.g. FreeBSD does) and not
-optional. Libev cannot simply switch on large file support because it has
-to exchange stat structures with application programs compiled using the
-default compilation environment.
-
-=head3 Inotify and Kqueue
-
-When C<inotify (7)> support has been compiled into libev and present at
-runtime, it will be used to speed up change detection where possible. The
-inotify descriptor will be created lazily when the first C<ev_stat>
-watcher is being started.
-
-Inotify presence does not change the semantics of C<ev_stat> watchers
-except that changes might be detected earlier, and in some cases, to avoid
-making regular C<stat> calls. Even in the presence of inotify support
-there are many cases where libev has to resort to regular C<stat> polling,
-but as long as kernel 2.6.25 or newer is used (2.6.24 and older have too
-many bugs), the path exists (i.e. stat succeeds), and the path resides on
-a local filesystem (libev currently assumes only ext2/3, jfs, reiserfs and
-xfs are fully working) libev usually gets away without polling.
-
-There is no support for kqueue, as apparently it cannot be used to
-implement this functionality, due to the requirement of having a file
-descriptor open on the object at all times, and detecting renames, unlinks
-etc. is difficult.
-
-=head3 C<stat ()> is a synchronous operation
-
-Libev doesn't normally do any kind of I/O itself, and so is not blocking
-the process. The exception are C<ev_stat> watchers - those call C<stat
-()>, which is a synchronous operation.
-
-For local paths, this usually doesn't matter: unless the system is very
-busy or the intervals between stat's are large, a stat call will be fast,
-as the path data is usually in memory already (except when starting the
-watcher).
-
-For networked file systems, calling C<stat ()> can block an indefinite
-time due to network issues, and even under good conditions, a stat call
-often takes multiple milliseconds.
-
-Therefore, it is best to avoid using C<ev_stat> watchers on networked
-paths, although this is fully supported by libev.
-
-=head3 The special problem of stat time resolution
-
-The C<stat ()> system call only supports full-second resolution portably,
-and even on systems where the resolution is higher, most file systems
-still only support whole seconds.
-
-That means that, if the time is the only thing that changes, you can
-easily miss updates: on the first update, C<ev_stat> detects a change and
-calls your callback, which does something. When there is another update
-within the same second, C<ev_stat> will be unable to detect unless the
-stat data does change in other ways (e.g. file size).
-
-The solution to this is to delay acting on a change for slightly more
-than a second (or till slightly after the next full second boundary), using
-a roughly one-second-delay C<ev_timer> (e.g. C<ev_timer_set (w, 0., 1.02);
-ev_timer_again (loop, w)>).
-
-The C<.02> offset is added to work around small timing inconsistencies
-of some operating systems (where the second counter of the current time
-might be be delayed. One such system is the Linux kernel, where a call to
-C<gettimeofday> might return a timestamp with a full second later than
-a subsequent C<time> call - if the equivalent of C<time ()> is used to
-update file times then there will be a small window where the kernel uses
-the previous second to update file times but libev might already execute
-the timer callback).
-
-=head3 Watcher-Specific Functions and Data Members
-
-=over 4
-
-=item ev_stat_init (ev_stat *, callback, const char *path, ev_tstamp interval)
-
-=item ev_stat_set (ev_stat *, const char *path, ev_tstamp interval)
-
-Configures the watcher to wait for status changes of the given
-C<path>. The C<interval> is a hint on how quickly a change is expected to
-be detected and should normally be specified as C<0> to let libev choose
-a suitable value. The memory pointed to by C<path> must point to the same
-path for as long as the watcher is active.
-
-The callback will receive an C<EV_STAT> event when a change was detected,
-relative to the attributes at the time the watcher was started (or the
-last change was detected).
-
-=item ev_stat_stat (loop, ev_stat *)
-
-Updates the stat buffer immediately with new values. If you change the
-watched path in your callback, you could call this function to avoid
-detecting this change (while introducing a race condition if you are not
-the only one changing the path). Can also be useful simply to find out the
-new values.
-
-=item ev_statdata attr [read-only]
-
-The most-recently detected attributes of the file. Although the type is
-C<ev_statdata>, this is usually the (or one of the) C<struct stat> types
-suitable for your system, but you can only rely on the POSIX-standardised
-members to be present. If the C<st_nlink> member is C<0>, then there was
-some error while C<stat>ing the file.
-
-=item ev_statdata prev [read-only]
-
-The previous attributes of the file. The callback gets invoked whenever
-C<prev> != C<attr>, or, more precisely, one or more of these members
-differ: C<st_dev>, C<st_ino>, C<st_mode>, C<st_nlink>, C<st_uid>,
-C<st_gid>, C<st_rdev>, C<st_size>, C<st_atime>, C<st_mtime>, C<st_ctime>.
-
-=item ev_tstamp interval [read-only]
-
-The specified interval.
-
-=item const char *path [read-only]
-
-The file system path that is being watched.
-
-=back
-
-=head3 Examples
-
-Example: Watch C</etc/passwd> for attribute changes.
-
-   static void
-   passwd_cb (struct ev_loop *loop, ev_stat *w, int revents)
-   {
-     /* /etc/passwd changed in some way */
-     if (w->attr.st_nlink)
-       {
-         printf ("passwd current size  %ld\n", (long)w->attr.st_size);
-         printf ("passwd current atime %ld\n", (long)w->attr.st_mtime);
-         printf ("passwd current mtime %ld\n", (long)w->attr.st_mtime);
-       }
-     else
-       /* you shalt not abuse printf for puts */
-       puts ("wow, /etc/passwd is not there, expect problems. "
-             "if this is windows, they already arrived\n");
-   }
-
-   ...
-   ev_stat passwd;
-
-   ev_stat_init (&passwd, passwd_cb, "/etc/passwd", 0.);
-   ev_stat_start (loop, &passwd);
-
-Example: Like above, but additionally use a one-second delay so we do not
-miss updates (however, frequent updates will delay processing, too, so
-one might do the work both on C<ev_stat> callback invocation I<and> on
-C<ev_timer> callback invocation).
-
-   static ev_stat passwd;
-   static ev_timer timer;
-
-   static void
-   timer_cb (EV_P_ ev_timer *w, int revents)
-   {
-     ev_timer_stop (EV_A_ w);
-
-     /* now it's one second after the most recent passwd change */
-   }
-
-   static void
-   stat_cb (EV_P_ ev_stat *w, int revents)
-   {
-     /* reset the one-second timer */
-     ev_timer_again (EV_A_ &timer);
-   }
-
-   ...
-   ev_stat_init (&passwd, stat_cb, "/etc/passwd", 0.);
-   ev_stat_start (loop, &passwd);
-   ev_timer_init (&timer, timer_cb, 0., 1.02);
-
-
-=head2 C<ev_idle> - when you've got nothing better to do...
-
-Idle watchers trigger events when no other events of the same or higher
-priority are pending (prepare, check and other idle watchers do not count
-as receiving "events").
-
-That is, as long as your process is busy handling sockets or timeouts
-(or even signals, imagine) of the same or higher priority it will not be
-triggered. But when your process is idle (or only lower-priority watchers
-are pending), the idle watchers are being called once per event loop
-iteration - until stopped, that is, or your process receives more events
-and becomes busy again with higher priority stuff.
-
-The most noteworthy effect is that as long as any idle watchers are
-active, the process will not block when waiting for new events.
-
-Apart from keeping your process non-blocking (which is a useful
-effect on its own sometimes), idle watchers are a good place to do
-"pseudo-background processing", or delay processing stuff to after the
-event loop has handled all outstanding events.
-
-=head3 Abusing an C<ev_idle> watcher for its side-effect
-
-As long as there is at least one active idle watcher, libev will never
-sleep unnecessarily. Or in other words, it will loop as fast as possible.
-For this to work, the idle watcher doesn't need to be invoked at all - the
-lowest priority will do.
-
-This mode of operation can be useful together with an C<ev_check> watcher,
-to do something on each event loop iteration - for example to balance load
-between different connections.
-
-See L</Abusing an ev_check watcher for its side-effect> for a longer
-example.
-
-=head3 Watcher-Specific Functions and Data Members
-
-=over 4
-
-=item ev_idle_init (ev_idle *, callback)
-
-Initialises and configures the idle watcher - it has no parameters of any
-kind. There is a C<ev_idle_set> macro, but using it is utterly pointless,
-believe me.
-
-=back
-
-=head3 Examples
-
-Example: Dynamically allocate an C<ev_idle> watcher, start it, and in the
-callback, free it. Also, use no error checking, as usual.
-
-   static void
-   idle_cb (struct ev_loop *loop, ev_idle *w, int revents)
-   {
-     // stop the watcher
-     ev_idle_stop (loop, w);
-
-     // now we can free it
-     free (w);
-
-     // now do something you wanted to do when the program has
-     // no longer anything immediate to do.
-   }
-
-   ev_idle *idle_watcher = malloc (sizeof (ev_idle));
-   ev_idle_init (idle_watcher, idle_cb);
-   ev_idle_start (loop, idle_watcher);
-
-
-=head2 C<ev_prepare> and C<ev_check> - customise your event loop!
-
-Prepare and check watchers are often (but not always) used in pairs:
-prepare watchers get invoked before the process blocks and check watchers
-afterwards.
-
-You I<must not> call C<ev_run> (or similar functions that enter the
-current event loop) or C<ev_loop_fork> from either C<ev_prepare> or
-C<ev_check> watchers. Other loops than the current one are fine,
-however. The rationale behind this is that you do not need to check
-for recursion in those watchers, i.e. the sequence will always be
-C<ev_prepare>, blocking, C<ev_check> so if you have one watcher of each
-kind they will always be called in pairs bracketing the blocking call.
-
-Their main purpose is to integrate other event mechanisms into libev and
-their use is somewhat advanced. They could be used, for example, to track
-variable changes, implement your own watchers, integrate net-snmp or a
-coroutine library and lots more. They are also occasionally useful if
-you cache some data and want to flush it before blocking (for example,
-in X programs you might want to do an C<XFlush ()> in an C<ev_prepare>
-watcher).
-
-This is done by examining in each prepare call which file descriptors
-need to be watched by the other library, registering C<ev_io> watchers
-for them and starting an C<ev_timer> watcher for any timeouts (many
-libraries provide exactly this functionality). Then, in the check watcher,
-you check for any events that occurred (by checking the pending status
-of all watchers and stopping them) and call back into the library. The
-I/O and timer callbacks will never actually be called (but must be valid
-nevertheless, because you never know, you know?).
-
-As another example, the Perl Coro module uses these hooks to integrate
-coroutines into libev programs, by yielding to other active coroutines
-during each prepare and only letting the process block if no coroutines
-are ready to run (it's actually more complicated: it only runs coroutines
-with priority higher than or equal to the event loop and one coroutine
-of lower priority, but only once, using idle watchers to keep the event
-loop from blocking if lower-priority coroutines are active, thus mapping
-low-priority coroutines to idle/background tasks).
-
-When used for this purpose, it is recommended to give C<ev_check> watchers
-highest (C<EV_MAXPRI>) priority, to ensure that they are being run before
-any other watchers after the poll (this doesn't matter for C<ev_prepare>
-watchers).
-
-Also, C<ev_check> watchers (and C<ev_prepare> watchers, too) should not
-activate ("feed") events into libev. While libev fully supports this, they
-might get executed before other C<ev_check> watchers did their job. As
-C<ev_check> watchers are often used to embed other (non-libev) event
-loops those other event loops might be in an unusable state until their
-C<ev_check> watcher ran (always remind yourself to coexist peacefully with
-others).
-
-=head3 Abusing an C<ev_check> watcher for its side-effect
-
-C<ev_check> (and less often also C<ev_prepare>) watchers can also be
-useful because they are called once per event loop iteration. For
-example, if you want to handle a large number of connections fairly, you
-normally only do a bit of work for each active connection, and if there
-is more work to do, you wait for the next event loop iteration, so other
-connections have a chance of making progress.
-
-Using an C<ev_check> watcher is almost enough: it will be called on the
-next event loop iteration. However, that isn't as soon as possible -
-without external events, your C<ev_check> watcher will not be invoked.
-
-This is where C<ev_idle> watchers come in handy - all you need is a
-single global idle watcher that is active as long as you have one active
-C<ev_check> watcher. The C<ev_idle> watcher makes sure the event loop
-will not sleep, and the C<ev_check> watcher makes sure a callback gets
-invoked. Neither watcher alone can do that.
-
-=head3 Watcher-Specific Functions and Data Members
-
-=over 4
-
-=item ev_prepare_init (ev_prepare *, callback)
-
-=item ev_check_init (ev_check *, callback)
-
-Initialises and configures the prepare or check watcher - they have no
-parameters of any kind. There are C<ev_prepare_set> and C<ev_check_set>
-macros, but using them is utterly, utterly, utterly and completely
-pointless.
-
-=back
-
-=head3 Examples
-
-There are a number of principal ways to embed other event loops or modules
-into libev. Here are some ideas on how to include libadns into libev
-(there is a Perl module named C<EV::ADNS> that does this, which you could
-use as a working example. Another Perl module named C<EV::Glib> embeds a
-Glib main context into libev, and finally, C<Glib::EV> embeds EV into the
-Glib event loop).
-
-Method 1: Add IO watchers and a timeout watcher in a prepare handler,
-and in a check watcher, destroy them and call into libadns. What follows
-is pseudo-code only of course. This requires you to either use a low
-priority for the check watcher or use C<ev_clear_pending> explicitly, as
-the callbacks for the IO/timeout watchers might not have been called yet.
-
-   static ev_io iow [nfd];
-   static ev_timer tw;
-
-   static void
-   io_cb (struct ev_loop *loop, ev_io *w, int revents)
-   {
-   }
-
-   // create io watchers for each fd and a timer before blocking
-   static void
-   adns_prepare_cb (struct ev_loop *loop, ev_prepare *w, int revents)
-   {
-     int timeout = 3600000;
-     struct pollfd fds [nfd];
-     // actual code will need to loop here and realloc etc.
-     adns_beforepoll (ads, fds, &nfd, &timeout, timeval_from (ev_time ()));
-
-     /* the callback is illegal, but won't be called as we stop during check */
-     ev_timer_init (&tw, 0, timeout * 1e-3, 0.);
-     ev_timer_start (loop, &tw);
-
-     // create one ev_io per pollfd
-     for (int i = 0; i < nfd; ++i)
-       {
-         ev_io_init (iow + i, io_cb, fds [i].fd,
-           ((fds [i].events & POLLIN ? EV_READ : 0)
-            | (fds [i].events & POLLOUT ? EV_WRITE : 0)));
-
-         fds [i].revents = 0;
-         ev_io_start (loop, iow + i);
-       }
-   }
-
-   // stop all watchers after blocking
-   static void
-   adns_check_cb (struct ev_loop *loop, ev_check *w, int revents)
-   {
-     ev_timer_stop (loop, &tw);
-
-     for (int i = 0; i < nfd; ++i)
-       {
-         // set the relevant poll flags
-         // could also call adns_processreadable etc. here
-         struct pollfd *fd = fds + i;
-         int revents = ev_clear_pending (iow + i);
-         if (revents & EV_READ ) fd->revents |= fd->events & POLLIN;
-         if (revents & EV_WRITE) fd->revents |= fd->events & POLLOUT;
-
-         // now stop the watcher
-         ev_io_stop (loop, iow + i);
-       }
-
-     adns_afterpoll (adns, fds, nfd, timeval_from (ev_now (loop));
-   }
-
-Method 2: This would be just like method 1, but you run C<adns_afterpoll>
-in the prepare watcher and would dispose of the check watcher.
-
-Method 3: If the module to be embedded supports explicit event
-notification (libadns does), you can also make use of the actual watcher
-callbacks, and only destroy/create the watchers in the prepare watcher.
-
-   static void
-   timer_cb (EV_P_ ev_timer *w, int revents)
-   {
-     adns_state ads = (adns_state)w->data;
-     update_now (EV_A);
-
-     adns_processtimeouts (ads, &tv_now);
-   }
-
-   static void
-   io_cb (EV_P_ ev_io *w, int revents)
-   {
-     adns_state ads = (adns_state)w->data;
-     update_now (EV_A);
-
-     if (revents & EV_READ ) adns_processreadable  (ads, w->fd, &tv_now);
-     if (revents & EV_WRITE) adns_processwriteable (ads, w->fd, &tv_now);
-   }
-
-   // do not ever call adns_afterpoll
-
-Method 4: Do not use a prepare or check watcher because the module you
-want to embed is not flexible enough to support it. Instead, you can
-override their poll function. The drawback with this solution is that the
-main loop is now no longer controllable by EV. The C<Glib::EV> module uses
-this approach, effectively embedding EV as a client into the horrible
-libglib event loop.
-
-   static gint
-   event_poll_func (GPollFD *fds, guint nfds, gint timeout)
-   {
-     int got_events = 0;
-
-     for (n = 0; n < nfds; ++n)
-       // create/start io watcher that sets the relevant bits in fds[n] and increment got_events
-
-     if (timeout >= 0)
-       // create/start timer
-
-     // poll
-     ev_run (EV_A_ 0);
-
-     // stop timer again
-     if (timeout >= 0)
-       ev_timer_stop (EV_A_ &to);
-
-     // stop io watchers again - their callbacks should have set
-     for (n = 0; n < nfds; ++n)
-       ev_io_stop (EV_A_ iow [n]);
-
-     return got_events;
-   }
-
-
-=head2 C<ev_embed> - when one backend isn't enough...
-
-This is a rather advanced watcher type that lets you embed one event loop
-into another (currently only C<ev_io> events are supported in the embedded
-loop, other types of watchers might be handled in a delayed or incorrect
-fashion and must not be used).
-
-There are primarily two reasons you would want that: work around bugs and
-prioritise I/O.
-
-As an example for a bug workaround, the kqueue backend might only support
-sockets on some platform, so it is unusable as generic backend, but you
-still want to make use of it because you have many sockets and it scales
-so nicely. In this case, you would create a kqueue-based loop and embed
-it into your default loop (which might use e.g. poll). Overall operation
-will be a bit slower because first libev has to call C<poll> and then
-C<kevent>, but at least you can use both mechanisms for what they are
-best: C<kqueue> for scalable sockets and C<poll> if you want it to work :)
-
-As for prioritising I/O: under rare circumstances you have the case where
-some fds have to be watched and handled very quickly (with low latency),
-and even priorities and idle watchers might have too much overhead. In
-this case you would put all the high priority stuff in one loop and all
-the rest in a second one, and embed the second one in the first.
-
-As long as the watcher is active, the callback will be invoked every
-time there might be events pending in the embedded loop. The callback
-must then call C<ev_embed_sweep (mainloop, watcher)> to make a single
-sweep and invoke their callbacks (the callback doesn't need to invoke the
-C<ev_embed_sweep> function directly, it could also start an idle watcher
-to give the embedded loop strictly lower priority for example).
-
-You can also set the callback to C<0>, in which case the embed watcher
-will automatically execute the embedded loop sweep whenever necessary.
-
-Fork detection will be handled transparently while the C<ev_embed> watcher
-is active, i.e., the embedded loop will automatically be forked when the
-embedding loop forks. In other cases, the user is responsible for calling
-C<ev_loop_fork> on the embedded loop.
-
-Unfortunately, not all backends are embeddable: only the ones returned by
-C<ev_embeddable_backends> are, which, unfortunately, does not include any
-portable one.
-
-So when you want to use this feature you will always have to be prepared
-that you cannot get an embeddable loop. The recommended way to get around
-this is to have a separate variables for your embeddable loop, try to
-create it, and if that fails, use the normal loop for everything.
-
-=head3 C<ev_embed> and fork
-
-While the C<ev_embed> watcher is running, forks in the embedding loop will
-automatically be applied to the embedded loop as well, so no special
-fork handling is required in that case. When the watcher is not running,
-however, it is still the task of the libev user to call C<ev_loop_fork ()>
-as applicable.
-
-=head3 Watcher-Specific Functions and Data Members
-
-=over 4
-
-=item ev_embed_init (ev_embed *, callback, struct ev_loop *embedded_loop)
-
-=item ev_embed_set (ev_embed *, struct ev_loop *embedded_loop)
-
-Configures the watcher to embed the given loop, which must be
-embeddable. If the callback is C<0>, then C<ev_embed_sweep> will be
-invoked automatically, otherwise it is the responsibility of the callback
-to invoke it (it will continue to be called until the sweep has been done,
-if you do not want that, you need to temporarily stop the embed watcher).
-
-=item ev_embed_sweep (loop, ev_embed *)
-
-Make a single, non-blocking sweep over the embedded loop. This works
-similarly to C<ev_run (embedded_loop, EVRUN_NOWAIT)>, but in the most
-appropriate way for embedded loops.
-
-=item struct ev_loop *other [read-only]
-
-The embedded event loop.
-
-=back
-
-=head3 Examples
-
-Example: Try to get an embeddable event loop and embed it into the default
-event loop. If that is not possible, use the default loop. The default
-loop is stored in C<loop_hi>, while the embeddable loop is stored in
-C<loop_lo> (which is C<loop_hi> in the case no embeddable loop can be
-used).
-
-   struct ev_loop *loop_hi = ev_default_init (0);
-   struct ev_loop *loop_lo = 0;
-   ev_embed embed;
-
-   // see if there is a chance of getting one that works
-   // (remember that a flags value of 0 means autodetection)
-   loop_lo = ev_embeddable_backends () & ev_recommended_backends ()
-     ? ev_loop_new (ev_embeddable_backends () & ev_recommended_backends ())
-     : 0;
-
-   // if we got one, then embed it, otherwise default to loop_hi
-   if (loop_lo)
-     {
-       ev_embed_init (&embed, 0, loop_lo);
-       ev_embed_start (loop_hi, &embed);
-     }
-   else
-     loop_lo = loop_hi;
-
-Example: Check if kqueue is available but not recommended and create
-a kqueue backend for use with sockets (which usually work with any
-kqueue implementation). Store the kqueue/socket-only event loop in
-C<loop_socket>. (One might optionally use C<EVFLAG_NOENV>, too).
-
-   struct ev_loop *loop = ev_default_init (0);
-   struct ev_loop *loop_socket = 0;
-   ev_embed embed;
-
-   if (ev_supported_backends () & ~ev_recommended_backends () & EVBACKEND_KQUEUE)
-     if ((loop_socket = ev_loop_new (EVBACKEND_KQUEUE))
-       {
-         ev_embed_init (&embed, 0, loop_socket);
-         ev_embed_start (loop, &embed);
-       }
-
-   if (!loop_socket)
-     loop_socket = loop;
-
-   // now use loop_socket for all sockets, and loop for everything else
-
-
-=head2 C<ev_fork> - the audacity to resume the event loop after a fork
-
-Fork watchers are called when a C<fork ()> was detected (usually because
-whoever is a good citizen cared to tell libev about it by calling
-C<ev_loop_fork>). The invocation is done before the event loop blocks next
-and before C<ev_check> watchers are being called, and only in the child
-after the fork. If whoever good citizen calling C<ev_default_fork> cheats
-and calls it in the wrong process, the fork handlers will be invoked, too,
-of course.
-
-=head3 The special problem of life after fork - how is it possible?
-
-Most uses of C<fork ()> consist of forking, then some simple calls to set
-up/change the process environment, followed by a call to C<exec()>. This
-sequence should be handled by libev without any problems.
-
-This changes when the application actually wants to do event handling
-in the child, or both parent in child, in effect "continuing" after the
-fork.
-
-The default mode of operation (for libev, with application help to detect
-forks) is to duplicate all the state in the child, as would be expected
-when I<either> the parent I<or> the child process continues.
-
-When both processes want to continue using libev, then this is usually the
-wrong result. In that case, usually one process (typically the parent) is
-supposed to continue with all watchers in place as before, while the other
-process typically wants to start fresh, i.e. without any active watchers.
-
-The cleanest and most efficient way to achieve that with libev is to
-simply create a new event loop, which of course will be "empty", and
-use that for new watchers. This has the advantage of not touching more
-memory than necessary, and thus avoiding the copy-on-write, and the
-disadvantage of having to use multiple event loops (which do not support
-signal watchers).
-
-When this is not possible, or you want to use the default loop for
-other reasons, then in the process that wants to start "fresh", call
-C<ev_loop_destroy (EV_DEFAULT)> followed by C<ev_default_loop (...)>.
-Destroying the default loop will "orphan" (not stop) all registered
-watchers, so you have to be careful not to execute code that modifies
-those watchers. Note also that in that case, you have to re-register any
-signal watchers.
-
-=head3 Watcher-Specific Functions and Data Members
-
-=over 4
-
-=item ev_fork_init (ev_fork *, callback)
-
-Initialises and configures the fork watcher - it has no parameters of any
-kind. There is a C<ev_fork_set> macro, but using it is utterly pointless,
-really.
-
-=back
-
-
-=head2 C<ev_cleanup> - even the best things end
-
-Cleanup watchers are called just before the event loop is being destroyed
-by a call to C<ev_loop_destroy>.
-
-While there is no guarantee that the event loop gets destroyed, cleanup
-watchers provide a convenient method to install cleanup hooks for your
-program, worker threads and so on - you just to make sure to destroy the
-loop when you want them to be invoked.
-
-Cleanup watchers are invoked in the same way as any other watcher. Unlike
-all other watchers, they do not keep a reference to the event loop (which
-makes a lot of sense if you think about it). Like all other watchers, you
-can call libev functions in the callback, except C<ev_cleanup_start>.
-
-=head3 Watcher-Specific Functions and Data Members
-
-=over 4
-
-=item ev_cleanup_init (ev_cleanup *, callback)
-
-Initialises and configures the cleanup watcher - it has no parameters of
-any kind. There is a C<ev_cleanup_set> macro, but using it is utterly
-pointless, I assure you.
-
-=back
-
-Example: Register an atexit handler to destroy the default loop, so any
-cleanup functions are called.
-
-   static void
-   program_exits (void)
-   {
-     ev_loop_destroy (EV_DEFAULT_UC);
-   }
-
-   ...
-   atexit (program_exits);
-
-
-=head2 C<ev_async> - how to wake up an event loop
-
-In general, you cannot use an C<ev_loop> from multiple threads or other
-asynchronous sources such as signal handlers (as opposed to multiple event
-loops - those are of course safe to use in different threads).
-
-Sometimes, however, you need to wake up an event loop you do not control,
-for example because it belongs to another thread. This is what C<ev_async>
-watchers do: as long as the C<ev_async> watcher is active, you can signal
-it by calling C<ev_async_send>, which is thread- and signal safe.
-
-This functionality is very similar to C<ev_signal> watchers, as signals,
-too, are asynchronous in nature, and signals, too, will be compressed
-(i.e. the number of callback invocations may be less than the number of
-C<ev_async_send> calls). In fact, you could use signal watchers as a kind
-of "global async watchers" by using a watcher on an otherwise unused
-signal, and C<ev_feed_signal> to signal this watcher from another thread,
-even without knowing which loop owns the signal.
-
-=head3 Queueing
-
-C<ev_async> does not support queueing of data in any way. The reason
-is that the author does not know of a simple (or any) algorithm for a
-multiple-writer-single-reader queue that works in all cases and doesn't
-need elaborate support such as pthreads or unportable memory access
-semantics.
-
-That means that if you want to queue data, you have to provide your own
-queue. But at least I can tell you how to implement locking around your
-queue:
-
-=over 4
-
-=item queueing from a signal handler context
-
-To implement race-free queueing, you simply add to the queue in the signal
-handler but you block the signal handler in the watcher callback. Here is
-an example that does that for some fictitious SIGUSR1 handler:
-
-   static ev_async mysig;
-
-   static void
-   sigusr1_handler (void)
-   {
-     sometype data;
-
-     // no locking etc.
-     queue_put (data);
-     ev_async_send (EV_DEFAULT_ &mysig);
-   }
-
-   static void
-   mysig_cb (EV_P_ ev_async *w, int revents)
-   {
-     sometype data;
-     sigset_t block, prev;
-
-     sigemptyset (&block);
-     sigaddset (&block, SIGUSR1);
-     sigprocmask (SIG_BLOCK, &block, &prev);
-
-     while (queue_get (&data))
-       process (data);
-
-     if (sigismember (&prev, SIGUSR1)
-       sigprocmask (SIG_UNBLOCK, &block, 0);
-   }
-
-(Note: pthreads in theory requires you to use C<pthread_setmask>
-instead of C<sigprocmask> when you use threads, but libev doesn't do it
-either...).
-
-=item queueing from a thread context
-
-The strategy for threads is different, as you cannot (easily) block
-threads but you can easily preempt them, so to queue safely you need to
-employ a traditional mutex lock, such as in this pthread example:
-
-   static ev_async mysig;
-   static pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER;
-
-   static void
-   otherthread (void)
-   {
-     // only need to lock the actual queueing operation
-     pthread_mutex_lock (&mymutex);
-     queue_put (data);
-     pthread_mutex_unlock (&mymutex);
-
-     ev_async_send (EV_DEFAULT_ &mysig);
-   }
-
-   static void
-   mysig_cb (EV_P_ ev_async *w, int revents)
-   {
-     pthread_mutex_lock (&mymutex);
-
-     while (queue_get (&data))
-       process (data);
-
-     pthread_mutex_unlock (&mymutex);
-   }
-
-=back
-
-
-=head3 Watcher-Specific Functions and Data Members
-
-=over 4
-
-=item ev_async_init (ev_async *, callback)
-
-Initialises and configures the async watcher - it has no parameters of any
-kind. There is a C<ev_async_set> macro, but using it is utterly pointless,
-trust me.
-
-=item ev_async_send (loop, ev_async *)
-
-Sends/signals/activates the given C<ev_async> watcher, that is, feeds
-an C<EV_ASYNC> event on the watcher into the event loop, and instantly
-returns.
-
-Unlike C<ev_feed_event>, this call is safe to do from other threads,
-signal or similar contexts (see the discussion of C<EV_ATOMIC_T> in the
-embedding section below on what exactly this means).
-
-Note that, as with other watchers in libev, multiple events might get
-compressed into a single callback invocation (another way to look at
-this is that C<ev_async> watchers are level-triggered: they are set on
-C<ev_async_send>, reset when the event loop detects that).
-
-This call incurs the overhead of at most one extra system call per event
-loop iteration, if the event loop is blocked, and no syscall at all if
-the event loop (or your program) is processing events. That means that
-repeated calls are basically free (there is no need to avoid calls for
-performance reasons) and that the overhead becomes smaller (typically
-zero) under load.
-
-=item bool = ev_async_pending (ev_async *)
-
-Returns a non-zero value when C<ev_async_send> has been called on the
-watcher but the event has not yet been processed (or even noted) by the
-event loop.
-
-C<ev_async_send> sets a flag in the watcher and wakes up the loop. When
-the loop iterates next and checks for the watcher to have become active,
-it will reset the flag again. C<ev_async_pending> can be used to very
-quickly check whether invoking the loop might be a good idea.
-
-Not that this does I<not> check whether the watcher itself is pending,
-only whether it has been requested to make this watcher pending: there
-is a time window between the event loop checking and resetting the async
-notification, and the callback being invoked.
-
-=back
-
-
-=head1 OTHER FUNCTIONS
-
-There are some other functions of possible interest. Described. Here. Now.
-
-=over 4
-
-=item ev_once (loop, int fd, int events, ev_tstamp timeout, callback)
-
-This function combines a simple timer and an I/O watcher, calls your
-callback on whichever event happens first and automatically stops both
-watchers. This is useful if you want to wait for a single event on an fd
-or timeout without having to allocate/configure/start/stop/free one or
-more watchers yourself.
-
-If C<fd> is less than 0, then no I/O watcher will be started and the
-C<events> argument is being ignored. Otherwise, an C<ev_io> watcher for
-the given C<fd> and C<events> set will be created and started.
-
-If C<timeout> is less than 0, then no timeout watcher will be
-started. Otherwise an C<ev_timer> watcher with after = C<timeout> (and
-repeat = 0) will be started. C<0> is a valid timeout.
-
-The callback has the type C<void (*cb)(int revents, void *arg)> and is
-passed an C<revents> set like normal event callbacks (a combination of
-C<EV_ERROR>, C<EV_READ>, C<EV_WRITE> or C<EV_TIMER>) and the C<arg>
-value passed to C<ev_once>. Note that it is possible to receive I<both>
-a timeout and an io event at the same time - you probably should give io
-events precedence.
-
-Example: wait up to ten seconds for data to appear on STDIN_FILENO.
-
-   static void stdin_ready (int revents, void *arg)
-   {
-     if (revents & EV_READ)
-       /* stdin might have data for us, joy! */;
-     else if (revents & EV_TIMER)
-       /* doh, nothing entered */;
-   }
-
-   ev_once (STDIN_FILENO, EV_READ, 10., stdin_ready, 0);
-
-=item ev_feed_fd_event (loop, int fd, int revents)
-
-Feed an event on the given fd, as if a file descriptor backend detected
-the given events.
-
-=item ev_feed_signal_event (loop, int signum)
-
-Feed an event as if the given signal occurred. See also C<ev_feed_signal>,
-which is async-safe.
-
-=back
-
-
-=head1 COMMON OR USEFUL IDIOMS (OR BOTH)
-
-This section explains some common idioms that are not immediately
-obvious. Note that examples are sprinkled over the whole manual, and this
-section only contains stuff that wouldn't fit anywhere else.
-
-=head2 ASSOCIATING CUSTOM DATA WITH A WATCHER
-
-Each watcher has, by default, a C<void *data> member that you can read
-or modify at any time: libev will completely ignore it. This can be used
-to associate arbitrary data with your watcher. If you need more data and
-don't want to allocate memory separately and store a pointer to it in that
-data member, you can also "subclass" the watcher type and provide your own
-data:
-
-   struct my_io
-   {
-     ev_io io;
-     int otherfd;
-     void *somedata;
-     struct whatever *mostinteresting;
-   };
-
-   ...
-   struct my_io w;
-   ev_io_init (&w.io, my_cb, fd, EV_READ);
-
-And since your callback will be called with a pointer to the watcher, you
-can cast it back to your own type:
-
-   static void my_cb (struct ev_loop *loop, ev_io *w_, int revents)
-   {
-     struct my_io *w = (struct my_io *)w_;
-     ...
-   }
-
-More interesting and less C-conformant ways of casting your callback
-function type instead have been omitted.
-
-=head2 BUILDING YOUR OWN COMPOSITE WATCHERS
-
-Another common scenario is to use some data structure with multiple
-embedded watchers, in effect creating your own watcher that combines
-multiple libev event sources into one "super-watcher":
-
-   struct my_biggy
-   {
-     int some_data;
-     ev_timer t1;
-     ev_timer t2;
-   }
-
-In this case getting the pointer to C<my_biggy> is a bit more
-complicated: Either you store the address of your C<my_biggy> struct in
-the C<data> member of the watcher (for woozies or C++ coders), or you need
-to use some pointer arithmetic using C<offsetof> inside your watchers (for
-real programmers):
-
-   #include <stddef.h>
-
-   static void
-   t1_cb (EV_P_ ev_timer *w, int revents)
-   {
-     struct my_biggy big = (struct my_biggy *)
-       (((char *)w) - offsetof (struct my_biggy, t1));
-   }
-
-   static void
-   t2_cb (EV_P_ ev_timer *w, int revents)
-   {
-     struct my_biggy big = (struct my_biggy *)
-       (((char *)w) - offsetof (struct my_biggy, t2));
-   }
-
-=head2 AVOIDING FINISHING BEFORE RETURNING
-
-Often you have structures like this in event-based programs:
-
-  callback ()
-  {
-    free (request);
-  }
-
-  request = start_new_request (..., callback);
-
-The intent is to start some "lengthy" operation. The C<request> could be
-used to cancel the operation, or do other things with it.
-
-It's not uncommon to have code paths in C<start_new_request> that
-immediately invoke the callback, for example, to report errors. Or you add
-some caching layer that finds that it can skip the lengthy aspects of the
-operation and simply invoke the callback with the result.
-
-The problem here is that this will happen I<before> C<start_new_request>
-has returned, so C<request> is not set.
-
-Even if you pass the request by some safer means to the callback, you
-might want to do something to the request after starting it, such as
-canceling it, which probably isn't working so well when the callback has
-already been invoked.
-
-A common way around all these issues is to make sure that
-C<start_new_request> I<always> returns before the callback is invoked. If
-C<start_new_request> immediately knows the result, it can artificially
-delay invoking the callback by using a C<prepare> or C<idle> watcher for
-example, or more sneakily, by reusing an existing (stopped) watcher and
-pushing it into the pending queue:
-
-   ev_set_cb (watcher, callback);
-   ev_feed_event (EV_A_ watcher, 0);
-
-This way, C<start_new_request> can safely return before the callback is
-invoked, while not delaying callback invocation too much.
-
-=head2 MODEL/NESTED EVENT LOOP INVOCATIONS AND EXIT CONDITIONS
-
-Often (especially in GUI toolkits) there are places where you have
-I<modal> interaction, which is most easily implemented by recursively
-invoking C<ev_run>.
-
-This brings the problem of exiting - a callback might want to finish the
-main C<ev_run> call, but not the nested one (e.g. user clicked "Quit", but
-a modal "Are you sure?" dialog is still waiting), or just the nested one
-and not the main one (e.g. user clocked "Ok" in a modal dialog), or some
-other combination: In these cases, a simple C<ev_break> will not work.
-
-The solution is to maintain "break this loop" variable for each C<ev_run>
-invocation, and use a loop around C<ev_run> until the condition is
-triggered, using C<EVRUN_ONCE>:
-
-   // main loop
-   int exit_main_loop = 0;
-
-   while (!exit_main_loop)
-     ev_run (EV_DEFAULT_ EVRUN_ONCE);
-
-   // in a modal watcher
-   int exit_nested_loop = 0;
-
-   while (!exit_nested_loop)
-     ev_run (EV_A_ EVRUN_ONCE);
-
-To exit from any of these loops, just set the corresponding exit variable:
-
-   // exit modal loop
-   exit_nested_loop = 1;
-
-   // exit main program, after modal loop is finished
-   exit_main_loop = 1;
-
-   // exit both
-   exit_main_loop = exit_nested_loop = 1;
-
-=head2 THREAD LOCKING EXAMPLE
-
-Here is a fictitious example of how to run an event loop in a different
-thread from where callbacks are being invoked and watchers are
-created/added/removed.
-
-For a real-world example, see the C<EV::Loop::Async> perl module,
-which uses exactly this technique (which is suited for many high-level
-languages).
-
-The example uses a pthread mutex to protect the loop data, a condition
-variable to wait for callback invocations, an async watcher to notify the
-event loop thread and an unspecified mechanism to wake up the main thread.
-
-First, you need to associate some data with the event loop:
-
-   typedef struct {
-     mutex_t lock; /* global loop lock */
-     ev_async async_w;
-     thread_t tid;
-     cond_t invoke_cv;
-   } userdata;
-
-   void prepare_loop (EV_P)
-   {
-      // for simplicity, we use a static userdata struct.
-      static userdata u;
-
-      ev_async_init (&u->async_w, async_cb);
-      ev_async_start (EV_A_ &u->async_w);
-
-      pthread_mutex_init (&u->lock, 0);
-      pthread_cond_init (&u->invoke_cv, 0);
-
-      // now associate this with the loop
-      ev_set_userdata (EV_A_ u);
-      ev_set_invoke_pending_cb (EV_A_ l_invoke);
-      ev_set_loop_release_cb (EV_A_ l_release, l_acquire);
-
-      // then create the thread running ev_run
-      pthread_create (&u->tid, 0, l_run, EV_A);
-   }
-
-The callback for the C<ev_async> watcher does nothing: the watcher is used
-solely to wake up the event loop so it takes notice of any new watchers
-that might have been added:
-
-   static void
-   async_cb (EV_P_ ev_async *w, int revents)
-   {
-      // just used for the side effects
-   }
-
-The C<l_release> and C<l_acquire> callbacks simply unlock/lock the mutex
-protecting the loop data, respectively.
-
-   static void
-   l_release (EV_P)
-   {
-     userdata *u = ev_userdata (EV_A);
-     pthread_mutex_unlock (&u->lock);
-   }
-
-   static void
-   l_acquire (EV_P)
-   {
-     userdata *u = ev_userdata (EV_A);
-     pthread_mutex_lock (&u->lock);
-   }
-
-The event loop thread first acquires the mutex, and then jumps straight
-into C<ev_run>:
-
-   void *
-   l_run (void *thr_arg)
-   {
-     struct ev_loop *loop = (struct ev_loop *)thr_arg;
-
-     l_acquire (EV_A);
-     pthread_setcanceltype (PTHREAD_CANCEL_ASYNCHRONOUS, 0);
-     ev_run (EV_A_ 0);
-     l_release (EV_A);
-
-     return 0;
-   }
-
-Instead of invoking all pending watchers, the C<l_invoke> callback will
-signal the main thread via some unspecified mechanism (signals? pipe
-writes? C<Async::Interrupt>?) and then waits until all pending watchers
-have been called (in a while loop because a) spurious wakeups are possible
-and b) skipping inter-thread-communication when there are no pending
-watchers is very beneficial):
-
-   static void
-   l_invoke (EV_P)
-   {
-     userdata *u = ev_userdata (EV_A);
-
-     while (ev_pending_count (EV_A))
-       {
-         wake_up_other_thread_in_some_magic_or_not_so_magic_way ();
-         pthread_cond_wait (&u->invoke_cv, &u->lock);
-       }
-   }
-
-Now, whenever the main thread gets told to invoke pending watchers, it
-will grab the lock, call C<ev_invoke_pending> and then signal the loop
-thread to continue:
-
-   static void
-   real_invoke_pending (EV_P)
-   {
-     userdata *u = ev_userdata (EV_A);
-
-     pthread_mutex_lock (&u->lock);
-     ev_invoke_pending (EV_A);
-     pthread_cond_signal (&u->invoke_cv);
-     pthread_mutex_unlock (&u->lock);
-   }
-
-Whenever you want to start/stop a watcher or do other modifications to an
-event loop, you will now have to lock:
-
-   ev_timer timeout_watcher;
-   userdata *u = ev_userdata (EV_A);
-
-   ev_timer_init (&timeout_watcher, timeout_cb, 5.5, 0.);
-
-   pthread_mutex_lock (&u->lock);
-   ev_timer_start (EV_A_ &timeout_watcher);
-   ev_async_send (EV_A_ &u->async_w);
-   pthread_mutex_unlock (&u->lock);
-
-Note that sending the C<ev_async> watcher is required because otherwise
-an event loop currently blocking in the kernel will have no knowledge
-about the newly added timer. By waking up the loop it will pick up any new
-watchers in the next event loop iteration.
-
-=head2 THREADS, COROUTINES, CONTINUATIONS, QUEUES... INSTEAD OF CALLBACKS
-
-While the overhead of a callback that e.g. schedules a thread is small, it
-is still an overhead. If you embed libev, and your main usage is with some
-kind of threads or coroutines, you might want to customise libev so that
-doesn't need callbacks anymore.
-
-Imagine you have coroutines that you can switch to using a function
-C<switch_to (coro)>, that libev runs in a coroutine called C<libev_coro>
-and that due to some magic, the currently active coroutine is stored in a
-global called C<current_coro>. Then you can build your own "wait for libev
-event" primitive by changing C<EV_CB_DECLARE> and C<EV_CB_INVOKE> (note
-the differing C<;> conventions):
-
-   #define EV_CB_DECLARE(type)   struct my_coro *cb;
-   #define EV_CB_INVOKE(watcher) switch_to ((watcher)->cb)
-
-That means instead of having a C callback function, you store the
-coroutine to switch to in each watcher, and instead of having libev call
-your callback, you instead have it switch to that coroutine.
-
-A coroutine might now wait for an event with a function called
-C<wait_for_event>. (the watcher needs to be started, as always, but it doesn't
-matter when, or whether the watcher is active or not when this function is
-called):
-
-   void
-   wait_for_event (ev_watcher *w)
-   {
-     ev_set_cb (w, current_coro);
-     switch_to (libev_coro);
-   }
-
-That basically suspends the coroutine inside C<wait_for_event> and
-continues the libev coroutine, which, when appropriate, switches back to
-this or any other coroutine.
-
-You can do similar tricks if you have, say, threads with an event queue -
-instead of storing a coroutine, you store the queue object and instead of
-switching to a coroutine, you push the watcher onto the queue and notify
-any waiters.
-
-To embed libev, see L</EMBEDDING>, but in short, it's easiest to create two
-files, F<my_ev.h> and F<my_ev.c> that include the respective libev files:
-
-   // my_ev.h
-   #define EV_CB_DECLARE(type)   struct my_coro *cb;
-   #define EV_CB_INVOKE(watcher) switch_to ((watcher)->cb)
-   #include "../libev/ev.h"
-
-   // my_ev.c
-   #define EV_H "my_ev.h"
-   #include "../libev/ev.c"
-
-And then use F<my_ev.h> when you would normally use F<ev.h>, and compile
-F<my_ev.c> into your project. When properly specifying include paths, you
-can even use F<ev.h> as header file name directly.
-
-
-=head1 LIBEVENT EMULATION
-
-Libev offers a compatibility emulation layer for libevent. It cannot
-emulate the internals of libevent, so here are some usage hints:
-
-=over 4
-
-=item * Only the libevent-1.4.1-beta API is being emulated.
-
-This was the newest libevent version available when libev was implemented,
-and is still mostly unchanged in 2010.
-
-=item * Use it by including <event.h>, as usual.
-
-=item * The following members are fully supported: ev_base, ev_callback,
-ev_arg, ev_fd, ev_res, ev_events.
-
-=item * Avoid using ev_flags and the EVLIST_*-macros, while it is
-maintained by libev, it does not work exactly the same way as in libevent (consider
-it a private API).
-
-=item * Priorities are not currently supported. Initialising priorities
-will fail and all watchers will have the same priority, even though there
-is an ev_pri field.
-
-=item * In libevent, the last base created gets the signals, in libev, the
-base that registered the signal gets the signals.
-
-=item * Other members are not supported.
-
-=item * The libev emulation is I<not> ABI compatible to libevent, you need
-to use the libev header file and library.
-
-=back
-
-=head1 C++ SUPPORT
-
-=head2 C API
-
-The normal C API should work fine when used from C++: both ev.h and the
-libev sources can be compiled as C++. Therefore, code that uses the C API
-will work fine.
-
-Proper exception specifications might have to be added to callbacks passed
-to libev: exceptions may be thrown only from watcher callbacks, all
-other callbacks (allocator, syserr, loop acquire/release and periodic
-reschedule callbacks) must not throw exceptions, and might need a C<throw
-()> specification. If you have code that needs to be compiled as both C
-and C++ you can use the C<EV_THROW> macro for this:
-
-   static void
-   fatal_error (const char *msg) EV_THROW
-   {
-     perror (msg);
-     abort ();
-   }
-
-   ...
-   ev_set_syserr_cb (fatal_error);
-
-The only API functions that can currently throw exceptions are C<ev_run>,
-C<ev_invoke>, C<ev_invoke_pending> and C<ev_loop_destroy> (the latter
-because it runs cleanup watchers).
-
-Throwing exceptions in watcher callbacks is only supported if libev itself
-is compiled with a C++ compiler or your C and C++ environments allow
-throwing exceptions through C libraries (most do).
-
-=head2 C++ API
-
-Libev comes with some simplistic wrapper classes for C++ that mainly allow
-you to use some convenience methods to start/stop watchers and also change
-the callback model to a model using method callbacks on objects.
-
-To use it,
-
-   #include <ev++.h>
-
-This automatically includes F<ev.h> and puts all of its definitions (many
-of them macros) into the global namespace. All C++ specific things are
-put into the C<ev> namespace. It should support all the same embedding
-options as F<ev.h>, most notably C<EV_MULTIPLICITY>.
-
-Care has been taken to keep the overhead low. The only data member the C++
-classes add (compared to plain C-style watchers) is the event loop pointer
-that the watcher is associated with (or no additional members at all if
-you disable C<EV_MULTIPLICITY> when embedding libev).
-
-Currently, functions, static and non-static member functions and classes
-with C<operator ()> can be used as callbacks. Other types should be easy
-to add as long as they only need one additional pointer for context. If
-you need support for other types of functors please contact the author
-(preferably after implementing it).
-
-For all this to work, your C++ compiler either has to use the same calling
-conventions as your C compiler (for static member functions), or you have
-to embed libev and compile libev itself as C++.
-
-Here is a list of things available in the C<ev> namespace:
-
-=over 4
-
-=item C<ev::READ>, C<ev::WRITE> etc.
-
-These are just enum values with the same values as the C<EV_READ> etc.
-macros from F<ev.h>.
-
-=item C<ev::tstamp>, C<ev::now>
-
-Aliases to the same types/functions as with the C<ev_> prefix.
-
-=item C<ev::io>, C<ev::timer>, C<ev::periodic>, C<ev::idle>, C<ev::sig> etc.
-
-For each C<ev_TYPE> watcher in F<ev.h> there is a corresponding class of
-the same name in the C<ev> namespace, with the exception of C<ev_signal>
-which is called C<ev::sig> to avoid clashes with the C<signal> macro
-defined by many implementations.
-
-All of those classes have these methods:
-
-=over 4
-
-=item ev::TYPE::TYPE ()
-
-=item ev::TYPE::TYPE (loop)
-
-=item ev::TYPE::~TYPE
-
-The constructor (optionally) takes an event loop to associate the watcher
-with. If it is omitted, it will use C<EV_DEFAULT>.
-
-The constructor calls C<ev_init> for you, which means you have to call the
-C<set> method before starting it.
-
-It will not set a callback, however: You have to call the templated C<set>
-method to set a callback before you can start the watcher.
-
-(The reason why you have to use a method is a limitation in C++ which does
-not allow explicit template arguments for constructors).
-
-The destructor automatically stops the watcher if it is active.
-
-=item w->set<class, &class::method> (object *)
-
-This method sets the callback method to call. The method has to have a
-signature of C<void (*)(ev_TYPE &, int)>, it receives the watcher as
-first argument and the C<revents> as second. The object must be given as
-parameter and is stored in the C<data> member of the watcher.
-
-This method synthesizes efficient thunking code to call your method from
-the C callback that libev requires. If your compiler can inline your
-callback (i.e. it is visible to it at the place of the C<set> call and
-your compiler is good :), then the method will be fully inlined into the
-thunking function, making it as fast as a direct C callback.
-
-Example: simple class declaration and watcher initialisation
-
-   struct myclass
-   {
-     void io_cb (ev::io &w, int revents) { }
-   }
-
-   myclass obj;
-   ev::io iow;
-   iow.set <myclass, &myclass::io_cb> (&obj);
-
-=item w->set (object *)
-
-This is a variation of a method callback - leaving out the method to call
-will default the method to C<operator ()>, which makes it possible to use
-functor objects without having to manually specify the C<operator ()> all
-the time. Incidentally, you can then also leave out the template argument
-list.
-
-The C<operator ()> method prototype must be C<void operator ()(watcher &w,
-int revents)>.
-
-See the method-C<set> above for more details.
-
-Example: use a functor object as callback.
-
-   struct myfunctor
-   {
-     void operator() (ev::io &w, int revents)
-     {
-       ...
-     }
-   }
-
-   myfunctor f;
-
-   ev::io w;
-   w.set (&f);
-
-=item w->set<function> (void *data = 0)
-
-Also sets a callback, but uses a static method or plain function as
-callback. The optional C<data> argument will be stored in the watcher's
-C<data> member and is free for you to use.
-
-The prototype of the C<function> must be C<void (*)(ev::TYPE &w, int)>.
-
-See the method-C<set> above for more details.
-
-Example: Use a plain function as callback.
-
-   static void io_cb (ev::io &w, int revents) { }
-   iow.set <io_cb> ();
-
-=item w->set (loop)
-
-Associates a different C<struct ev_loop> with this watcher. You can only
-do this when the watcher is inactive (and not pending either).
-
-=item w->set ([arguments])
-
-Basically the same as C<ev_TYPE_set> (except for C<ev::embed> watchers>),
-with the same arguments. Either this method or a suitable start method
-must be called at least once. Unlike the C counterpart, an active watcher
-gets automatically stopped and restarted when reconfiguring it with this
-method.
-
-For C<ev::embed> watchers this method is called C<set_embed>, to avoid
-clashing with the C<set (loop)> method.
-
-=item w->start ()
-
-Starts the watcher. Note that there is no C<loop> argument, as the
-constructor already stores the event loop.
-
-=item w->start ([arguments])
-
-Instead of calling C<set> and C<start> methods separately, it is often
-convenient to wrap them in one call. Uses the same type of arguments as
-the configure C<set> method of the watcher.
-
-=item w->stop ()
-
-Stops the watcher if it is active. Again, no C<loop> argument.
-
-=item w->again () (C<ev::timer>, C<ev::periodic> only)
-
-For C<ev::timer> and C<ev::periodic>, this invokes the corresponding
-C<ev_TYPE_again> function.
-
-=item w->sweep () (C<ev::embed> only)
-
-Invokes C<ev_embed_sweep>.
-
-=item w->update () (C<ev::stat> only)
-
-Invokes C<ev_stat_stat>.
-
-=back
-
-=back
-
-Example: Define a class with two I/O and idle watchers, start the I/O
-watchers in the constructor.
-
-   class myclass
-   {
-     ev::io   io  ; void io_cb   (ev::io   &w, int revents);
-     ev::io   io2 ; void io2_cb  (ev::io   &w, int revents);
-     ev::idle idle; void idle_cb (ev::idle &w, int revents);
-
-     myclass (int fd)
-     {
-       io  .set <myclass, &myclass::io_cb  > (this);
-       io2 .set <myclass, &myclass::io2_cb > (this);
-       idle.set <myclass, &myclass::idle_cb> (this);
-
-       io.set (fd, ev::WRITE); // configure the watcher
-       io.start ();            // start it whenever convenient
-
-       io2.start (fd, ev::READ); // set + start in one call
-     }
-   };
-
-
-=head1 OTHER LANGUAGE BINDINGS
-
-Libev does not offer other language bindings itself, but bindings for a
-number of languages exist in the form of third-party packages. If you know
-any interesting language binding in addition to the ones listed here, drop
-me a note.
-
-=over 4
-
-=item Perl
-
-The EV module implements the full libev API and is actually used to test
-libev. EV is developed together with libev. Apart from the EV core module,
-there are additional modules that implement libev-compatible interfaces
-to C<libadns> (C<EV::ADNS>, but C<AnyEvent::DNS> is preferred nowadays),
-C<Net::SNMP> (C<Net::SNMP::EV>) and the C<libglib> event core (C<Glib::EV>
-and C<EV::Glib>).
-
-It can be found and installed via CPAN, its homepage is at
-L<http://software.schmorp.de/pkg/EV>.
-
-=item Python
-
-Python bindings can be found at L<http://code.google.com/p/pyev/>. It
-seems to be quite complete and well-documented.
-
-=item Ruby
-
-Tony Arcieri has written a ruby extension that offers access to a subset
-of the libev API and adds file handle abstractions, asynchronous DNS and
-more on top of it. It can be found via gem servers. Its homepage is at
-L<http://rev.rubyforge.org/>.
-
-Roger Pack reports that using the link order C<-lws2_32 -lmsvcrt-ruby-190>
-makes rev work even on mingw.
-
-=item Haskell
-
-A haskell binding to libev is available at
-L<http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hlibev>.
-
-=item D
-
-Leandro Lucarella has written a D language binding (F<ev.d>) for libev, to
-be found at L<http://www.llucax.com.ar/proj/ev.d/index.html>.
-
-=item Ocaml
-
-Erkki Seppala has written Ocaml bindings for libev, to be found at
-L<http://modeemi.cs.tut.fi/~flux/software/ocaml-ev/>.
-
-=item Lua
-
-Brian Maher has written a partial interface to libev for lua (at the
-time of this writing, only C<ev_io> and C<ev_timer>), to be found at
-L<http://github.com/brimworks/lua-ev>.
-
-=item Javascript
-
-Node.js (L<http://nodejs.org>) uses libev as the underlying event library.
-
-=item Others
-
-There are others, and I stopped counting.
-
-=back
-
-
-=head1 MACRO MAGIC
-
-Libev can be compiled with a variety of options, the most fundamental
-of which is C<EV_MULTIPLICITY>. This option determines whether (most)
-functions and callbacks have an initial C<struct ev_loop *> argument.
-
-To make it easier to write programs that cope with either variant, the
-following macros are defined:
-
-=over 4
-
-=item C<EV_A>, C<EV_A_>
-
-This provides the loop I<argument> for functions, if one is required ("ev
-loop argument"). The C<EV_A> form is used when this is the sole argument,
-C<EV_A_> is used when other arguments are following. Example:
-
-   ev_unref (EV_A);
-   ev_timer_add (EV_A_ watcher);
-   ev_run (EV_A_ 0);
-
-It assumes the variable C<loop> of type C<struct ev_loop *> is in scope,
-which is often provided by the following macro.
-
-=item C<EV_P>, C<EV_P_>
-
-This provides the loop I<parameter> for functions, if one is required ("ev
-loop parameter"). The C<EV_P> form is used when this is the sole parameter,
-C<EV_P_> is used when other parameters are following. Example:
-
-   // this is how ev_unref is being declared
-   static void ev_unref (EV_P);
-
-   // this is how you can declare your typical callback
-   static void cb (EV_P_ ev_timer *w, int revents)
-
-It declares a parameter C<loop> of type C<struct ev_loop *>, quite
-suitable for use with C<EV_A>.
-
-=item C<EV_DEFAULT>, C<EV_DEFAULT_>
-
-Similar to the other two macros, this gives you the value of the default
-loop, if multiple loops are supported ("ev loop default"). The default loop
-will be initialised if it isn't already initialised.
-
-For non-multiplicity builds, these macros do nothing, so you always have
-to initialise the loop somewhere.
-
-=item C<EV_DEFAULT_UC>, C<EV_DEFAULT_UC_>
-
-Usage identical to C<EV_DEFAULT> and C<EV_DEFAULT_>, but requires that the
-default loop has been initialised (C<UC> == unchecked). Their behaviour
-is undefined when the default loop has not been initialised by a previous
-execution of C<EV_DEFAULT>, C<EV_DEFAULT_> or C<ev_default_init (...)>.
-
-It is often prudent to use C<EV_DEFAULT> when initialising the first
-watcher in a function but use C<EV_DEFAULT_UC> afterwards.
-
-=back
-
-Example: Declare and initialise a check watcher, utilising the above
-macros so it will work regardless of whether multiple loops are supported
-or not.
-
-   static void
-   check_cb (EV_P_ ev_timer *w, int revents)
-   {
-     ev_check_stop (EV_A_ w);
-   }
-
-   ev_check check;
-   ev_check_init (&check, check_cb);
-   ev_check_start (EV_DEFAULT_ &check);
-   ev_run (EV_DEFAULT_ 0);
-
-=head1 EMBEDDING
-
-Libev can (and often is) directly embedded into host
-applications. Examples of applications that embed it include the Deliantra
-Game Server, the EV perl module, the GNU Virtual Private Ethernet (gvpe)
-and rxvt-unicode.
-
-The goal is to enable you to just copy the necessary files into your
-source directory without having to change even a single line in them, so
-you can easily upgrade by simply copying (or having a checked-out copy of
-libev somewhere in your source tree).
-
-=head2 FILESETS
-
-Depending on what features you need you need to include one or more sets of files
-in your application.
-
-=head3 CORE EVENT LOOP
-
-To include only the libev core (all the C<ev_*> functions), with manual
-configuration (no autoconf):
-
-   #define EV_STANDALONE 1
-   #include "ev.c"
-
-This will automatically include F<ev.h>, too, and should be done in a
-single C source file only to provide the function implementations. To use
-it, do the same for F<ev.h> in all files wishing to use this API (best
-done by writing a wrapper around F<ev.h> that you can include instead and
-where you can put other configuration options):
-
-   #define EV_STANDALONE 1
-   #include "ev.h"
-
-Both header files and implementation files can be compiled with a C++
-compiler (at least, that's a stated goal, and breakage will be treated
-as a bug).
-
-You need the following files in your source tree, or in a directory
-in your include path (e.g. in libev/ when using -Ilibev):
-
-   ev.h
-   ev.c
-   ev_vars.h
-   ev_wrap.h
-
-   ev_win32.c      required on win32 platforms only
-
-   ev_select.c     only when select backend is enabled
-   ev_poll.c       only when poll backend is enabled
-   ev_epoll.c      only when the epoll backend is enabled
-   ev_kqueue.c     only when the kqueue backend is enabled
-   ev_port.c       only when the solaris port backend is enabled
-
-F<ev.c> includes the backend files directly when enabled, so you only need
-to compile this single file.
-
-=head3 LIBEVENT COMPATIBILITY API
-
-To include the libevent compatibility API, also include:
-
-   #include "event.c"
-
-in the file including F<ev.c>, and:
-
-   #include "event.h"
-
-in the files that want to use the libevent API. This also includes F<ev.h>.
-
-You need the following additional files for this:
-
-   event.h
-   event.c
-
-=head3 AUTOCONF SUPPORT
-
-Instead of using C<EV_STANDALONE=1> and providing your configuration in
-whatever way you want, you can also C<m4_include([libev.m4])> in your
-F<configure.ac> and leave C<EV_STANDALONE> undefined. F<ev.c> will then
-include F<config.h> and configure itself accordingly.
-
-For this of course you need the m4 file:
-
-   libev.m4
-
-=head2 PREPROCESSOR SYMBOLS/MACROS
-
-Libev can be configured via a variety of preprocessor symbols you have to
-define before including (or compiling) any of its files. The default in
-the absence of autoconf is documented for every option.
-
-Symbols marked with "(h)" do not change the ABI, and can have different
-values when compiling libev vs. including F<ev.h>, so it is permissible
-to redefine them before including F<ev.h> without breaking compatibility
-to a compiled library. All other symbols change the ABI, which means all
-users of libev and the libev code itself must be compiled with compatible
-settings.
-
-=over 4
-
-=item EV_COMPAT3 (h)
-
-Backwards compatibility is a major concern for libev. This is why this
-release of libev comes with wrappers for the functions and symbols that
-have been renamed between libev version 3 and 4.
-
-You can disable these wrappers (to test compatibility with future
-versions) by defining C<EV_COMPAT3> to C<0> when compiling your
-sources. This has the additional advantage that you can drop the C<struct>
-from C<struct ev_loop> declarations, as libev will provide an C<ev_loop>
-typedef in that case.
-
-In some future version, the default for C<EV_COMPAT3> will become C<0>,
-and in some even more future version the compatibility code will be
-removed completely.
-
-=item EV_STANDALONE (h)
-
-Must always be C<1> if you do not use autoconf configuration, which
-keeps libev from including F<config.h>, and it also defines dummy
-implementations for some libevent functions (such as logging, which is not
-supported). It will also not define any of the structs usually found in
-F<event.h> that are not directly supported by the libev core alone.
-
-In standalone mode, libev will still try to automatically deduce the
-configuration, but has to be more conservative.
-
-=item EV_USE_FLOOR
-
-If defined to be C<1>, libev will use the C<floor ()> function for its
-periodic reschedule calculations, otherwise libev will fall back on a
-portable (slower) implementation. If you enable this, you usually have to
-link against libm or something equivalent. Enabling this when the C<floor>
-function is not available will fail, so the safe default is to not enable
-this.
-
-=item EV_USE_MONOTONIC
-
-If defined to be C<1>, libev will try to detect the availability of the
-monotonic clock option at both compile time and runtime. Otherwise no
-use of the monotonic clock option will be attempted. If you enable this,
-you usually have to link against librt or something similar. Enabling it
-when the functionality isn't available is safe, though, although you have
-to make sure you link against any libraries where the C<clock_gettime>
-function is hiding in (often F<-lrt>). See also C<EV_USE_CLOCK_SYSCALL>.
-
-=item EV_USE_REALTIME
-
-If defined to be C<1>, libev will try to detect the availability of the
-real-time clock option at compile time (and assume its availability
-at runtime if successful). Otherwise no use of the real-time clock
-option will be attempted. This effectively replaces C<gettimeofday>
-by C<clock_get (CLOCK_REALTIME, ...)> and will not normally affect
-correctness. See the note about libraries in the description of
-C<EV_USE_MONOTONIC>, though. Defaults to the opposite value of
-C<EV_USE_CLOCK_SYSCALL>.
-
-=item EV_USE_CLOCK_SYSCALL
-
-If defined to be C<1>, libev will try to use a direct syscall instead
-of calling the system-provided C<clock_gettime> function. This option
-exists because on GNU/Linux, C<clock_gettime> is in C<librt>, but C<librt>
-unconditionally pulls in C<libpthread>, slowing down single-threaded
-programs needlessly. Using a direct syscall is slightly slower (in
-theory), because no optimised vdso implementation can be used, but avoids
-the pthread dependency. Defaults to C<1> on GNU/Linux with glibc 2.x or
-higher, as it simplifies linking (no need for C<-lrt>).
-
-=item EV_USE_NANOSLEEP
-
-If defined to be C<1>, libev will assume that C<nanosleep ()> is available
-and will use it for delays. Otherwise it will use C<select ()>.
-
-=item EV_USE_EVENTFD
-
-If defined to be C<1>, then libev will assume that C<eventfd ()> is
-available and will probe for kernel support at runtime. This will improve
-C<ev_signal> and C<ev_async> performance and reduce resource consumption.
-If undefined, it will be enabled if the headers indicate GNU/Linux + Glibc
-2.7 or newer, otherwise disabled.
-
-=item EV_USE_SELECT
-
-If undefined or defined to be C<1>, libev will compile in support for the
-C<select>(2) backend. No attempt at auto-detection will be done: if no
-other method takes over, select will be it. Otherwise the select backend
-will not be compiled in.
-
-=item EV_SELECT_USE_FD_SET
-
-If defined to C<1>, then the select backend will use the system C<fd_set>
-structure. This is useful if libev doesn't compile due to a missing
-C<NFDBITS> or C<fd_mask> definition or it mis-guesses the bitset layout
-on exotic systems. This usually limits the range of file descriptors to
-some low limit such as 1024 or might have other limitations (winsocket
-only allows 64 sockets). The C<FD_SETSIZE> macro, set before compilation,
-configures the maximum size of the C<fd_set>.
-
-=item EV_SELECT_IS_WINSOCKET
-
-When defined to C<1>, the select backend will assume that
-select/socket/connect etc. don't understand file descriptors but
-wants osf handles on win32 (this is the case when the select to
-be used is the winsock select). This means that it will call
-C<_get_osfhandle> on the fd to convert it to an OS handle. Otherwise,
-it is assumed that all these functions actually work on fds, even
-on win32. Should not be defined on non-win32 platforms.
-
-=item EV_FD_TO_WIN32_HANDLE(fd)
-
-If C<EV_SELECT_IS_WINSOCKET> is enabled, then libev needs a way to map
-file descriptors to socket handles. When not defining this symbol (the
-default), then libev will call C<_get_osfhandle>, which is usually
-correct. In some cases, programs use their own file descriptor management,
-in which case they can provide this function to map fds to socket handles.
-
-=item EV_WIN32_HANDLE_TO_FD(handle)
-
-If C<EV_SELECT_IS_WINSOCKET> then libev maps handles to file descriptors
-using the standard C<_open_osfhandle> function. For programs implementing
-their own fd to handle mapping, overwriting this function makes it easier
-to do so. This can be done by defining this macro to an appropriate value.
-
-=item EV_WIN32_CLOSE_FD(fd)
-
-If programs implement their own fd to handle mapping on win32, then this
-macro can be used to override the C<close> function, useful to unregister
-file descriptors again. Note that the replacement function has to close
-the underlying OS handle.
-
-=item EV_USE_WSASOCKET
-
-If defined to be C<1>, libev will use C<WSASocket> to create its internal
-communication socket, which works better in some environments. Otherwise,
-the normal C<socket> function will be used, which works better in other
-environments.
-
-=item EV_USE_POLL
-
-If defined to be C<1>, libev will compile in support for the C<poll>(2)
-backend. Otherwise it will be enabled on non-win32 platforms. It
-takes precedence over select.
-
-=item EV_USE_EPOLL
-
-If defined to be C<1>, libev will compile in support for the Linux
-C<epoll>(7) backend. Its availability will be detected at runtime,
-otherwise another method will be used as fallback. This is the preferred
-backend for GNU/Linux systems. If undefined, it will be enabled if the
-headers indicate GNU/Linux + Glibc 2.4 or newer, otherwise disabled.
-
-=item EV_USE_KQUEUE
-
-If defined to be C<1>, libev will compile in support for the BSD style
-C<kqueue>(2) backend. Its actual availability will be detected at runtime,
-otherwise another method will be used as fallback. This is the preferred
-backend for BSD and BSD-like systems, although on most BSDs kqueue only
-supports some types of fds correctly (the only platform we found that
-supports ptys for example was NetBSD), so kqueue might be compiled in, but
-not be used unless explicitly requested. The best way to use it is to find
-out whether kqueue supports your type of fd properly and use an embedded
-kqueue loop.
-
-=item EV_USE_PORT
-
-If defined to be C<1>, libev will compile in support for the Solaris
-10 port style backend. Its availability will be detected at runtime,
-otherwise another method will be used as fallback. This is the preferred
-backend for Solaris 10 systems.
-
-=item EV_USE_DEVPOLL
-
-Reserved for future expansion, works like the USE symbols above.
-
-=item EV_USE_INOTIFY
-
-If defined to be C<1>, libev will compile in support for the Linux inotify
-interface to speed up C<ev_stat> watchers. Its actual availability will
-be detected at runtime. If undefined, it will be enabled if the headers
-indicate GNU/Linux + Glibc 2.4 or newer, otherwise disabled.
-
-=item EV_NO_SMP
-
-If defined to be C<1>, libev will assume that memory is always coherent
-between threads, that is, threads can be used, but threads never run on
-different cpus (or different cpu cores). This reduces dependencies
-and makes libev faster.
-
-=item EV_NO_THREADS
-
-If defined to be C<1>, libev will assume that it will never be called from
-different threads (that includes signal handlers), which is a stronger
-assumption than C<EV_NO_SMP>, above. This reduces dependencies and makes
-libev faster.
-
-=item EV_ATOMIC_T
-
-Libev requires an integer type (suitable for storing C<0> or C<1>) whose
-access is atomic with respect to other threads or signal contexts. No
-such type is easily found in the C language, so you can provide your own
-type that you know is safe for your purposes. It is used both for signal
-handler "locking" as well as for signal and thread safety in C<ev_async>
-watchers.
-
-In the absence of this define, libev will use C<sig_atomic_t volatile>
-(from F<signal.h>), which is usually good enough on most platforms.
-
-=item EV_H (h)
-
-The name of the F<ev.h> header file used to include it. The default if
-undefined is C<"ev.h"> in F<event.h>, F<ev.c> and F<ev++.h>. This can be
-used to virtually rename the F<ev.h> header file in case of conflicts.
-
-=item EV_CONFIG_H (h)
-
-If C<EV_STANDALONE> isn't C<1>, this variable can be used to override
-F<ev.c>'s idea of where to find the F<config.h> file, similarly to
-C<EV_H>, above.
-
-=item EV_EVENT_H (h)
-
-Similarly to C<EV_H>, this macro can be used to override F<event.c>'s idea
-of how the F<event.h> header can be found, the default is C<"event.h">.
-
-=item EV_PROTOTYPES (h)
-
-If defined to be C<0>, then F<ev.h> will not define any function
-prototypes, but still define all the structs and other symbols. This is
-occasionally useful if you want to provide your own wrapper functions
-around libev functions.
-
-=item EV_MULTIPLICITY
-
-If undefined or defined to C<1>, then all event-loop-specific functions
-will have the C<struct ev_loop *> as first argument, and you can create
-additional independent event loops. Otherwise there will be no support
-for multiple event loops and there is no first event loop pointer
-argument. Instead, all functions act on the single default loop.
-
-Note that C<EV_DEFAULT> and C<EV_DEFAULT_> will no longer provide a
-default loop when multiplicity is switched off - you always have to
-initialise the loop manually in this case.
-
-=item EV_MINPRI
-
-=item EV_MAXPRI
-
-The range of allowed priorities. C<EV_MINPRI> must be smaller or equal to
-C<EV_MAXPRI>, but otherwise there are no non-obvious limitations. You can
-provide for more priorities by overriding those symbols (usually defined
-to be C<-2> and C<2>, respectively).
-
-When doing priority-based operations, libev usually has to linearly search
-all the priorities, so having many of them (hundreds) uses a lot of space
-and time, so using the defaults of five priorities (-2 .. +2) is usually
-fine.
-
-If your embedding application does not need any priorities, defining these
-both to C<0> will save some memory and CPU.
-
-=item EV_PERIODIC_ENABLE, EV_IDLE_ENABLE, EV_EMBED_ENABLE, EV_STAT_ENABLE,
-EV_PREPARE_ENABLE, EV_CHECK_ENABLE, EV_FORK_ENABLE, EV_SIGNAL_ENABLE,
-EV_ASYNC_ENABLE, EV_CHILD_ENABLE.
-
-If undefined or defined to be C<1> (and the platform supports it), then
-the respective watcher type is supported. If defined to be C<0>, then it
-is not. Disabling watcher types mainly saves code size.
-
-=item EV_FEATURES
-
-If you need to shave off some kilobytes of code at the expense of some
-speed (but with the full API), you can define this symbol to request
-certain subsets of functionality. The default is to enable all features
-that can be enabled on the platform.
-
-A typical way to use this symbol is to define it to C<0> (or to a bitset
-with some broad features you want) and then selectively re-enable
-additional parts you want, for example if you want everything minimal,
-but multiple event loop support, async and child watchers and the poll
-backend, use this:
-
-   #define EV_FEATURES 0
-   #define EV_MULTIPLICITY 1
-   #define EV_USE_POLL 1
-   #define EV_CHILD_ENABLE 1
-   #define EV_ASYNC_ENABLE 1
-
-The actual value is a bitset, it can be a combination of the following
-values (by default, all of these are enabled):
-
-=over 4
-
-=item C<1> - faster/larger code
-
-Use larger code to speed up some operations.
-
-Currently this is used to override some inlining decisions (enlarging the
-code size by roughly 30% on amd64).
-
-When optimising for size, use of compiler flags such as C<-Os> with
-gcc is recommended, as well as C<-DNDEBUG>, as libev contains a number of
-assertions.
-
-The default is off when C<__OPTIMIZE_SIZE__> is defined by your compiler
-(e.g. gcc with C<-Os>).
-
-=item C<2> - faster/larger data structures
-
-Replaces the small 2-heap for timer management by a faster 4-heap, larger
-hash table sizes and so on. This will usually further increase code size
-and can additionally have an effect on the size of data structures at
-runtime.
-
-The default is off when C<__OPTIMIZE_SIZE__> is defined by your compiler
-(e.g. gcc with C<-Os>).
-
-=item C<4> - full API configuration
-
-This enables priorities (sets C<EV_MAXPRI>=2 and C<EV_MINPRI>=-2), and
-enables multiplicity (C<EV_MULTIPLICITY>=1).
-
-=item C<8> - full API
-
-This enables a lot of the "lesser used" API functions. See C<ev.h> for
-details on which parts of the API are still available without this
-feature, and do not complain if this subset changes over time.
-
-=item C<16> - enable all optional watcher types
-
-Enables all optional watcher types.  If you want to selectively enable
-only some watcher types other than I/O and timers (e.g. prepare,
-embed, async, child...) you can enable them manually by defining
-C<EV_watchertype_ENABLE> to C<1> instead.
-
-=item C<32> - enable all backends
-
-This enables all backends - without this feature, you need to enable at
-least one backend manually (C<EV_USE_SELECT> is a good choice).
-
-=item C<64> - enable OS-specific "helper" APIs
-
-Enable inotify, eventfd, signalfd and similar OS-specific helper APIs by
-default.
-
-=back
-
-Compiling with C<gcc -Os -DEV_STANDALONE -DEV_USE_EPOLL=1 -DEV_FEATURES=0>
-reduces the compiled size of libev from 24.7Kb code/2.8Kb data to 6.5Kb
-code/0.3Kb data on my GNU/Linux amd64 system, while still giving you I/O
-watchers, timers and monotonic clock support.
-
-With an intelligent-enough linker (gcc+binutils are intelligent enough
-when you use C<-Wl,--gc-sections -ffunction-sections>) functions unused by
-your program might be left out as well - a binary starting a timer and an
-I/O watcher then might come out at only 5Kb.
-
-=item EV_API_STATIC
-
-If this symbol is defined (by default it is not), then all identifiers
-will have static linkage. This means that libev will not export any
-identifiers, and you cannot link against libev anymore. This can be useful
-when you embed libev, only want to use libev functions in a single file,
-and do not want its identifiers to be visible.
-
-To use this, define C<EV_API_STATIC> and include F<ev.c> in the file that
-wants to use libev.
-
-This option only works when libev is compiled with a C compiler, as C++
-doesn't support the required declaration syntax.
-
-=item EV_AVOID_STDIO
-
-If this is set to C<1> at compiletime, then libev will avoid using stdio
-functions (printf, scanf, perror etc.). This will increase the code size
-somewhat, but if your program doesn't otherwise depend on stdio and your
-libc allows it, this avoids linking in the stdio library which is quite
-big.
-
-Note that error messages might become less precise when this option is
-enabled.
-
-=item EV_NSIG
-
-The highest supported signal number, +1 (or, the number of
-signals): Normally, libev tries to deduce the maximum number of signals
-automatically, but sometimes this fails, in which case it can be
-specified. Also, using a lower number than detected (C<32> should be
-good for about any system in existence) can save some memory, as libev
-statically allocates some 12-24 bytes per signal number.
-
-=item EV_PID_HASHSIZE
-
-C<ev_child> watchers use a small hash table to distribute workload by
-pid. The default size is C<16> (or C<1> with C<EV_FEATURES> disabled),
-usually more than enough. If you need to manage thousands of children you
-might want to increase this value (I<must> be a power of two).
-
-=item EV_INOTIFY_HASHSIZE
-
-C<ev_stat> watchers use a small hash table to distribute workload by
-inotify watch id. The default size is C<16> (or C<1> with C<EV_FEATURES>
-disabled), usually more than enough. If you need to manage thousands of
-C<ev_stat> watchers you might want to increase this value (I<must> be a
-power of two).
-
-=item EV_USE_4HEAP
-
-Heaps are not very cache-efficient. To improve the cache-efficiency of the
-timer and periodics heaps, libev uses a 4-heap when this symbol is defined
-to C<1>. The 4-heap uses more complicated (longer) code but has noticeably
-faster performance with many (thousands) of watchers.
-
-The default is C<1>, unless C<EV_FEATURES> overrides it, in which case it
-will be C<0>.
-
-=item EV_HEAP_CACHE_AT
-
-Heaps are not very cache-efficient. To improve the cache-efficiency of the
-timer and periodics heaps, libev can cache the timestamp (I<at>) within
-the heap structure (selected by defining C<EV_HEAP_CACHE_AT> to C<1>),
-which uses 8-12 bytes more per watcher and a few hundred bytes more code,
-but avoids random read accesses on heap changes. This improves performance
-noticeably with many (hundreds) of watchers.
-
-The default is C<1>, unless C<EV_FEATURES> overrides it, in which case it
-will be C<0>.
-
-=item EV_VERIFY
-
-Controls how much internal verification (see C<ev_verify ()>) will
-be done: If set to C<0>, no internal verification code will be compiled
-in. If set to C<1>, then verification code will be compiled in, but not
-called. If set to C<2>, then the internal verification code will be
-called once per loop, which can slow down libev. If set to C<3>, then the
-verification code will be called very frequently, which will slow down
-libev considerably.
-
-The default is C<1>, unless C<EV_FEATURES> overrides it, in which case it
-will be C<0>.
-
-=item EV_COMMON
-
-By default, all watchers have a C<void *data> member. By redefining
-this macro to something else you can include more and other types of
-members. You have to define it each time you include one of the files,
-though, and it must be identical each time.
-
-For example, the perl EV module uses something like this:
-
-   #define EV_COMMON                       \
-     SV *self; /* contains this struct */  \
-     SV *cb_sv, *fh /* note no trailing ";" */
-
-=item EV_CB_DECLARE (type)
-
-=item EV_CB_INVOKE (watcher, revents)
-
-=item ev_set_cb (ev, cb)
-
-Can be used to change the callback member declaration in each watcher,
-and the way callbacks are invoked and set. Must expand to a struct member
-definition and a statement, respectively. See the F<ev.h> header file for
-their default definitions. One possible use for overriding these is to
-avoid the C<struct ev_loop *> as first argument in all cases, or to use
-method calls instead of plain function calls in C++.
-
-=back
-
-=head2 EXPORTED API SYMBOLS
-
-If you need to re-export the API (e.g. via a DLL) and you need a list of
-exported symbols, you can use the provided F<Symbol.*> files which list
-all public symbols, one per line:
-
-   Symbols.ev      for libev proper
-   Symbols.event   for the libevent emulation
-
-This can also be used to rename all public symbols to avoid clashes with
-multiple versions of libev linked together (which is obviously bad in
-itself, but sometimes it is inconvenient to avoid this).
-
-A sed command like this will create wrapper C<#define>'s that you need to
-include before including F<ev.h>:
-
-   <Symbols.ev sed -e "s/.*/#define & myprefix_&/" >wrap.h
-
-This would create a file F<wrap.h> which essentially looks like this:
-
-   #define ev_backend     myprefix_ev_backend
-   #define ev_check_start myprefix_ev_check_start
-   #define ev_check_stop  myprefix_ev_check_stop
-   ...
-
-=head2 EXAMPLES
-
-For a real-world example of a program the includes libev
-verbatim, you can have a look at the EV perl module
-(L<http://software.schmorp.de/pkg/EV.html>). It has the libev files in
-the F<libev/> subdirectory and includes them in the F<EV/EVAPI.h> (public
-interface) and F<EV.xs> (implementation) files. Only the F<EV.xs> file
-will be compiled. It is pretty complex because it provides its own header
-file.
-
-The usage in rxvt-unicode is simpler. It has a F<ev_cpp.h> header file
-that everybody includes and which overrides some configure choices:
-
-   #define EV_FEATURES 8
-   #define EV_USE_SELECT 1
-   #define EV_PREPARE_ENABLE 1
-   #define EV_IDLE_ENABLE 1
-   #define EV_SIGNAL_ENABLE 1
-   #define EV_CHILD_ENABLE 1
-   #define EV_USE_STDEXCEPT 0
-   #define EV_CONFIG_H <config.h>
-
-   #include "ev++.h"
-
-And a F<ev_cpp.C> implementation file that contains libev proper and is compiled:
-
-   #include "ev_cpp.h"
-   #include "ev.c"
-
-=head1 INTERACTION WITH OTHER PROGRAMS, LIBRARIES OR THE ENVIRONMENT
-
-=head2 THREADS AND COROUTINES
-
-=head3 THREADS
-
-All libev functions are reentrant and thread-safe unless explicitly
-documented otherwise, but libev implements no locking itself. This means
-that you can use as many loops as you want in parallel, as long as there
-are no concurrent calls into any libev function with the same loop
-parameter (C<ev_default_*> calls have an implicit default loop parameter,
-of course): libev guarantees that different event loops share no data
-structures that need any locking.
-
-Or to put it differently: calls with different loop parameters can be done
-concurrently from multiple threads, calls with the same loop parameter
-must be done serially (but can be done from different threads, as long as
-only one thread ever is inside a call at any point in time, e.g. by using
-a mutex per loop).
-
-Specifically to support threads (and signal handlers), libev implements
-so-called C<ev_async> watchers, which allow some limited form of
-concurrency on the same event loop, namely waking it up "from the
-outside".
-
-If you want to know which design (one loop, locking, or multiple loops
-without or something else still) is best for your problem, then I cannot
-help you, but here is some generic advice:
-
-=over 4
-
-=item * most applications have a main thread: use the default libev loop
-in that thread, or create a separate thread running only the default loop.
-
-This helps integrating other libraries or software modules that use libev
-themselves and don't care/know about threading.
-
-=item * one loop per thread is usually a good model.
-
-Doing this is almost never wrong, sometimes a better-performance model
-exists, but it is always a good start.
-
-=item * other models exist, such as the leader/follower pattern, where one
-loop is handed through multiple threads in a kind of round-robin fashion.
-
-Choosing a model is hard - look around, learn, know that usually you can do
-better than you currently do :-)
-
-=item * often you need to talk to some other thread which blocks in the
-event loop.
-
-C<ev_async> watchers can be used to wake them up from other threads safely
-(or from signal contexts...).
-
-An example use would be to communicate signals or other events that only
-work in the default loop by registering the signal watcher with the
-default loop and triggering an C<ev_async> watcher from the default loop
-watcher callback into the event loop interested in the signal.
-
-=back
-
-See also L</THREAD LOCKING EXAMPLE>.
-
-=head3 COROUTINES
-
-Libev is very accommodating to coroutines ("cooperative threads"):
-libev fully supports nesting calls to its functions from different
-coroutines (e.g. you can call C<ev_run> on the same loop from two
-different coroutines, and switch freely between both coroutines running
-the loop, as long as you don't confuse yourself). The only exception is
-that you must not do this from C<ev_periodic> reschedule callbacks.
-
-Care has been taken to ensure that libev does not keep local state inside
-C<ev_run>, and other calls do not usually allow for coroutine switches as
-they do not call any callbacks.
-
-=head2 COMPILER WARNINGS
-
-Depending on your compiler and compiler settings, you might get no or a
-lot of warnings when compiling libev code. Some people are apparently
-scared by this.
-
-However, these are unavoidable for many reasons. For one, each compiler
-has different warnings, and each user has different tastes regarding
-warning options. "Warn-free" code therefore cannot be a goal except when
-targeting a specific compiler and compiler-version.
-
-Another reason is that some compiler warnings require elaborate
-workarounds, or other changes to the code that make it less clear and less
-maintainable.
-
-And of course, some compiler warnings are just plain stupid, or simply
-wrong (because they don't actually warn about the condition their message
-seems to warn about). For example, certain older gcc versions had some
-warnings that resulted in an extreme number of false positives. These have
-been fixed, but some people still insist on making code warn-free with
-such buggy versions.
-
-While libev is written to generate as few warnings as possible,
-"warn-free" code is not a goal, and it is recommended not to build libev
-with any compiler warnings enabled unless you are prepared to cope with
-them (e.g. by ignoring them). Remember that warnings are just that:
-warnings, not errors, or proof of bugs.
-
-
-=head2 VALGRIND
-
-Valgrind has a special section here because it is a popular tool that is
-highly useful. Unfortunately, valgrind reports are very hard to interpret.
-
-If you think you found a bug (memory leak, uninitialised data access etc.)
-in libev, then check twice: If valgrind reports something like:
-
-   ==2274==    definitely lost: 0 bytes in 0 blocks.
-   ==2274==      possibly lost: 0 bytes in 0 blocks.
-   ==2274==    still reachable: 256 bytes in 1 blocks.
-
-Then there is no memory leak, just as memory accounted to global variables
-is not a memleak - the memory is still being referenced, and didn't leak.
-
-Similarly, under some circumstances, valgrind might report kernel bugs
-as if it were a bug in libev (e.g. in realloc or in the poll backend,
-although an acceptable workaround has been found here), or it might be
-confused.
-
-Keep in mind that valgrind is a very good tool, but only a tool. Don't
-make it into some kind of religion.
-
-If you are unsure about something, feel free to contact the mailing list
-with the full valgrind report and an explanation on why you think this
-is a bug in libev (best check the archives, too :). However, don't be
-annoyed when you get a brisk "this is no bug" answer and take the chance
-of learning how to interpret valgrind properly.
-
-If you need, for some reason, empty reports from valgrind for your project
-I suggest using suppression lists.
-
-
-=head1 PORTABILITY NOTES
-
-=head2 GNU/LINUX 32 BIT LIMITATIONS
-
-GNU/Linux is the only common platform that supports 64 bit file/large file
-interfaces but I<disables> them by default.
-
-That means that libev compiled in the default environment doesn't support
-files larger than 2GiB or so, which mainly affects C<ev_stat> watchers.
-
-Unfortunately, many programs try to work around this GNU/Linux issue
-by enabling the large file API, which makes them incompatible with the
-standard libev compiled for their system.
-
-Likewise, libev cannot enable the large file API itself as this would
-suddenly make it incompatible to the default compile time environment,
-i.e. all programs not using special compile switches.
-
-=head2 OS/X AND DARWIN BUGS
-
-The whole thing is a bug if you ask me - basically any system interface
-you touch is broken, whether it is locales, poll, kqueue or even the
-OpenGL drivers.
-
-=head3 C<kqueue> is buggy
-
-The kqueue syscall is broken in all known versions - most versions support
-only sockets, many support pipes.
-
-Libev tries to work around this by not using C<kqueue> by default on this
-rotten platform, but of course you can still ask for it when creating a
-loop - embedding a socket-only kqueue loop into a select-based one is
-probably going to work well.
-
-=head3 C<poll> is buggy
-
-Instead of fixing C<kqueue>, Apple replaced their (working) C<poll>
-implementation by something calling C<kqueue> internally around the 10.5.6
-release, so now C<kqueue> I<and> C<poll> are broken.
-
-Libev tries to work around this by not using C<poll> by default on
-this rotten platform, but of course you can still ask for it when creating
-a loop.
-
-=head3 C<select> is buggy
-
-All that's left is C<select>, and of course Apple found a way to fuck this
-one up as well: On OS/X, C<select> actively limits the number of file
-descriptors you can pass in to 1024 - your program suddenly crashes when
-you use more.
-
-There is an undocumented "workaround" for this - defining
-C<_DARWIN_UNLIMITED_SELECT>, which libev tries to use, so select I<should>
-work on OS/X.
-
-=head2 SOLARIS PROBLEMS AND WORKAROUNDS
-
-=head3 C<errno> reentrancy
-
-The default compile environment on Solaris is unfortunately so
-thread-unsafe that you can't even use components/libraries compiled
-without C<-D_REENTRANT> in a threaded program, which, of course, isn't
-defined by default. A valid, if stupid, implementation choice.
-
-If you want to use libev in threaded environments you have to make sure
-it's compiled with C<_REENTRANT> defined.
-
-=head3 Event port backend
-
-The scalable event interface for Solaris is called "event
-ports". Unfortunately, this mechanism is very buggy in all major
-releases. If you run into high CPU usage, your program freezes or you get
-a large number of spurious wakeups, make sure you have all the relevant
-and latest kernel patches applied. No, I don't know which ones, but there
-are multiple ones to apply, and afterwards, event ports actually work
-great.
-
-If you can't get it to work, you can try running the program by setting
-the environment variable C<LIBEV_FLAGS=3> to only allow C<poll> and
-C<select> backends.
-
-=head2 AIX POLL BUG
-
-AIX unfortunately has a broken C<poll.h> header. Libev works around
-this by trying to avoid the poll backend altogether (i.e. it's not even
-compiled in), which normally isn't a big problem as C<select> works fine
-with large bitsets on AIX, and AIX is dead anyway.
-
-=head2 WIN32 PLATFORM LIMITATIONS AND WORKAROUNDS
-
-=head3 General issues
-
-Win32 doesn't support any of the standards (e.g. POSIX) that libev
-requires, and its I/O model is fundamentally incompatible with the POSIX
-model. Libev still offers limited functionality on this platform in
-the form of the C<EVBACKEND_SELECT> backend, and only supports socket
-descriptors. This only applies when using Win32 natively, not when using
-e.g. cygwin. Actually, it only applies to the microsofts own compilers,
-as every compiler comes with a slightly differently broken/incompatible
-environment.
-
-Lifting these limitations would basically require the full
-re-implementation of the I/O system. If you are into this kind of thing,
-then note that glib does exactly that for you in a very portable way (note
-also that glib is the slowest event library known to man).
-
-There is no supported compilation method available on windows except
-embedding it into other applications.
-
-Sensible signal handling is officially unsupported by Microsoft - libev
-tries its best, but under most conditions, signals will simply not work.
-
-Not a libev limitation but worth mentioning: windows apparently doesn't
-accept large writes: instead of resulting in a partial write, windows will
-either accept everything or return C<ENOBUFS> if the buffer is too large,
-so make sure you only write small amounts into your sockets (less than a
-megabyte seems safe, but this apparently depends on the amount of memory
-available).
-
-Due to the many, low, and arbitrary limits on the win32 platform and
-the abysmal performance of winsockets, using a large number of sockets
-is not recommended (and not reasonable). If your program needs to use
-more than a hundred or so sockets, then likely it needs to use a totally
-different implementation for windows, as libev offers the POSIX readiness
-notification model, which cannot be implemented efficiently on windows
-(due to Microsoft monopoly games).
-
-A typical way to use libev under windows is to embed it (see the embedding
-section for details) and use the following F<evwrap.h> header file instead
-of F<ev.h>:
-
-   #define EV_STANDALONE              /* keeps ev from requiring config.h */
-   #define EV_SELECT_IS_WINSOCKET 1   /* configure libev for windows select */
-
-   #include "ev.h"
-
-And compile the following F<evwrap.c> file into your project (make sure
-you do I<not> compile the F<ev.c> or any other embedded source files!):
-
-   #include "evwrap.h"
-   #include "ev.c"
-
-=head3 The winsocket C<select> function
-
-The winsocket C<select> function doesn't follow POSIX in that it
-requires socket I<handles> and not socket I<file descriptors> (it is
-also extremely buggy). This makes select very inefficient, and also
-requires a mapping from file descriptors to socket handles (the Microsoft
-C runtime provides the function C<_open_osfhandle> for this). See the
-discussion of the C<EV_SELECT_USE_FD_SET>, C<EV_SELECT_IS_WINSOCKET> and
-C<EV_FD_TO_WIN32_HANDLE> preprocessor symbols for more info.
-
-The configuration for a "naked" win32 using the Microsoft runtime
-libraries and raw winsocket select is:
-
-   #define EV_USE_SELECT 1
-   #define EV_SELECT_IS_WINSOCKET 1   /* forces EV_SELECT_USE_FD_SET, too */
-
-Note that winsockets handling of fd sets is O(n), so you can easily get a
-complexity in the O(n²) range when using win32.
-
-=head3 Limited number of file descriptors
-
-Windows has numerous arbitrary (and low) limits on things.
-
-Early versions of winsocket's select only supported waiting for a maximum
-of C<64> handles (probably owning to the fact that all windows kernels
-can only wait for C<64> things at the same time internally; Microsoft
-recommends spawning a chain of threads and wait for 63 handles and the
-previous thread in each. Sounds great!).
-
-Newer versions support more handles, but you need to define C<FD_SETSIZE>
-to some high number (e.g. C<2048>) before compiling the winsocket select
-call (which might be in libev or elsewhere, for example, perl and many
-other interpreters do their own select emulation on windows).
-
-Another limit is the number of file descriptors in the Microsoft runtime
-libraries, which by default is C<64> (there must be a hidden I<64>
-fetish or something like this inside Microsoft). You can increase this
-by calling C<_setmaxstdio>, which can increase this limit to C<2048>
-(another arbitrary limit), but is broken in many versions of the Microsoft
-runtime libraries. This might get you to about C<512> or C<2048> sockets
-(depending on windows version and/or the phase of the moon). To get more,
-you need to wrap all I/O functions and provide your own fd management, but
-the cost of calling select (O(n²)) will likely make this unworkable.
-
-=head2 PORTABILITY REQUIREMENTS
-
-In addition to a working ISO-C implementation and of course the
-backend-specific APIs, libev relies on a few additional extensions:
-
-=over 4
-
-=item C<void (*)(ev_watcher_type *, int revents)> must have compatible
-calling conventions regardless of C<ev_watcher_type *>.
-
-Libev assumes not only that all watcher pointers have the same internal
-structure (guaranteed by POSIX but not by ISO C for example), but it also
-assumes that the same (machine) code can be used to call any watcher
-callback: The watcher callbacks have different type signatures, but libev
-calls them using an C<ev_watcher *> internally.
-
-=item null pointers and integer zero are represented by 0 bytes
-
-Libev uses C<memset> to initialise structs and arrays to C<0> bytes, and
-relies on this setting pointers and integers to null.
-
-=item pointer accesses must be thread-atomic
-
-Accessing a pointer value must be atomic, it must both be readable and
-writable in one piece - this is the case on all current architectures.
-
-=item C<sig_atomic_t volatile> must be thread-atomic as well
-
-The type C<sig_atomic_t volatile> (or whatever is defined as
-C<EV_ATOMIC_T>) must be atomic with respect to accesses from different
-threads. This is not part of the specification for C<sig_atomic_t>, but is
-believed to be sufficiently portable.
-
-=item C<sigprocmask> must work in a threaded environment
-
-Libev uses C<sigprocmask> to temporarily block signals. This is not
-allowed in a threaded program (C<pthread_sigmask> has to be used). Typical
-pthread implementations will either allow C<sigprocmask> in the "main
-thread" or will block signals process-wide, both behaviours would
-be compatible with libev. Interaction between C<sigprocmask> and
-C<pthread_sigmask> could complicate things, however.
-
-The most portable way to handle signals is to block signals in all threads
-except the initial one, and run the signal handling loop in the initial
-thread as well.
-
-=item C<long> must be large enough for common memory allocation sizes
-
-To improve portability and simplify its API, libev uses C<long> internally
-instead of C<size_t> when allocating its data structures. On non-POSIX
-systems (Microsoft...) this might be unexpectedly low, but is still at
-least 31 bits everywhere, which is enough for hundreds of millions of
-watchers.
-
-=item C<double> must hold a time value in seconds with enough accuracy
-
-The type C<double> is used to represent timestamps. It is required to
-have at least 51 bits of mantissa (and 9 bits of exponent), which is
-good enough for at least into the year 4000 with millisecond accuracy
-(the design goal for libev). This requirement is overfulfilled by
-implementations using IEEE 754, which is basically all existing ones.
-
-With IEEE 754 doubles, you get microsecond accuracy until at least the
-year 2255 (and millisecond accuracy till the year 287396 - by then, libev
-is either obsolete or somebody patched it to use C<long double> or
-something like that, just kidding).
-
-=back
-
-If you know of other additional requirements drop me a note.
-
-
-=head1 ALGORITHMIC COMPLEXITIES
-
-In this section the complexities of (many of) the algorithms used inside
-libev will be documented. For complexity discussions about backends see
-the documentation for C<ev_default_init>.
-
-All of the following are about amortised time: If an array needs to be
-extended, libev needs to realloc and move the whole array, but this
-happens asymptotically rarer with higher number of elements, so O(1) might
-mean that libev does a lengthy realloc operation in rare cases, but on
-average it is much faster and asymptotically approaches constant time.
-
-=over 4
-
-=item Starting and stopping timer/periodic watchers: O(log skipped_other_timers)
-
-This means that, when you have a watcher that triggers in one hour and
-there are 100 watchers that would trigger before that, then inserting will
-have to skip roughly seven (C<ld 100>) of these watchers.
-
-=item Changing timer/periodic watchers (by autorepeat or calling again): O(log skipped_other_timers)
-
-That means that changing a timer costs less than removing/adding them,
-as only the relative motion in the event queue has to be paid for.
-
-=item Starting io/check/prepare/idle/signal/child/fork/async watchers: O(1)
-
-These just add the watcher into an array or at the head of a list.
-
-=item Stopping check/prepare/idle/fork/async watchers: O(1)
-
-=item Stopping an io/signal/child watcher: O(number_of_watchers_for_this_(fd/signal/pid % EV_PID_HASHSIZE))
-
-These watchers are stored in lists, so they need to be walked to find the
-correct watcher to remove. The lists are usually short (you don't usually
-have many watchers waiting for the same fd or signal: one is typical, two
-is rare).
-
-=item Finding the next timer in each loop iteration: O(1)
-
-By virtue of using a binary or 4-heap, the next timer is always found at a
-fixed position in the storage array.
-
-=item Each change on a file descriptor per loop iteration: O(number_of_watchers_for_this_fd)
-
-A change means an I/O watcher gets started or stopped, which requires
-libev to recalculate its status (and possibly tell the kernel, depending
-on backend and whether C<ev_io_set> was used).
-
-=item Activating one watcher (putting it into the pending state): O(1)
-
-=item Priority handling: O(number_of_priorities)
-
-Priorities are implemented by allocating some space for each
-priority. When doing priority-based operations, libev usually has to
-linearly search all the priorities, but starting/stopping and activating
-watchers becomes O(1) with respect to priority handling.
-
-=item Sending an ev_async: O(1)
-
-=item Processing ev_async_send: O(number_of_async_watchers)
-
-=item Processing signals: O(max_signal_number)
-
-Sending involves a system call I<iff> there were no other C<ev_async_send>
-calls in the current loop iteration and the loop is currently
-blocked. Checking for async and signal events involves iterating over all
-running async watchers or all signal numbers.
-
-=back
-
-
-=head1 PORTING FROM LIBEV 3.X TO 4.X
-
-The major version 4 introduced some incompatible changes to the API.
-
-At the moment, the C<ev.h> header file provides compatibility definitions
-for all changes, so most programs should still compile. The compatibility
-layer might be removed in later versions of libev, so better update to the
-new API early than late.
-
-=over 4
-
-=item C<EV_COMPAT3> backwards compatibility mechanism
-
-The backward compatibility mechanism can be controlled by
-C<EV_COMPAT3>. See L</"PREPROCESSOR SYMBOLS/MACROS"> in the L</EMBEDDING>
-section.
-
-=item C<ev_default_destroy> and C<ev_default_fork> have been removed
-
-These calls can be replaced easily by their C<ev_loop_xxx> counterparts:
-
-   ev_loop_destroy (EV_DEFAULT_UC);
-   ev_loop_fork (EV_DEFAULT);
-
-=item function/symbol renames
-
-A number of functions and symbols have been renamed:
-
-  ev_loop         => ev_run
-  EVLOOP_NONBLOCK => EVRUN_NOWAIT
-  EVLOOP_ONESHOT  => EVRUN_ONCE
-
-  ev_unloop       => ev_break
-  EVUNLOOP_CANCEL => EVBREAK_CANCEL
-  EVUNLOOP_ONE    => EVBREAK_ONE
-  EVUNLOOP_ALL    => EVBREAK_ALL
-
-  EV_TIMEOUT      => EV_TIMER
-
-  ev_loop_count   => ev_iteration
-  ev_loop_depth   => ev_depth
-  ev_loop_verify  => ev_verify
-
-Most functions working on C<struct ev_loop> objects don't have an
-C<ev_loop_> prefix, so it was removed; C<ev_loop>, C<ev_unloop> and
-associated constants have been renamed to not collide with the C<struct
-ev_loop> anymore and C<EV_TIMER> now follows the same naming scheme
-as all other watcher types. Note that C<ev_loop_fork> is still called
-C<ev_loop_fork> because it would otherwise clash with the C<ev_fork>
-typedef.
-
-=item C<EV_MINIMAL> mechanism replaced by C<EV_FEATURES>
-
-The preprocessor symbol C<EV_MINIMAL> has been replaced by a different
-mechanism, C<EV_FEATURES>. Programs using C<EV_MINIMAL> usually compile
-and work, but the library code will of course be larger.
-
-=back
-
-
-=head1 GLOSSARY
-
-=over 4
-
-=item active
-
-A watcher is active as long as it has been started and not yet stopped.
-See L</WATCHER STATES> for details.
-
-=item application
-
-In this document, an application is whatever is using libev.
-
-=item backend
-
-The part of the code dealing with the operating system interfaces.
-
-=item callback
-
-The address of a function that is called when some event has been
-detected. Callbacks are being passed the event loop, the watcher that
-received the event, and the actual event bitset.
-
-=item callback/watcher invocation
-
-The act of calling the callback associated with a watcher.
-
-=item event
-
-A change of state of some external event, such as data now being available
-for reading on a file descriptor, time having passed or simply not having
-any other events happening anymore.
-
-In libev, events are represented as single bits (such as C<EV_READ> or
-C<EV_TIMER>).
-
-=item event library
-
-A software package implementing an event model and loop.
-
-=item event loop
-
-An entity that handles and processes external events and converts them
-into callback invocations.
-
-=item event model
-
-The model used to describe how an event loop handles and processes
-watchers and events.
-
-=item pending
-
-A watcher is pending as soon as the corresponding event has been
-detected. See L</WATCHER STATES> for details.
-
-=item real time
-
-The physical time that is observed. It is apparently strictly monotonic :)
-
-=item wall-clock time
-
-The time and date as shown on clocks. Unlike real time, it can actually
-be wrong and jump forwards and backwards, e.g. when you adjust your
-clock.
-
-=item watcher
-
-A data structure that describes interest in certain events. Watchers need
-to be started (attached to an event loop) before they can receive events.
-
-=back
-
-=head1 AUTHOR
-
-Marc Lehmann <libev@schmorp.de>, with repeated corrections by Mikael
-Magnusson and Emanuele Giaquinta, and minor corrections by many others.
-
diff --git a/libev/ev_epoll.c b/libev/ev_epoll.c
index 6aef862..58cfa68 100644
--- a/libev/ev_epoll.c
+++ b/libev/ev_epoll.c
@@ -1,7 +1,7 @@
 /*
  * libev epoll fd activity backend
  *
- * Copyright (c) 2007,2008,2009,2010,2011 Marc Alexander Lehmann <libev@schmorp.de>
+ * Copyright (c) 2007,2008,2009,2010,2011,2016,2017,2019 Marc Alexander Lehmann <libev@schmorp.de>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modifica-
@@ -93,10 +93,10 @@ epoll_modify (EV_P_ int fd, int oev, int nev)
   ev.events   = (nev & EV_READ  ? EPOLLIN  : 0)
               | (nev & EV_WRITE ? EPOLLOUT : 0);
 
-  if (expect_true (!epoll_ctl (backend_fd, oev && oldmask != nev ? EPOLL_CTL_MOD : EPOLL_CTL_ADD, fd, &ev)))
+  if (ecb_expect_true (!epoll_ctl (backend_fd, oev && oldmask != nev ? EPOLL_CTL_MOD : EPOLL_CTL_ADD, fd, &ev)))
     return;
 
-  if (expect_true (errno == ENOENT))
+  if (ecb_expect_true (errno == ENOENT))
     {
       /* if ENOENT then the fd went away, so try to do the right thing */
       if (!nev)
@@ -105,7 +105,7 @@ epoll_modify (EV_P_ int fd, int oev, int nev)
       if (!epoll_ctl (backend_fd, EPOLL_CTL_ADD, fd, &ev))
         return;
     }
-  else if (expect_true (errno == EEXIST))
+  else if (ecb_expect_true (errno == EEXIST))
     {
       /* EEXIST means we ignored a previous DEL, but the fd is still active */
       /* if the kernel mask is the same as the new mask, we assume it hasn't changed */
@@ -115,7 +115,7 @@ epoll_modify (EV_P_ int fd, int oev, int nev)
       if (!epoll_ctl (backend_fd, EPOLL_CTL_MOD, fd, &ev))
         return;
     }
-  else if (expect_true (errno == EPERM))
+  else if (ecb_expect_true (errno == EPERM))
     {
       /* EPERM means the fd is always ready, but epoll is too snobbish */
       /* to handle it, unlike select or poll. */
@@ -124,12 +124,14 @@ epoll_modify (EV_P_ int fd, int oev, int nev)
       /* add fd to epoll_eperms, if not already inside */
       if (!(oldmask & EV_EMASK_EPERM))
         {
-          array_needsize (int, epoll_eperms, epoll_epermmax, epoll_epermcnt + 1, EMPTY2);
+          array_needsize (int, epoll_eperms, epoll_epermmax, epoll_epermcnt + 1, array_needsize_noinit);
           epoll_eperms [epoll_epermcnt++] = fd;
         }
 
       return;
     }
+  else
+    assert (("libev: I/O watcher with invalid fd found in epoll_ctl", errno != EBADF && errno != ELOOP && errno != EINVAL));
 
   fd_kill (EV_A_ fd);
 
@@ -144,16 +146,16 @@ epoll_poll (EV_P_ ev_tstamp timeout)
   int i;
   int eventcnt;
 
-  if (expect_false (epoll_epermcnt))
-    timeout = 0.;
+  if (ecb_expect_false (epoll_epermcnt))
+    timeout = EV_TS_CONST (0.);
 
   /* epoll wait times cannot be larger than (LONG_MAX - 999UL) / HZ msecs, which is below */
   /* the default libev max wait time, however. */
   EV_RELEASE_CB;
-  eventcnt = epoll_wait (backend_fd, epoll_events, epoll_eventmax, timeout * 1e3);
+  eventcnt = epoll_wait (backend_fd, epoll_events, epoll_eventmax, EV_TS_TO_MSEC (timeout));
   EV_ACQUIRE_CB;
 
-  if (expect_false (eventcnt < 0))
+  if (ecb_expect_false (eventcnt < 0))
     {
       if (errno != EINTR)
         ev_syserr ("(libev) epoll_wait");
@@ -176,14 +178,14 @@ epoll_poll (EV_P_ ev_tstamp timeout)
        * other spurious notifications will be found by epoll_ctl, below
        * we assume that fd is always in range, as we never shrink the anfds array
        */
-      if (expect_false ((uint32_t)anfds [fd].egen != (uint32_t)(ev->data.u64 >> 32)))
+      if (ecb_expect_false ((uint32_t)anfds [fd].egen != (uint32_t)(ev->data.u64 >> 32)))
         {
           /* recreate kernel state */
           postfork |= 2;
           continue;
         }
 
-      if (expect_false (got & ~want))
+      if (ecb_expect_false (got & ~want))
         {
           anfds [fd].emask = want;
 
@@ -195,6 +197,8 @@ epoll_poll (EV_P_ ev_tstamp timeout)
            * above with the gencounter check (== our fd is not the event fd), and
            * partially here, when epoll_ctl returns an error (== a child has the fd
            * but we closed it).
+           * note: for events such as POLLHUP, where we can't know whether it refers
+           * to EV_READ or EV_WRITE, we might issue redundant EPOLL_CTL_MOD calls.
            */
           ev->events = (want & EV_READ  ? EPOLLIN  : 0)
                      | (want & EV_WRITE ? EPOLLOUT : 0);
@@ -212,7 +216,7 @@ epoll_poll (EV_P_ ev_tstamp timeout)
     }
 
   /* if the receive array was full, increase its size */
-  if (expect_false (eventcnt == epoll_eventmax))
+  if (ecb_expect_false (eventcnt == epoll_eventmax))
     {
       ev_free (epoll_events);
       epoll_eventmax = array_nextsize (sizeof (struct epoll_event), epoll_eventmax, epoll_eventmax + 1);
@@ -235,23 +239,34 @@ epoll_poll (EV_P_ ev_tstamp timeout)
     }
 }
 
-inline_size
-int
-epoll_init (EV_P_ int flags)
+static int
+epoll_epoll_create (void)
 {
+  int fd;
+
 #if defined EPOLL_CLOEXEC && !defined __ANDROID__
-  backend_fd = epoll_create1 (EPOLL_CLOEXEC);
+  fd = epoll_create1 (EPOLL_CLOEXEC);
 
-  if (backend_fd < 0 && (errno == EINVAL || errno == ENOSYS))
+  if (fd < 0 && (errno == EINVAL || errno == ENOSYS))
 #endif
-    backend_fd = epoll_create (256);
+    {
+      fd = epoll_create (256);
 
-  if (backend_fd < 0)
-    return 0;
+      if (fd >= 0)
+        fcntl (fd, F_SETFD, FD_CLOEXEC);
+    }
+
+  return fd;
+}
 
-  fcntl (backend_fd, F_SETFD, FD_CLOEXEC);
+inline_size
+int
+epoll_init (EV_P_ int flags)
+{
+  if ((backend_fd = epoll_epoll_create ()) < 0)
+    return 0;
 
-  backend_mintime = 1e-3; /* epoll does sometimes return early, this is just to avoid the worst */
+  backend_mintime = EV_TS_CONST (1e-3); /* epoll does sometimes return early, this is just to avoid the worst */
   backend_modify  = epoll_modify;
   backend_poll    = epoll_poll;
 
@@ -269,17 +284,15 @@ epoll_destroy (EV_P)
   array_free (epoll_eperm, EMPTY);
 }
 
-inline_size
-void
+ecb_cold
+static void
 epoll_fork (EV_P)
 {
   close (backend_fd);
 
-  while ((backend_fd = epoll_create (256)) < 0)
+  while ((backend_fd = epoll_epoll_create ()) < 0)
     ev_syserr ("(libev) epoll_create");
 
-  fcntl (backend_fd, F_SETFD, FD_CLOEXEC);
-
   fd_rearm_all (EV_A);
 }
 
diff --git a/libev/ev_iouring.c b/libev/ev_iouring.c
new file mode 100644
index 0000000..bfd3de6
--- /dev/null
+++ b/libev/ev_iouring.c
@@ -0,0 +1,694 @@
+/*
+ * libev linux io_uring fd activity backend
+ *
+ * Copyright (c) 2019-2020 Marc Alexander Lehmann <libev@schmorp.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+/*
+ * general notes about linux io_uring:
+ *
+ * a) it's the best interface I have seen so far. on linux.
+ * b) best is not necessarily very good.
+ * c) it's better than the aio mess, doesn't suffer from the fork problems
+ *    of linux aio or epoll and so on and so on. and you could do event stuff
+ *    without any syscalls. what's not to like?
+ * d) ok, it's vastly more complex, but that's ok, really.
+ * e) why two mmaps instead of one? one would be more space-efficient,
+ *    and I can't see what benefit two would have (other than being
+ *    somehow resizable/relocatable, but that's apparently not possible).
+ * f) hmm, it's practically undebuggable (gdb can't access the memory, and
+ *    the bizarre way structure offsets are communicated makes it hard to
+ *    just print the ring buffer heads, even *iff* the memory were visible
+ *    in gdb. but then, that's also ok, really.
+ * g) well, you cannot specify a timeout when waiting for events. no,
+ *    seriously, the interface doesn't support a timeout. never seen _that_
+ *    before. sure, you can use a timerfd, but that's another syscall
+ *    you could have avoided. overall, this bizarre omission smells
+ *    like a µ-optimisation by the io_uring author for his personal
+ *    applications, to the detriment of everybody else who just wants
+ *    an event loop. but, umm, ok, if that's all, it could be worse.
+ *    (from what I gather from the author Jens Axboe, it simply didn't
+ *    occur to him, and he made good on it by adding an unlimited nuber
+ *    of timeouts later :).
+ * h) initially there was a hardcoded limit of 4096 outstanding events.
+ *    later versions not only bump this to 32k, but also can handle
+ *    an unlimited amount of events, so this only affects the batch size.
+ * i) unlike linux aio, you *can* register more then the limit
+ *    of fd events. while early verisons of io_uring signalled an overflow
+ *    and you ended up getting wet. 5.5+ does not do this anymore.
+ * j) but, oh my! it had exactly the same bugs as the linux aio backend,
+ *    where some undocumented poll combinations just fail. fortunately,
+ *    after finally reaching the author, he was more than willing to fix
+ *    this probably in 5.6+.
+ * k) overall, the *API* itself is, I dare to say, not a total trainwreck.
+ *    once the bugs ae fixed (probably in 5.6+), it will be without
+ *    competition.
+ */
+
+/* TODO: use internal TIMEOUT */
+/* TODO: take advantage of single mmap, NODROP etc. */
+/* TODO: resize cq/sq size independently */
+
+#include <sys/timerfd.h>
+#include <sys/mman.h>
+#include <poll.h>
+#include <stdint.h>
+
+#define IOURING_INIT_ENTRIES 32
+
+/*****************************************************************************/
+/* syscall wrapdadoop - this section has the raw api/abi definitions */
+
+#include <linux/fs.h>
+#include <linux/types.h>
+
+/* mostly directly taken from the kernel or documentation */
+
+struct io_uring_sqe
+{
+  __u8 opcode;
+  __u8 flags;
+  __u16 ioprio;
+  __s32 fd;
+  union {
+    __u64 off;
+    __u64 addr2;
+  };
+  __u64 addr;
+  __u32 len;
+  union {
+    __kernel_rwf_t rw_flags;
+    __u32 fsync_flags;
+    __u16 poll_events;
+    __u32 sync_range_flags;
+    __u32 msg_flags;
+    __u32 timeout_flags;
+    __u32 accept_flags;
+    __u32 cancel_flags;
+    __u32 open_flags;
+    __u32 statx_flags;
+  };
+  __u64 user_data;
+  union {
+    __u16 buf_index;
+    __u64 __pad2[3];
+  };
+};
+
+struct io_uring_cqe
+{
+  __u64 user_data;
+  __s32 res;
+  __u32 flags;
+};
+
+struct io_sqring_offsets
+{
+  __u32 head;
+  __u32 tail;
+  __u32 ring_mask;
+  __u32 ring_entries;
+  __u32 flags;
+  __u32 dropped;
+  __u32 array;
+  __u32 resv1;
+  __u64 resv2;
+};
+
+struct io_cqring_offsets
+{
+  __u32 head;
+  __u32 tail;
+  __u32 ring_mask;
+  __u32 ring_entries;
+  __u32 overflow;
+  __u32 cqes;
+  __u64 resv[2];
+};
+
+struct io_uring_params
+{
+  __u32 sq_entries;
+  __u32 cq_entries;
+  __u32 flags;
+  __u32 sq_thread_cpu;
+  __u32 sq_thread_idle;
+  __u32 features;
+  __u32 resv[4];
+  struct io_sqring_offsets sq_off;
+  struct io_cqring_offsets cq_off;
+};
+
+#define IORING_SETUP_CQSIZE 0x00000008
+
+#define IORING_OP_POLL_ADD        6
+#define IORING_OP_POLL_REMOVE     7
+#define IORING_OP_TIMEOUT        11
+#define IORING_OP_TIMEOUT_REMOVE 12
+
+/* relative or absolute, reference clock is CLOCK_MONOTONIC */
+struct iouring_kernel_timespec
+{
+  int64_t tv_sec;
+  long long tv_nsec;
+};
+
+#define IORING_TIMEOUT_ABS 0x00000001
+
+#define IORING_ENTER_GETEVENTS 0x01
+
+#define IORING_OFF_SQ_RING 0x00000000ULL
+#define IORING_OFF_CQ_RING 0x08000000ULL
+#define IORING_OFF_SQES	   0x10000000ULL
+
+#define IORING_FEAT_SINGLE_MMAP   0x00000001
+#define IORING_FEAT_NODROP        0x00000002
+#define IORING_FEAT_SUBMIT_STABLE 0x00000004
+
+inline_size
+int
+evsys_io_uring_setup (unsigned entries, struct io_uring_params *params)
+{
+  return ev_syscall2 (SYS_io_uring_setup, entries, params);
+}
+
+inline_size
+int
+evsys_io_uring_enter (int fd, unsigned to_submit, unsigned min_complete, unsigned flags, const sigset_t *sig, size_t sigsz)
+{
+  return ev_syscall6 (SYS_io_uring_enter, fd, to_submit, min_complete, flags, sig, sigsz);
+}
+
+/*****************************************************************************/
+/* actual backed implementation */
+
+/* we hope that volatile will make the compiler access this variables only once */
+#define EV_SQ_VAR(name) *(volatile unsigned *)((char *)iouring_sq_ring + iouring_sq_ ## name)
+#define EV_CQ_VAR(name) *(volatile unsigned *)((char *)iouring_cq_ring + iouring_cq_ ## name)
+
+/* the index array */
+#define EV_SQ_ARRAY     ((unsigned *)((char *)iouring_sq_ring + iouring_sq_array))
+
+/* the submit/completion queue entries */
+#define EV_SQES         ((struct io_uring_sqe *)         iouring_sqes)
+#define EV_CQES         ((struct io_uring_cqe *)((char *)iouring_cq_ring + iouring_cq_cqes))
+
+inline_speed
+int
+iouring_enter (EV_P_ ev_tstamp timeout)
+{
+  int res;
+
+  EV_RELEASE_CB;
+
+  res = evsys_io_uring_enter (iouring_fd, iouring_to_submit, 1,
+                              timeout > EV_TS_CONST (0.) ? IORING_ENTER_GETEVENTS : 0, 0, 0);
+
+  assert (("libev: io_uring_enter did not consume all sqes", (res < 0 || res == iouring_to_submit)));
+
+  iouring_to_submit = 0;
+
+  EV_ACQUIRE_CB;
+
+  return res;
+}
+
+/* TODO: can we move things around so we don't need this forward-reference? */
+static void
+iouring_poll (EV_P_ ev_tstamp timeout);
+
+static
+struct io_uring_sqe *
+iouring_sqe_get (EV_P)
+{
+  unsigned tail;
+  
+  for (;;)
+    {
+      tail = EV_SQ_VAR (tail);
+
+      if (ecb_expect_true (tail + 1 - EV_SQ_VAR (head) <= EV_SQ_VAR (ring_entries)))
+        break; /* whats the problem, we have free sqes */
+
+      /* queue full, need to flush and possibly handle some events */
+
+#if EV_FEATURE_CODE
+      /* first we ask the kernel nicely, most often this frees up some sqes */
+      int res = iouring_enter (EV_A_ EV_TS_CONST (0.));
+
+      ECB_MEMORY_FENCE_ACQUIRE; /* better safe than sorry */
+
+      if (res >= 0)
+        continue; /* yes, it worked, try again */
+#endif
+
+      /* some problem, possibly EBUSY - do the full poll and let it handle any issues */
+
+      iouring_poll (EV_A_ EV_TS_CONST (0.));
+      /* iouring_poll should have done ECB_MEMORY_FENCE_ACQUIRE for us */
+    }
+
+  /*assert (("libev: io_uring queue full after flush", tail + 1 - EV_SQ_VAR (head) <= EV_SQ_VAR (ring_entries)));*/
+
+  return EV_SQES + (tail & EV_SQ_VAR (ring_mask));
+}
+
+inline_size
+struct io_uring_sqe *
+iouring_sqe_submit (EV_P_ struct io_uring_sqe *sqe)
+{
+  unsigned idx = sqe - EV_SQES;
+
+  EV_SQ_ARRAY [idx] = idx;
+  ECB_MEMORY_FENCE_RELEASE;
+  ++EV_SQ_VAR (tail);
+  /*ECB_MEMORY_FENCE_RELEASE; /* for the time being we assume this is not needed */
+  ++iouring_to_submit;
+}
+
+/*****************************************************************************/
+
+/* when the timerfd expires we simply note the fact,
+ * as the purpose of the timerfd is to wake us up, nothing else.
+ * the next iteration should re-set it.
+ */
+static void
+iouring_tfd_cb (EV_P_ struct ev_io *w, int revents)
+{
+  iouring_tfd_to = EV_TSTAMP_HUGE;
+}
+
+/* called for full and partial cleanup */
+ecb_cold
+static int
+iouring_internal_destroy (EV_P)
+{
+  close (iouring_tfd);
+  close (iouring_fd);
+
+  if (iouring_sq_ring != MAP_FAILED) munmap (iouring_sq_ring, iouring_sq_ring_size);
+  if (iouring_cq_ring != MAP_FAILED) munmap (iouring_cq_ring, iouring_cq_ring_size);
+  if (iouring_sqes    != MAP_FAILED) munmap (iouring_sqes   , iouring_sqes_size   );
+
+  if (ev_is_active (&iouring_tfd_w))
+    {
+      ev_ref (EV_A);
+      ev_io_stop (EV_A_ &iouring_tfd_w);
+    }
+}
+
+ecb_cold
+static int
+iouring_internal_init (EV_P)
+{
+  struct io_uring_params params = { 0 };
+
+  iouring_to_submit = 0;
+
+  iouring_tfd     = -1;
+  iouring_sq_ring = MAP_FAILED;
+  iouring_cq_ring = MAP_FAILED;
+  iouring_sqes    = MAP_FAILED;
+
+  if (!have_monotonic) /* cannot really happen, but what if11 */
+    return -1;
+
+  for (;;)
+    {
+      iouring_fd = evsys_io_uring_setup (iouring_entries, &params);
+
+      if (iouring_fd >= 0)
+        break; /* yippie */
+
+      if (errno != EINVAL)
+        return -1; /* we failed */
+
+#if TODO
+      if ((~params.features) & (IORING_FEAT_NODROP | IORING_FEATURE_SINGLE_MMAP | IORING_FEAT_SUBMIT_STABLE))
+        return -1; /* we require the above features */
+#endif
+
+      /* EINVAL: lots of possible reasons, but maybe
+       * it is because we hit the unqueryable hardcoded size limit
+       */
+
+      /* we hit the limit already, give up */
+      if (iouring_max_entries)
+        return -1;
+
+      /* first time we hit EINVAL? assume we hit the limit, so go back and retry */
+      iouring_entries >>= 1;
+      iouring_max_entries = iouring_entries;
+    }
+
+  iouring_sq_ring_size = params.sq_off.array + params.sq_entries * sizeof (unsigned);
+  iouring_cq_ring_size = params.cq_off.cqes  + params.cq_entries * sizeof (struct io_uring_cqe);
+  iouring_sqes_size    =                       params.sq_entries * sizeof (struct io_uring_sqe);
+
+  iouring_sq_ring = mmap (0, iouring_sq_ring_size, PROT_READ | PROT_WRITE,
+                          MAP_SHARED | MAP_POPULATE, iouring_fd, IORING_OFF_SQ_RING);
+  iouring_cq_ring = mmap (0, iouring_cq_ring_size, PROT_READ | PROT_WRITE,
+                          MAP_SHARED | MAP_POPULATE, iouring_fd, IORING_OFF_CQ_RING);
+  iouring_sqes    = mmap (0, iouring_sqes_size, PROT_READ | PROT_WRITE,
+                          MAP_SHARED | MAP_POPULATE, iouring_fd, IORING_OFF_SQES);
+
+  if (iouring_sq_ring == MAP_FAILED || iouring_cq_ring == MAP_FAILED || iouring_sqes == MAP_FAILED)
+    return -1;
+
+  iouring_sq_head         = params.sq_off.head;
+  iouring_sq_tail         = params.sq_off.tail;
+  iouring_sq_ring_mask    = params.sq_off.ring_mask;
+  iouring_sq_ring_entries = params.sq_off.ring_entries;
+  iouring_sq_flags        = params.sq_off.flags;
+  iouring_sq_dropped      = params.sq_off.dropped;
+  iouring_sq_array        = params.sq_off.array;
+
+  iouring_cq_head         = params.cq_off.head;
+  iouring_cq_tail         = params.cq_off.tail;
+  iouring_cq_ring_mask    = params.cq_off.ring_mask;
+  iouring_cq_ring_entries = params.cq_off.ring_entries;
+  iouring_cq_overflow     = params.cq_off.overflow;
+  iouring_cq_cqes         = params.cq_off.cqes;
+
+  iouring_tfd = timerfd_create (CLOCK_MONOTONIC, TFD_CLOEXEC);
+
+  if (iouring_tfd < 0)
+    return iouring_tfd;
+
+  iouring_tfd_to = EV_TSTAMP_HUGE;
+
+  return 0;
+}
+
+ecb_cold
+static void
+iouring_fork (EV_P)
+{
+  iouring_internal_destroy (EV_A);
+
+  while (iouring_internal_init (EV_A) < 0)
+    ev_syserr ("(libev) io_uring_setup");
+
+  fd_rearm_all (EV_A);
+
+  ev_io_stop  (EV_A_ &iouring_tfd_w);
+  ev_io_set   (EV_A_ &iouring_tfd_w, iouring_tfd, EV_READ);
+  ev_io_start (EV_A_ &iouring_tfd_w);
+}
+
+/*****************************************************************************/
+
+static void
+iouring_modify (EV_P_ int fd, int oev, int nev)
+{
+  if (oev)
+    {
+      /* we assume the sqe's are all "properly" initialised */
+      struct io_uring_sqe *sqe = iouring_sqe_get (EV_A);
+      sqe->opcode    = IORING_OP_POLL_REMOVE;
+      sqe->fd        = fd;
+      /* Jens Axboe notified me that user_data is not what is documented, but is
+       * some kind of unique ID that has to match, otherwise the request cannot
+       * be removed. Since we don't *really* have that, we pass in the old
+       * generation counter - if that fails, too bad, it will hopefully be removed
+       * at close time and then be ignored. */
+      sqe->addr      = (uint32_t)fd | ((__u64)(uint32_t)anfds [fd].egen << 32);
+      sqe->user_data = (uint64_t)-1;
+      iouring_sqe_submit (EV_A_ sqe);
+
+      /* increment generation counter to avoid handling old events */
+      ++anfds [fd].egen;
+    }
+
+  if (nev)
+    {
+      struct io_uring_sqe *sqe = iouring_sqe_get (EV_A);
+      sqe->opcode      = IORING_OP_POLL_ADD;
+      sqe->fd          = fd;
+      sqe->addr        = 0;
+      sqe->user_data   = (uint32_t)fd | ((__u64)(uint32_t)anfds [fd].egen << 32);
+      sqe->poll_events =
+        (nev & EV_READ ? POLLIN : 0)
+        | (nev & EV_WRITE ? POLLOUT : 0);
+      iouring_sqe_submit (EV_A_ sqe);
+    }
+}
+
+inline_size
+void
+iouring_tfd_update (EV_P_ ev_tstamp timeout)
+{
+  ev_tstamp tfd_to = mn_now + timeout;
+
+  /* we assume there will be many iterations per timer change, so
+   * we only re-set the timerfd when we have to because its expiry
+   * is too late.
+   */
+  if (ecb_expect_false (tfd_to < iouring_tfd_to))
+    {
+       struct itimerspec its;
+
+       iouring_tfd_to = tfd_to;
+       EV_TS_SET (its.it_interval, 0.);
+       EV_TS_SET (its.it_value, tfd_to);
+
+       if (timerfd_settime (iouring_tfd, TFD_TIMER_ABSTIME, &its, 0) < 0)
+         assert (("libev: iouring timerfd_settime failed", 0));
+    }
+}
+
+inline_size
+void
+iouring_process_cqe (EV_P_ struct io_uring_cqe *cqe)
+{
+  int      fd  = cqe->user_data & 0xffffffffU;
+  uint32_t gen = cqe->user_data >> 32;
+  int      res = cqe->res;
+
+  /* user_data -1 is a remove that we are not atm. interested in */
+  if (cqe->user_data == (uint64_t)-1)
+    return;
+
+  assert (("libev: io_uring fd must be in-bounds", fd >= 0 && fd < anfdmax));
+
+  /* documentation lies, of course. the result value is NOT like
+   * normal syscalls, but like linux raw syscalls, i.e. negative
+   * error numbers. fortunate, as otherwise there would be no way
+   * to get error codes at all. still, why not document this?
+   */
+
+  /* ignore event if generation doesn't match */
+  /* other than skipping removal events, */
+  /* this should actually be very rare */
+  if (ecb_expect_false (gen != (uint32_t)anfds [fd].egen))
+    return;
+
+  if (ecb_expect_false (res < 0))
+    {
+      /*TODO: EINVAL handling (was something failed with this fd)*/
+
+      if (res == -EBADF)
+        {
+          assert (("libev: event loop rejected bad fd", res != -EBADF));
+          fd_kill (EV_A_ fd);
+        }
+      else
+        {
+          errno = -res;
+          ev_syserr ("(libev) IORING_OP_POLL_ADD");
+        }
+
+      return;
+    }
+
+  /* feed events, we do not expect or handle POLLNVAL */
+  fd_event (
+    EV_A_
+    fd,
+    (res & (POLLOUT | POLLERR | POLLHUP) ? EV_WRITE : 0)
+    | (res & (POLLIN | POLLERR | POLLHUP) ? EV_READ : 0)
+  );
+
+  /* io_uring is oneshot, so we need to re-arm the fd next iteration */
+  /* this also means we usually have to do at least one syscall per iteration */
+  anfds [fd].events = 0;
+  fd_change (EV_A_ fd, EV_ANFD_REIFY);
+}
+
+/* called when the event queue overflows */
+ecb_cold
+static void
+iouring_overflow (EV_P)
+{
+  /* we have two options, resize the queue (by tearing down
+   * everything and recreating it, or living with it
+   * and polling.
+   * we implement this by resizing the queue, and, if that fails,
+   * we just recreate the state on every failure, which
+   * kind of is a very inefficient poll.
+   * one danger is, due to the bios toward lower fds,
+   * we will only really get events for those, so
+   * maybe we need a poll() fallback, after all.
+   */
+  /*EV_CQ_VAR (overflow) = 0;*/ /* need to do this if we keep the state and poll manually */
+
+  fd_rearm_all (EV_A);
+
+  /* we double the size until we hit the hard-to-probe maximum */
+  if (!iouring_max_entries)
+    {
+      iouring_entries <<= 1;
+      iouring_fork (EV_A);
+    }
+  else
+    {
+      /* we hit the kernel limit, we should fall back to something else.
+       * we can either poll() a few times and hope for the best,
+       * poll always, or switch to epoll.
+       * TODO: is this necessary with newer kernels?
+       */
+
+      iouring_internal_destroy (EV_A);
+
+      /* this should make it so that on return, we don't call any uring functions */
+      iouring_to_submit = 0;
+
+      for (;;)
+        {
+          backend = epoll_init (EV_A_ 0);
+
+          if (backend)
+            break;
+
+          ev_syserr ("(libev) iouring switch to epoll");
+        }
+    }
+}
+
+/* handle any events in the completion queue, return true if there were any */
+static int
+iouring_handle_cq (EV_P)
+{
+  unsigned head, tail, mask;
+  
+  head = EV_CQ_VAR (head);
+  ECB_MEMORY_FENCE_ACQUIRE;
+  tail = EV_CQ_VAR (tail);
+
+  if (head == tail)
+    return 0;
+
+  /* it can only overflow if we have events, yes, yes? */
+  if (ecb_expect_false (EV_CQ_VAR (overflow)))
+    {
+      iouring_overflow (EV_A);
+      return 1;
+    }
+
+  mask = EV_CQ_VAR (ring_mask);
+
+  do
+    iouring_process_cqe (EV_A_ &EV_CQES [head++ & mask]);
+  while (head != tail);
+
+  EV_CQ_VAR (head) = head;
+  ECB_MEMORY_FENCE_RELEASE;
+
+  return 1;
+}
+
+static void
+iouring_poll (EV_P_ ev_tstamp timeout)
+{
+  /* if we have events, no need for extra syscalls, but we might have to queue events */
+  /* we also clar the timeout if there are outstanding fdchanges */
+  /* the latter should only happen if both the sq and cq are full, most likely */
+  /* because we have a lot of event sources that immediately complete */
+  /* TODO: fdchacngecnt is always 0 because fd_reify does not have two buffers yet */
+  if (iouring_handle_cq (EV_A) || fdchangecnt)
+    timeout = EV_TS_CONST (0.);
+  else
+    /* no events, so maybe wait for some */
+    iouring_tfd_update (EV_A_ timeout);
+
+  /* only enter the kernel if we have something to submit, or we need to wait */
+  if (timeout || iouring_to_submit)
+    {
+      int res = iouring_enter (EV_A_ timeout);
+
+      if (ecb_expect_false (res < 0))
+        if (errno == EINTR)
+          /* ignore */;
+        else if (errno == EBUSY)
+          /* cq full, cannot submit - should be rare because we flush the cq first, so simply ignore */;
+        else
+          ev_syserr ("(libev) iouring setup");
+      else
+        iouring_handle_cq (EV_A);
+    }
+}
+
+inline_size
+int
+iouring_init (EV_P_ int flags)
+{
+  iouring_entries     = IOURING_INIT_ENTRIES;
+  iouring_max_entries = 0;
+
+  if (iouring_internal_init (EV_A) < 0)
+    {
+      iouring_internal_destroy (EV_A);
+      return 0;
+    }
+
+  ev_io_init  (&iouring_tfd_w, iouring_tfd_cb, iouring_tfd, EV_READ);
+  ev_set_priority (&iouring_tfd_w, EV_MINPRI);
+  ev_io_start (EV_A_ &iouring_tfd_w);
+  ev_unref (EV_A); /* watcher should not keep loop alive */
+
+  backend_modify = iouring_modify;
+  backend_poll   = iouring_poll;
+
+  return EVBACKEND_IOURING;
+}
+
+inline_size
+void
+iouring_destroy (EV_P)
+{
+  iouring_internal_destroy (EV_A);
+}
+
diff --git a/libev/ev_kqueue.c b/libev/ev_kqueue.c
index 0c05ab9..69c5147 100644
--- a/libev/ev_kqueue.c
+++ b/libev/ev_kqueue.c
@@ -1,7 +1,7 @@
 /*
  * libev kqueue backend
  *
- * Copyright (c) 2007,2008,2009,2010,2011,2012,2013 Marc Alexander Lehmann <libev@schmorp.de>
+ * Copyright (c) 2007,2008,2009,2010,2011,2012,2013,2016,2019 Marc Alexander Lehmann <libev@schmorp.de>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modifica-
@@ -48,7 +48,7 @@ void
 kqueue_change (EV_P_ int fd, int filter, int flags, int fflags)
 {
   ++kqueue_changecnt;
-  array_needsize (struct kevent, kqueue_changes, kqueue_changemax, kqueue_changecnt, EMPTY2);
+  array_needsize (struct kevent, kqueue_changes, kqueue_changemax, kqueue_changecnt, array_needsize_noinit);
 
   EV_SET (&kqueue_changes [kqueue_changecnt - 1], fd, filter, flags, fflags, 0, 0);
 }
@@ -103,10 +103,10 @@ kqueue_poll (EV_P_ ev_tstamp timeout)
   EV_ACQUIRE_CB;
   kqueue_changecnt = 0;
 
-  if (expect_false (res < 0))
+  if (ecb_expect_false (res < 0))
     {
       if (errno != EINTR)
-        ev_syserr ("(libev) kevent");
+        ev_syserr ("(libev) kqueue kevent");
 
       return;
     }
@@ -115,7 +115,7 @@ kqueue_poll (EV_P_ ev_tstamp timeout)
     {
       int fd = kqueue_events [i].ident;
 
-      if (expect_false (kqueue_events [i].flags & EV_ERROR))
+      if (ecb_expect_false (kqueue_events [i].flags & EV_ERROR))
         {
           int err = kqueue_events [i].data;
 
@@ -129,10 +129,16 @@ kqueue_poll (EV_P_ ev_tstamp timeout)
                   if (fd_valid (fd))
                     kqueue_modify (EV_A_ fd, 0, anfds [fd].events);
                   else
-                    fd_kill (EV_A_ fd);
+                    {
+                      assert (("libev: kqueue found invalid fd", 0));
+                      fd_kill (EV_A_ fd);
+                    }
                 }
               else /* on all other errors, we error out on the fd */
-                fd_kill (EV_A_ fd);
+                {
+                  assert (("libev: kqueue found invalid fd", 0));
+                  fd_kill (EV_A_ fd);
+                }
             }
         }
       else
@@ -145,7 +151,7 @@ kqueue_poll (EV_P_ ev_tstamp timeout)
         );
     }
 
-  if (expect_false (res == kqueue_eventmax))
+  if (ecb_expect_false (res == kqueue_eventmax))
     {
       ev_free (kqueue_events);
       kqueue_eventmax = array_nextsize (sizeof (struct kevent), kqueue_eventmax, kqueue_eventmax + 1);
@@ -164,7 +170,7 @@ kqueue_init (EV_P_ int flags)
 
   fcntl (backend_fd, F_SETFD, FD_CLOEXEC); /* not sure if necessary, hopefully doesn't hurt */
 
-  backend_mintime = 1e-9; /* apparently, they did the right thing in freebsd */
+  backend_mintime = EV_TS_CONST (1e-9); /* apparently, they did the right thing in freebsd */
   backend_modify  = kqueue_modify;
   backend_poll    = kqueue_poll;
 
diff --git a/libev/ev_linuxaio.c b/libev/ev_linuxaio.c
new file mode 100644
index 0000000..4687a70
--- /dev/null
+++ b/libev/ev_linuxaio.c
@@ -0,0 +1,620 @@
+/*
+ * libev linux aio fd activity backend
+ *
+ * Copyright (c) 2019 Marc Alexander Lehmann <libev@schmorp.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+/*
+ * general notes about linux aio:
+ *
+ * a) at first, the linux aio IOCB_CMD_POLL functionality introduced in
+ *    4.18 looks too good to be true: both watchers and events can be
+ *    batched, and events can even be handled in userspace using
+ *    a ring buffer shared with the kernel. watchers can be canceled
+ *    regardless of whether the fd has been closed. no problems with fork.
+ *    ok, the ring buffer is 200% undocumented (there isn't even a
+ *    header file), but otherwise, it's pure bliss!
+ * b) ok, watchers are one-shot, so you have to re-arm active ones
+ *    on every iteration. so much for syscall-less event handling,
+ *    but at least these re-arms can be batched, no big deal, right?
+ * c) well, linux as usual: the documentation lies to you: io_submit
+ *    sometimes returns EINVAL because the kernel doesn't feel like
+ *    handling your poll mask - ttys can be polled for POLLOUT,
+ *    POLLOUT|POLLIN, but polling for POLLIN fails. just great,
+ *    so we have to fall back to something else (hello, epoll),
+ *    but at least the fallback can be slow, because these are
+ *    exceptional cases, right?
+ * d) hmm, you have to tell the kernel the maximum number of watchers
+ *    you want to queue when initialising the aio context. but of
+ *    course the real limit is magically calculated in the kernel, and
+ *    is often higher then we asked for. so we just have to destroy
+ *    the aio context and re-create it a bit larger if we hit the limit.
+ *    (starts to remind you of epoll? well, it's a bit more deterministic
+ *    and less gambling, but still ugly as hell).
+ * e) that's when you find out you can also hit an arbitrary system-wide
+ *    limit. or the kernel simply doesn't want to handle your watchers.
+ *    what the fuck do we do then? you guessed it, in the middle
+ *    of event handling we have to switch to 100% epoll polling. and
+ *    that better is as fast as normal epoll polling, so you practically
+ *    have to use the normal epoll backend with all its quirks.
+ * f) end result of this train wreck: it inherits all the disadvantages
+ *    from epoll, while adding a number on its own. why even bother to use
+ *    it? because if conditions are right and your fds are supported and you
+ *    don't hit a limit, this backend is actually faster, doesn't gamble with
+ *    your fds, batches watchers and events and doesn't require costly state
+ *    recreates. well, until it does.
+ * g) all of this makes this backend use almost twice as much code as epoll.
+ *    which in turn uses twice as much code as poll. and that#s not counting
+ *    the fact that this backend also depends on the epoll backend, making
+ *    it three times as much code as poll, or kqueue.
+ * h) bleah. why can't linux just do kqueue. sure kqueue is ugly, but by now
+ *    it's clear that whatever linux comes up with is far, far, far worse.
+ */
+
+#include <sys/time.h> /* actually linux/time.h, but we must assume they are compatible */
+#include <poll.h>
+#include <linux/aio_abi.h>
+
+/*****************************************************************************/
+/* syscall wrapdadoop - this section has the raw api/abi definitions */
+
+#include <sys/syscall.h> /* no glibc wrappers */
+
+/* aio_abi.h is not versioned in any way, so we cannot test for its existance */
+#define IOCB_CMD_POLL 5
+
+/* taken from linux/fs/aio.c. yup, that's a .c file.
+ * not only is this totally undocumented, not even the source code
+ * can tell you what the future semantics of compat_features and
+ * incompat_features are, or what header_length actually is for.
+ */
+#define AIO_RING_MAGIC                  0xa10a10a1
+#define EV_AIO_RING_INCOMPAT_FEATURES   0
+struct aio_ring
+{
+  unsigned id;    /* kernel internal index number */
+  unsigned nr;    /* number of io_events */
+  unsigned head;  /* Written to by userland or by kernel. */
+  unsigned tail;
+
+  unsigned magic;
+  unsigned compat_features;
+  unsigned incompat_features;
+  unsigned header_length;  /* size of aio_ring */
+
+  struct io_event io_events[0];
+};
+
+inline_size
+int
+evsys_io_setup (unsigned nr_events, aio_context_t *ctx_idp)
+{
+  return ev_syscall2 (SYS_io_setup, nr_events, ctx_idp);
+}
+
+inline_size
+int
+evsys_io_destroy (aio_context_t ctx_id)
+{
+  return ev_syscall1 (SYS_io_destroy, ctx_id);
+}
+
+inline_size
+int
+evsys_io_submit (aio_context_t ctx_id, long nr, struct iocb *cbp[])
+{
+  return ev_syscall3 (SYS_io_submit, ctx_id, nr, cbp);
+}
+
+inline_size
+int
+evsys_io_cancel (aio_context_t ctx_id, struct iocb *cbp, struct io_event *result)
+{
+  return ev_syscall3 (SYS_io_cancel, ctx_id, cbp, result);
+}
+
+inline_size
+int
+evsys_io_getevents (aio_context_t ctx_id, long min_nr, long nr, struct io_event *events, struct timespec *timeout)
+{
+  return ev_syscall5 (SYS_io_getevents, ctx_id, min_nr, nr, events, timeout);
+}
+
+/*****************************************************************************/
+/* actual backed implementation */
+
+ecb_cold
+static int
+linuxaio_nr_events (EV_P)
+{
+  /* we start with 16 iocbs and incraese from there
+   * that's tiny, but the kernel has a rather low system-wide
+   * limit that can be reached quickly, so let's be parsimonious
+   * with this resource.
+   * Rest assured, the kernel generously rounds up small and big numbers
+   * in different ways (but doesn't seem to charge you for it).
+   * The 15 here is because the kernel usually has a power of two as aio-max-nr,
+   * and this helps to take advantage of that limit.
+   */
+
+  /* we try to fill 4kB pages exactly.
+   * the ring buffer header is 32 bytes, every io event is 32 bytes.
+   * the kernel takes the io requests number, doubles it, adds 2
+   * and adds the ring buffer.
+   * the way we use this is by starting low, and then roughly doubling the
+   * size each time we hit a limit.
+   */
+
+  int requests   = 15 << linuxaio_iteration;
+  int one_page   =  (4096
+                    / sizeof (struct io_event)    ) / 2; /* how many fit into one page */
+  int first_page = ((4096 - sizeof (struct aio_ring))
+                    / sizeof (struct io_event) - 2) / 2; /* how many fit into the first page */
+
+  /* if everything fits into one page, use count exactly */
+  if (requests > first_page)
+    /* otherwise, round down to full pages and add the first page */
+    requests = requests / one_page * one_page + first_page;
+
+  return requests;
+}
+
+/* we use out own wrapper structure in case we ever want to do something "clever" */
+typedef struct aniocb
+{
+  struct iocb io;
+  /*int inuse;*/
+} *ANIOCBP;
+
+inline_size
+void
+linuxaio_array_needsize_iocbp (ANIOCBP *base, int offset, int count)
+{
+  while (count--)
+    {
+      /* TODO: quite the overhead to allocate every iocb separately, maybe use our own allocator? */
+      ANIOCBP iocb = (ANIOCBP)ev_malloc (sizeof (*iocb));
+
+      /* full zero initialise is probably not required at the moment, but
+       * this is not well documented, so we better do it.
+       */
+      memset (iocb, 0, sizeof (*iocb));
+
+      iocb->io.aio_lio_opcode = IOCB_CMD_POLL;
+      iocb->io.aio_fildes     = offset;
+
+      base [offset++] = iocb;
+    }
+}
+
+ecb_cold
+static void
+linuxaio_free_iocbp (EV_P)
+{
+  while (linuxaio_iocbpmax--)
+    ev_free (linuxaio_iocbps [linuxaio_iocbpmax]);
+
+  linuxaio_iocbpmax = 0; /* next resize will completely reallocate the array, at some overhead */
+}
+
+static void
+linuxaio_modify (EV_P_ int fd, int oev, int nev)
+{
+  array_needsize (ANIOCBP, linuxaio_iocbps, linuxaio_iocbpmax, fd + 1, linuxaio_array_needsize_iocbp);
+  ANIOCBP iocb = linuxaio_iocbps [fd];
+  ANFD *anfd = &anfds [fd];
+
+  if (ecb_expect_false (iocb->io.aio_reqprio < 0))
+    {
+      /* we handed this fd over to epoll, so undo this first */
+      /* we do it manually because the optimisations on epoll_modify won't do us any good */
+      epoll_ctl (backend_fd, EPOLL_CTL_DEL, fd, 0);
+      anfd->emask = 0;
+      iocb->io.aio_reqprio = 0;
+    }
+  else if (ecb_expect_false (iocb->io.aio_buf))
+    {
+      /* iocb active, so cancel it first before resubmit */
+      /* this assumes we only ever get one call per fd per loop iteration */
+      for (;;)
+        {
+          /* on all relevant kernels, io_cancel fails with EINPROGRESS on "success" */
+          if (ecb_expect_false (evsys_io_cancel (linuxaio_ctx, &iocb->io, (struct io_event *)0) == 0))
+            break;
+
+          if (ecb_expect_true (errno == EINPROGRESS))
+            break;
+
+          /* the EINPROGRESS test is for nicer error message. clumsy. */
+          if (errno != EINTR)
+            {
+              assert (("libev: linuxaio unexpected io_cancel failed", errno != EINTR && errno != EINPROGRESS));
+              break;
+            }
+       }
+
+      /* increment generation counter to avoid handling old events */
+      ++anfd->egen;
+    }
+
+  iocb->io.aio_buf = (nev & EV_READ  ? POLLIN  : 0)
+                   | (nev & EV_WRITE ? POLLOUT : 0);
+
+  if (nev)
+    {
+      iocb->io.aio_data = (uint32_t)fd | ((__u64)(uint32_t)anfd->egen << 32);
+
+      /* queue iocb up for io_submit */
+      /* this assumes we only ever get one call per fd per loop iteration */
+      ++linuxaio_submitcnt;
+      array_needsize (struct iocb *, linuxaio_submits, linuxaio_submitmax, linuxaio_submitcnt, array_needsize_noinit);
+      linuxaio_submits [linuxaio_submitcnt - 1] = &iocb->io;
+    }
+}
+
+static void
+linuxaio_epoll_cb (EV_P_ struct ev_io *w, int revents)
+{
+  epoll_poll (EV_A_ 0);
+}
+
+inline_speed
+void
+linuxaio_fd_rearm (EV_P_ int fd)
+{
+  anfds [fd].events = 0;
+  linuxaio_iocbps [fd]->io.aio_buf = 0;
+  fd_change (EV_A_ fd, EV_ANFD_REIFY);
+}
+
+static void
+linuxaio_parse_events (EV_P_ struct io_event *ev, int nr)
+{
+  while (nr)
+    {
+      int fd       = ev->data & 0xffffffff;
+      uint32_t gen = ev->data >> 32;
+      int res      = ev->res;
+
+      assert (("libev: iocb fd must be in-bounds", fd >= 0 && fd < anfdmax));
+
+      /* only accept events if generation counter matches */
+      if (ecb_expect_true (gen == (uint32_t)anfds [fd].egen))
+        {
+          /* feed events, we do not expect or handle POLLNVAL */
+          fd_event (
+            EV_A_
+            fd,
+            (res & (POLLOUT | POLLERR | POLLHUP) ? EV_WRITE : 0)
+            | (res & (POLLIN | POLLERR | POLLHUP) ? EV_READ : 0)
+          );
+
+          /* linux aio is oneshot: rearm fd. TODO: this does more work than strictly needed */
+          linuxaio_fd_rearm (EV_A_ fd);
+        }
+
+      --nr;
+      ++ev;
+    }
+}
+
+/* get any events from ring buffer, return true if any were handled */
+static int
+linuxaio_get_events_from_ring (EV_P)
+{
+  struct aio_ring *ring = (struct aio_ring *)linuxaio_ctx;
+  unsigned head, tail;
+
+  /* the kernel reads and writes both of these variables, */
+  /* as a C extension, we assume that volatile use here */
+  /* both makes reads atomic and once-only */
+  head = *(volatile unsigned *)&ring->head;
+  ECB_MEMORY_FENCE_ACQUIRE;
+  tail = *(volatile unsigned *)&ring->tail;
+
+  if (head == tail)
+    return 0;
+
+  /* parse all available events, but only once, to avoid starvation */
+  if (ecb_expect_true (tail > head)) /* normal case around */
+    linuxaio_parse_events (EV_A_ ring->io_events + head, tail - head);
+  else /* wrapped around */
+    {
+      linuxaio_parse_events (EV_A_ ring->io_events + head, ring->nr - head);
+      linuxaio_parse_events (EV_A_ ring->io_events, tail);
+    }
+
+  ECB_MEMORY_FENCE_RELEASE;
+  /* as an extension to C, we hope that the volatile will make this atomic and once-only */
+  *(volatile unsigned *)&ring->head = tail;
+
+  return 1;
+}
+
+inline_size
+int
+linuxaio_ringbuf_valid (EV_P)
+{
+  struct aio_ring *ring = (struct aio_ring *)linuxaio_ctx;
+
+  return ecb_expect_true (ring->magic == AIO_RING_MAGIC)
+                      && ring->incompat_features == EV_AIO_RING_INCOMPAT_FEATURES
+                      && ring->header_length == sizeof (struct aio_ring); /* TODO: or use it to find io_event[0]? */
+}
+
+/* read at least one event from kernel, or timeout */
+inline_size
+void
+linuxaio_get_events (EV_P_ ev_tstamp timeout)
+{
+  struct timespec ts;
+  struct io_event ioev[8]; /* 256 octet stack space */
+  int want = 1; /* how many events to request */
+  int ringbuf_valid = linuxaio_ringbuf_valid (EV_A);
+
+  if (ecb_expect_true (ringbuf_valid))
+    {
+      /* if the ring buffer has any events, we don't wait or call the kernel at all */
+      if (linuxaio_get_events_from_ring (EV_A))
+        return;
+
+      /* if the ring buffer is empty, and we don't have a timeout, then don't call the kernel */
+      if (!timeout)
+        return;
+    }
+  else
+    /* no ringbuffer, request slightly larger batch */
+    want = sizeof (ioev) / sizeof (ioev [0]);
+
+  /* no events, so wait for some
+   * for fairness reasons, we do this in a loop, to fetch all events
+   */
+  for (;;)
+    {
+      int res;
+
+      EV_RELEASE_CB;
+
+      EV_TS_SET (ts, timeout);
+      res = evsys_io_getevents (linuxaio_ctx, 1, want, ioev, &ts);
+
+      EV_ACQUIRE_CB;
+
+      if (res < 0)
+        if (errno == EINTR)
+          /* ignored, retry */;
+        else
+          ev_syserr ("(libev) linuxaio io_getevents");
+      else if (res)
+        {
+          /* at least one event available, handle them */
+          linuxaio_parse_events (EV_A_ ioev, res);
+
+          if (ecb_expect_true (ringbuf_valid))
+            {
+              /* if we have a ring buffer, handle any remaining events in it */
+              linuxaio_get_events_from_ring (EV_A);
+
+              /* at this point, we should have handled all outstanding events */
+              break;
+            }
+          else if (res < want)
+            /* otherwise, if there were fewere events than we wanted, we assume there are no more */
+            break;
+        }
+      else
+        break; /* no events from the kernel, we are done */
+
+      timeout = EV_TS_CONST (0.); /* only wait in the first iteration */
+    }
+}
+
+inline_size
+int
+linuxaio_io_setup (EV_P)
+{
+  linuxaio_ctx = 0;
+  return evsys_io_setup (linuxaio_nr_events (EV_A), &linuxaio_ctx);
+}
+
+static void
+linuxaio_poll (EV_P_ ev_tstamp timeout)
+{
+  int submitted;
+
+  /* first phase: submit new iocbs */
+
+  /* io_submit might return less than the requested number of iocbs */
+  /* this is, afaics, only because of errors, but we go by the book and use a loop, */
+  /* which allows us to pinpoint the erroneous iocb */
+  for (submitted = 0; submitted < linuxaio_submitcnt; )
+    {
+      int res = evsys_io_submit (linuxaio_ctx, linuxaio_submitcnt - submitted, linuxaio_submits + submitted);
+
+      if (ecb_expect_false (res < 0))
+        if (errno == EINVAL)
+          {
+            /* This happens for unsupported fds, officially, but in my testing,
+             * also randomly happens for supported fds. We fall back to good old
+             * poll() here, under the assumption that this is a very rare case.
+             * See https://lore.kernel.org/patchwork/patch/1047453/ to see
+             * discussion about such a case (ttys) where polling for POLLIN
+             * fails but POLLIN|POLLOUT works.
+             */
+            struct iocb *iocb = linuxaio_submits [submitted];
+            epoll_modify (EV_A_ iocb->aio_fildes, 0, anfds [iocb->aio_fildes].events);
+            iocb->aio_reqprio = -1; /* mark iocb as epoll */
+
+            res = 1; /* skip this iocb - another iocb, another chance */
+          }
+        else if (errno == EAGAIN)
+          {
+            /* This happens when the ring buffer is full, or some other shit we
+             * don't know and isn't documented. Most likely because we have too
+             * many requests and linux aio can't be assed to handle them.
+             * In this case, we try to allocate a larger ring buffer, freeing
+             * ours first. This might fail, in which case we have to fall back to 100%
+             * epoll.
+             * God, how I hate linux not getting its act together. Ever.
+             */
+            evsys_io_destroy (linuxaio_ctx);
+            linuxaio_submitcnt = 0;
+
+            /* rearm all fds with active iocbs */
+            {
+              int fd;
+	      for (fd = 0; fd < linuxaio_iocbpmax; ++fd)
+                if (linuxaio_iocbps [fd]->io.aio_buf)
+                  linuxaio_fd_rearm (EV_A_ fd);
+            }
+
+            ++linuxaio_iteration;
+            if (linuxaio_io_setup (EV_A) < 0)
+              {
+                /* TODO: rearm all and recreate epoll backend from scratch */
+                /* TODO: might be more prudent? */
+
+                /* to bad, we can't get a new aio context, go 100% epoll */
+                linuxaio_free_iocbp (EV_A);
+                ev_io_stop (EV_A_ &linuxaio_epoll_w);
+                ev_ref (EV_A);
+                linuxaio_ctx = 0;
+
+                backend        = EVBACKEND_EPOLL;
+                backend_modify = epoll_modify;
+                backend_poll   = epoll_poll;
+              }
+
+            timeout = EV_TS_CONST (0.);
+            /* it's easiest to handle this mess in another iteration */
+            return;
+          }
+        else if (errno == EBADF)
+          {
+            assert (("libev: event loop rejected bad fd", errno != EBADF));
+            fd_kill (EV_A_ linuxaio_submits [submitted]->aio_fildes);
+
+            res = 1; /* skip this iocb */
+          }
+        else if (errno == EINTR) /* not seen in reality, not documented */
+          res = 0; /* silently ignore and retry */
+        else
+          {
+            ev_syserr ("(libev) linuxaio io_submit");
+            res = 0;
+          }
+
+      submitted += res;
+    }
+
+  linuxaio_submitcnt = 0;
+
+  /* second phase: fetch and parse events */
+
+  linuxaio_get_events (EV_A_ timeout);
+}
+
+inline_size
+int
+linuxaio_init (EV_P_ int flags)
+{
+  /* would be great to have a nice test for IOCB_CMD_POLL instead */
+  /* also: test some semi-common fd types, such as files and ttys in recommended_backends */
+  /* 4.18 introduced IOCB_CMD_POLL, 4.19 made epoll work, and we need that */
+  if (ev_linux_version () < 0x041300)
+    return 0;
+
+  if (!epoll_init (EV_A_ 0))
+    return 0;
+
+  linuxaio_iteration = 0;
+
+  if (linuxaio_io_setup (EV_A) < 0)
+    {
+      epoll_destroy (EV_A);
+      return 0;
+    }
+
+  ev_io_init  (&linuxaio_epoll_w, linuxaio_epoll_cb, backend_fd, EV_READ);
+  ev_set_priority (&linuxaio_epoll_w, EV_MAXPRI);
+  ev_io_start (EV_A_ &linuxaio_epoll_w);
+  ev_unref (EV_A); /* watcher should not keep loop alive */
+
+  backend_modify = linuxaio_modify;
+  backend_poll   = linuxaio_poll;
+
+  linuxaio_iocbpmax = 0;
+  linuxaio_iocbps = 0;
+
+  linuxaio_submits = 0;
+  linuxaio_submitmax = 0;
+  linuxaio_submitcnt = 0;
+
+  return EVBACKEND_LINUXAIO;
+}
+
+inline_size
+void
+linuxaio_destroy (EV_P)
+{
+  epoll_destroy (EV_A);
+  linuxaio_free_iocbp (EV_A);
+  evsys_io_destroy (linuxaio_ctx); /* fails in child, aio context is destroyed */
+}
+
+ecb_cold
+static void
+linuxaio_fork (EV_P)
+{
+  linuxaio_submitcnt = 0; /* all pointers were invalidated */
+  linuxaio_free_iocbp (EV_A); /* this frees all iocbs, which is very heavy-handed */
+  evsys_io_destroy (linuxaio_ctx); /* fails in child, aio context is destroyed */
+
+  linuxaio_iteration = 0; /* we start over in the child */
+
+  while (linuxaio_io_setup (EV_A) < 0)
+    ev_syserr ("(libev) linuxaio io_setup");
+
+  /* forking epoll should also effectively unregister all fds from the backend */
+  epoll_fork (EV_A);
+  /* epoll_fork already did this. hopefully */
+  /*fd_rearm_all (EV_A);*/
+
+  ev_io_stop  (EV_A_ &linuxaio_epoll_w);
+  ev_io_set   (EV_A_ &linuxaio_epoll_w, backend_fd, EV_READ);
+  ev_io_start (EV_A_ &linuxaio_epoll_w);
+}
+
diff --git a/libev/ev_poll.c b/libev/ev_poll.c
index bd742b0..e5508dd 100644
--- a/libev/ev_poll.c
+++ b/libev/ev_poll.c
@@ -1,7 +1,7 @@
 /*
  * libev poll fd activity backend
  *
- * Copyright (c) 2007,2008,2009,2010,2011 Marc Alexander Lehmann <libev@schmorp.de>
+ * Copyright (c) 2007,2008,2009,2010,2011,2016,2019 Marc Alexander Lehmann <libev@schmorp.de>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modifica-
@@ -41,10 +41,12 @@
 
 inline_size
 void
-pollidx_init (int *base, int count)
+array_needsize_pollidx (int *base, int offset, int count)
 {
-  /* consider using memset (.., -1, ...), which is practically guaranteed
-   * to work on all systems implementing poll */
+  /* using memset (.., -1, ...) is tempting, we we try
+   * to be ultraportable
+   */
+  base += offset;
   while (count--)
     *base++ = -1;
 }
@@ -57,14 +59,14 @@ poll_modify (EV_P_ int fd, int oev, int nev)
   if (oev == nev)
     return;
 
-  array_needsize (int, pollidxs, pollidxmax, fd + 1, pollidx_init);
+  array_needsize (int, pollidxs, pollidxmax, fd + 1, array_needsize_pollidx);
 
   idx = pollidxs [fd];
 
   if (idx < 0) /* need to allocate a new pollfd */
     {
       pollidxs [fd] = idx = pollcnt++;
-      array_needsize (struct pollfd, polls, pollmax, pollcnt, EMPTY2);
+      array_needsize (struct pollfd, polls, pollmax, pollcnt, array_needsize_noinit);
       polls [idx].fd = fd;
     }
 
@@ -78,7 +80,7 @@ poll_modify (EV_P_ int fd, int oev, int nev)
     {
       pollidxs [fd] = -1;
 
-      if (expect_true (idx < --pollcnt))
+      if (ecb_expect_true (idx < --pollcnt))
         {
           polls [idx] = polls [pollcnt];
           pollidxs [polls [idx].fd] = idx;
@@ -93,10 +95,10 @@ poll_poll (EV_P_ ev_tstamp timeout)
   int res;
   
   EV_RELEASE_CB;
-  res = poll (polls, pollcnt, timeout * 1e3);
+  res = poll (polls, pollcnt, EV_TS_TO_MSEC (timeout));
   EV_ACQUIRE_CB;
 
-  if (expect_false (res < 0))
+  if (ecb_expect_false (res < 0))
     {
       if (errno == EBADF)
         fd_ebadf (EV_A);
@@ -108,14 +110,17 @@ poll_poll (EV_P_ ev_tstamp timeout)
   else
     for (p = polls; res; ++p)
       {
-        assert (("libev: poll() returned illegal result, broken BSD kernel?", p < polls + pollcnt));
+        assert (("libev: poll returned illegal result, broken BSD kernel?", p < polls + pollcnt));
 
-        if (expect_false (p->revents)) /* this expect is debatable */
+        if (ecb_expect_false (p->revents)) /* this expect is debatable */
           {
             --res;
 
-            if (expect_false (p->revents & POLLNVAL))
-              fd_kill (EV_A_ p->fd);
+            if (ecb_expect_false (p->revents & POLLNVAL))
+              {
+                assert (("libev: poll found invalid fd in poll set", 0));
+                fd_kill (EV_A_ p->fd);
+              }
             else
               fd_event (
                 EV_A_
@@ -131,7 +136,7 @@ inline_size
 int
 poll_init (EV_P_ int flags)
 {
-  backend_mintime = 1e-3;
+  backend_mintime = EV_TS_CONST (1e-3);
   backend_modify  = poll_modify;
   backend_poll    = poll_poll;
 
diff --git a/libev/ev_port.c b/libev/ev_port.c
index c7b0b70..f4cd9d9 100644
--- a/libev/ev_port.c
+++ b/libev/ev_port.c
@@ -1,7 +1,7 @@
 /*
  * libev solaris event port backend
  *
- * Copyright (c) 2007,2008,2009,2010,2011 Marc Alexander Lehmann <libev@schmorp.de>
+ * Copyright (c) 2007,2008,2009,2010,2011,2019 Marc Alexander Lehmann <libev@schmorp.de>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modifica-
@@ -69,7 +69,10 @@ port_associate_and_check (EV_P_ int fd, int ev)
   )
     {
       if (errno == EBADFD)
-        fd_kill (EV_A_ fd);
+        {
+          assert (("libev: port_associate found invalid fd", errno != EBADFD));
+          fd_kill (EV_A_ fd);
+        }
       else
         ev_syserr ("(libev) port_associate");
     }
@@ -129,7 +132,7 @@ port_poll (EV_P_ ev_tstamp timeout)
         }
     }
 
-  if (expect_false (nget == port_eventmax))
+  if (ecb_expect_false (nget == port_eventmax))
     {
       ev_free (port_events);
       port_eventmax = array_nextsize (sizeof (port_event_t), port_eventmax, port_eventmax + 1);
@@ -151,11 +154,11 @@ port_init (EV_P_ int flags)
 
   /* if my reading of the opensolaris kernel sources are correct, then
    * opensolaris does something very stupid: it checks if the time has already
-   * elapsed and doesn't round up if that is the case,m otherwise it DOES round
+   * elapsed and doesn't round up if that is the case, otherwise it DOES round
    * up. Since we can't know what the case is, we need to guess by using a
    * "large enough" timeout. Normally, 1e-9 would be correct.
    */
-  backend_mintime = 1e-3; /* needed to compensate for port_getn returning early */
+  backend_mintime = EV_TS_CONST (1e-3); /* needed to compensate for port_getn returning early */
   backend_modify  = port_modify;
   backend_poll    = port_poll;
 
diff --git a/libev/ev_select.c b/libev/ev_select.c
index ed1fc7a..b862c81 100644
--- a/libev/ev_select.c
+++ b/libev/ev_select.c
@@ -108,7 +108,7 @@ select_modify (EV_P_ int fd, int oev, int nev)
     int     word = fd / NFDBITS;
     fd_mask mask = 1UL << (fd % NFDBITS);
 
-    if (expect_false (vec_max <= word))
+    if (ecb_expect_false (vec_max <= word))
       {
         int new_max = word + 1;
 
@@ -171,7 +171,7 @@ select_poll (EV_P_ ev_tstamp timeout)
 #endif
   EV_ACQUIRE_CB;
 
-  if (expect_false (res < 0))
+  if (ecb_expect_false (res < 0))
     {
       #if EV_SELECT_IS_WINSOCKET
       errno = WSAGetLastError ();
@@ -197,7 +197,7 @@ select_poll (EV_P_ ev_tstamp timeout)
         {
           if (timeout)
             {
-              unsigned long ms = timeout * 1e3;
+              unsigned long ms = EV_TS_TO_MSEC (timeout);
               Sleep (ms ? ms : 1);
             }
 
@@ -236,7 +236,7 @@ select_poll (EV_P_ ev_tstamp timeout)
           if (FD_ISSET (handle, (fd_set *)vec_eo)) events |= EV_WRITE;
           #endif
 
-          if (expect_true (events))
+          if (ecb_expect_true (events))
             fd_event (EV_A_ fd, events);
         }
   }
@@ -262,7 +262,7 @@ select_poll (EV_P_ ev_tstamp timeout)
               events |= word_r & mask ? EV_READ  : 0;
               events |= word_w & mask ? EV_WRITE : 0;
 
-              if (expect_true (events))
+              if (ecb_expect_true (events))
                 fd_event (EV_A_ word * NFDBITS + bit, events);
             }
       }
@@ -275,7 +275,7 @@ inline_size
 int
 select_init (EV_P_ int flags)
 {
-  backend_mintime = 1e-6;
+  backend_mintime = EV_TS_CONST (1e-6);
   backend_modify  = select_modify;
   backend_poll    = select_poll;
 
diff --git a/libev/ev_vars.h b/libev/ev_vars.h
index 04d4db1..fb0c583 100644
--- a/libev/ev_vars.h
+++ b/libev/ev_vars.h
@@ -1,7 +1,7 @@
 /*
  * loop member variable declarations
  *
- * Copyright (c) 2007,2008,2009,2010,2011,2012,2013 Marc Alexander Lehmann <libev@schmorp.de>
+ * Copyright (c) 2007,2008,2009,2010,2011,2012,2013,2019 Marc Alexander Lehmann <libev@schmorp.de>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modifica-
@@ -107,6 +107,46 @@ VARx(int, epoll_epermcnt)
 VARx(int, epoll_epermmax)
 #endif
 
+#if EV_USE_LINUXAIO || EV_GENWRAP
+VARx(aio_context_t, linuxaio_ctx)
+VARx(int, linuxaio_iteration)
+VARx(struct aniocb **, linuxaio_iocbps)
+VARx(int, linuxaio_iocbpmax)
+VARx(struct iocb **, linuxaio_submits)
+VARx(int, linuxaio_submitcnt)
+VARx(int, linuxaio_submitmax)
+VARx(ev_io, linuxaio_epoll_w)
+#endif
+
+#if EV_USE_IOURING || EV_GENWRAP
+VARx(int, iouring_fd)
+VARx(unsigned, iouring_to_submit);
+VARx(int, iouring_entries)
+VARx(int, iouring_max_entries)
+VARx(void *, iouring_sq_ring)
+VARx(void *, iouring_cq_ring)
+VARx(void *, iouring_sqes)
+VARx(uint32_t, iouring_sq_ring_size)
+VARx(uint32_t, iouring_cq_ring_size)
+VARx(uint32_t, iouring_sqes_size)
+VARx(uint32_t, iouring_sq_head)
+VARx(uint32_t, iouring_sq_tail)
+VARx(uint32_t, iouring_sq_ring_mask)
+VARx(uint32_t, iouring_sq_ring_entries)
+VARx(uint32_t, iouring_sq_flags)
+VARx(uint32_t, iouring_sq_dropped)
+VARx(uint32_t, iouring_sq_array)
+VARx(uint32_t, iouring_cq_head)
+VARx(uint32_t, iouring_cq_tail)
+VARx(uint32_t, iouring_cq_ring_mask)
+VARx(uint32_t, iouring_cq_ring_entries)
+VARx(uint32_t, iouring_cq_overflow)
+VARx(uint32_t, iouring_cq_cqes)
+VARx(ev_tstamp, iouring_tfd_to)
+VARx(int, iouring_tfd)
+VARx(ev_io, iouring_tfd_w)
+#endif
+
 #if EV_USE_KQUEUE || EV_GENWRAP
 VARx(pid_t, kqueue_fd_pid)
 VARx(struct kevent *, kqueue_changes)
@@ -187,6 +227,11 @@ VARx(ev_io, sigfd_w)
 VARx(sigset_t, sigfd_set)
 #endif
 
+#if EV_USE_TIMERFD || EV_GENWRAP
+VARx(int, timerfd) /* timerfd for time jump detection */
+VARx(ev_io, timerfd_w)
+#endif
+
 VARx(unsigned int, origflags) /* original loop flags */
 
 #if EV_FEATURE_API || EV_GENWRAP
@@ -195,8 +240,8 @@ VARx(unsigned int, loop_depth) /* #ev_run enters - #ev_run leaves */
 
 VARx(void *, userdata)
 /* C++ doesn't support the ev_loop_callback typedef here. stinks. */
-VAR (release_cb, void (*release_cb)(EV_P) EV_THROW)
-VAR (acquire_cb, void (*acquire_cb)(EV_P) EV_THROW)
+VAR (release_cb, void (*release_cb)(EV_P) EV_NOEXCEPT)
+VAR (acquire_cb, void (*acquire_cb)(EV_P) EV_NOEXCEPT)
 VAR (invoke_cb , ev_loop_callback invoke_cb)
 #endif
 
diff --git a/libev/ev_win32.c b/libev/ev_win32.c
index fd67135..cc38812 100644
--- a/libev/ev_win32.c
+++ b/libev/ev_win32.c
@@ -64,7 +64,11 @@ ev_pipe (int filedes [2])
   struct sockaddr_in adr2;
   int adr2_size = sizeof (adr2);
   SOCKET listener;
+#if EV_SELECT_IS_WINSOCKET
+  SOCKET sock [2] = { INVALID_SOCKET, INVALID_SOCKET };
+#else
   SOCKET sock [2] = { -1, -1 };
+#endif
 
   if ((listener = ev_tcp_socket ()) == INVALID_SOCKET)
     return -1;
@@ -88,9 +92,11 @@ ev_pipe (int filedes [2])
   if (connect (sock [0], (struct sockaddr *)&addr, addr_size))
     goto fail;
 
-  /* TODO: returns INVALID_SOCKET on winsock accept, not < 0. fix it */
-  /* when convenient, probably by just removing error checking altogether? */
+#if EV_SELECT_IS_WINSOCKET
+  if ((sock [1] = accept (listener, 0, 0)) == INVALID_SOCKET)
+#else
   if ((sock [1] = accept (listener, 0, 0)) < 0)
+#endif
     goto fail;
 
   /* windows vista returns fantasy port numbers for sockets:
@@ -154,8 +160,8 @@ ev_time (void)
   ui.u.LowPart  = ft.dwLowDateTime;
   ui.u.HighPart = ft.dwHighDateTime;
 
-  /* msvc cannot convert ulonglong to double... yes, it is that sucky */
-  return (LONGLONG)(ui.QuadPart - 116444736000000000) * 1e-7;
+  /* also, msvc cannot convert ulonglong to double... yes, it is that sucky */
+  return EV_TS_FROM_USEC (((LONGLONG)(ui.QuadPart - 116444736000000000) * 1e-1));
 }
 
 #endif
diff --git a/libev/ev_wrap.h b/libev/ev_wrap.h
index ad989ea..45d793c 100644
--- a/libev/ev_wrap.h
+++ b/libev/ev_wrap.h
@@ -44,12 +44,46 @@
 #define invoke_cb ((loop)->invoke_cb)
 #define io_blocktime ((loop)->io_blocktime)
 #define iocp ((loop)->iocp)
+#define iouring_cq_cqes ((loop)->iouring_cq_cqes)
+#define iouring_cq_head ((loop)->iouring_cq_head)
+#define iouring_cq_overflow ((loop)->iouring_cq_overflow)
+#define iouring_cq_ring ((loop)->iouring_cq_ring)
+#define iouring_cq_ring_entries ((loop)->iouring_cq_ring_entries)
+#define iouring_cq_ring_mask ((loop)->iouring_cq_ring_mask)
+#define iouring_cq_ring_size ((loop)->iouring_cq_ring_size)
+#define iouring_cq_tail ((loop)->iouring_cq_tail)
+#define iouring_entries ((loop)->iouring_entries)
+#define iouring_fd ((loop)->iouring_fd)
+#define iouring_max_entries ((loop)->iouring_max_entries)
+#define iouring_sq_array ((loop)->iouring_sq_array)
+#define iouring_sq_dropped ((loop)->iouring_sq_dropped)
+#define iouring_sq_flags ((loop)->iouring_sq_flags)
+#define iouring_sq_head ((loop)->iouring_sq_head)
+#define iouring_sq_ring ((loop)->iouring_sq_ring)
+#define iouring_sq_ring_entries ((loop)->iouring_sq_ring_entries)
+#define iouring_sq_ring_mask ((loop)->iouring_sq_ring_mask)
+#define iouring_sq_ring_size ((loop)->iouring_sq_ring_size)
+#define iouring_sq_tail ((loop)->iouring_sq_tail)
+#define iouring_sqes ((loop)->iouring_sqes)
+#define iouring_sqes_size ((loop)->iouring_sqes_size)
+#define iouring_tfd ((loop)->iouring_tfd)
+#define iouring_tfd_to ((loop)->iouring_tfd_to)
+#define iouring_tfd_w ((loop)->iouring_tfd_w)
+#define iouring_to_submit ((loop)->iouring_to_submit)
 #define kqueue_changecnt ((loop)->kqueue_changecnt)
 #define kqueue_changemax ((loop)->kqueue_changemax)
 #define kqueue_changes ((loop)->kqueue_changes)
 #define kqueue_eventmax ((loop)->kqueue_eventmax)
 #define kqueue_events ((loop)->kqueue_events)
 #define kqueue_fd_pid ((loop)->kqueue_fd_pid)
+#define linuxaio_ctx ((loop)->linuxaio_ctx)
+#define linuxaio_epoll_w ((loop)->linuxaio_epoll_w)
+#define linuxaio_iocbpmax ((loop)->linuxaio_iocbpmax)
+#define linuxaio_iocbps ((loop)->linuxaio_iocbps)
+#define linuxaio_iteration ((loop)->linuxaio_iteration)
+#define linuxaio_submitcnt ((loop)->linuxaio_submitcnt)
+#define linuxaio_submitmax ((loop)->linuxaio_submitmax)
+#define linuxaio_submits ((loop)->linuxaio_submits)
 #define loop_count ((loop)->loop_count)
 #define loop_depth ((loop)->loop_depth)
 #define loop_done ((loop)->loop_done)
@@ -89,6 +123,8 @@
 #define sigfd_w ((loop)->sigfd_w)
 #define timeout_blocktime ((loop)->timeout_blocktime)
 #define timercnt ((loop)->timercnt)
+#define timerfd ((loop)->timerfd)
+#define timerfd_w ((loop)->timerfd_w)
 #define timermax ((loop)->timermax)
 #define timers ((loop)->timers)
 #define userdata ((loop)->userdata)
@@ -143,12 +179,46 @@
 #undef invoke_cb
 #undef io_blocktime
 #undef iocp
+#undef iouring_cq_cqes
+#undef iouring_cq_head
+#undef iouring_cq_overflow
+#undef iouring_cq_ring
+#undef iouring_cq_ring_entries
+#undef iouring_cq_ring_mask
+#undef iouring_cq_ring_size
+#undef iouring_cq_tail
+#undef iouring_entries
+#undef iouring_fd
+#undef iouring_max_entries
+#undef iouring_sq_array
+#undef iouring_sq_dropped
+#undef iouring_sq_flags
+#undef iouring_sq_head
+#undef iouring_sq_ring
+#undef iouring_sq_ring_entries
+#undef iouring_sq_ring_mask
+#undef iouring_sq_ring_size
+#undef iouring_sq_tail
+#undef iouring_sqes
+#undef iouring_sqes_size
+#undef iouring_tfd
+#undef iouring_tfd_to
+#undef iouring_tfd_w
+#undef iouring_to_submit
 #undef kqueue_changecnt
 #undef kqueue_changemax
 #undef kqueue_changes
 #undef kqueue_eventmax
 #undef kqueue_events
 #undef kqueue_fd_pid
+#undef linuxaio_ctx
+#undef linuxaio_epoll_w
+#undef linuxaio_iocbpmax
+#undef linuxaio_iocbps
+#undef linuxaio_iteration
+#undef linuxaio_submitcnt
+#undef linuxaio_submitmax
+#undef linuxaio_submits
 #undef loop_count
 #undef loop_depth
 #undef loop_done
@@ -188,6 +258,8 @@
 #undef sigfd_w
 #undef timeout_blocktime
 #undef timercnt
+#undef timerfd
+#undef timerfd_w
 #undef timermax
 #undef timers
 #undef userdata
diff --git a/libev/event_compat.h b/libev/event_compat.h
deleted file mode 100644
index c62802c..0000000
--- a/libev/event_compat.h
+++ /dev/null
@@ -1,226 +0,0 @@
-/*
- * Copyright (c) 2000-2004 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2008      Marc Alexander Lehmann <libev@schmorp.de>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifdef _WIN32
-# define WIN32_LEAN_AND_MEAN
-# include <windows.h>
-# undef WIN32_LEAN_AND_MEAN
-typedef unsigned char u_char;
-typedef unsigned short u_short;
-#else
-# include <sys/types.h>
-# include <sys/time.h>
-# include <inttypes.h>
-#endif
-
-#include <stdarg.h>
-
-/* Fix so that ppl dont have to run with <sys/queue.h> */
-#ifndef TAILQ_ENTRY
-#define _EVENT_DEFINED_TQENTRY
-#define TAILQ_ENTRY(type)						\
-struct {								\
-	struct type *tqe_next;	/* next element */			\
-	struct type **tqe_prev;	/* address of previous next element */	\
-}
-#endif /* !TAILQ_ENTRY */
-#ifndef RB_ENTRY
-#define _EVENT_DEFINED_RBENTRY
-#define RB_ENTRY(type)							\
-struct {								\
-	struct type *rbe_left;		/* left element */		\
-	struct type *rbe_right;		/* right element */		\
-	struct type *rbe_parent;	/* parent element */		\
-	int rbe_color;			/* node color */		\
-}
-#endif /* !RB_ENTRY */
-
-/*
- * Key-Value pairs.  Can be used for HTTP headers but also for
- * query argument parsing.
- */
-struct evkeyval {
-	TAILQ_ENTRY(evkeyval) next;
-
-	char *key;
-	char *value;
-};
-
-#ifdef _EVENT_DEFINED_TQENTRY
-#undef TAILQ_ENTRY
-struct event_list;
-struct evkeyvalq;
-#undef _EVENT_DEFINED_TQENTRY
-#else
-TAILQ_HEAD (event_list, event);
-TAILQ_HEAD (evkeyvalq, evkeyval);
-#endif /* _EVENT_DEFINED_TQENTRY */
-#ifdef _EVENT_DEFINED_RBENTRY
-#undef RB_ENTRY
-#undef _EVENT_DEFINED_RBENTRY
-#endif /* _EVENT_DEFINED_RBENTRY */
-
-struct eventop {
-	char *name;
-	void *(*init)(struct event_base *);
-	int (*add)(void *, struct event *);
-	int (*del)(void *, struct event *);
-	int (*recalc)(struct event_base *, void *, int);
-	int (*dispatch)(struct event_base *, void *, struct timeval *);
-	void (*dealloc)(struct event_base *, void *);
-};
-
-/* These functions deal with buffering input and output */
-
-struct evbuffer {
-	u_char *buffer;
-	u_char *orig_buffer;
-
-	size_t misalign;
-	size_t totallen;
-	size_t off;
-
-	void (*cb)(struct evbuffer *, size_t, size_t, void *);
-	void *cbarg;
-};
-
-/* Just for error reporting - use other constants otherwise */
-#define EVBUFFER_READ		0x01
-#define EVBUFFER_WRITE		0x02
-#define EVBUFFER_EOF		0x10
-#define EVBUFFER_ERROR		0x20
-#define EVBUFFER_TIMEOUT	0x40
-
-struct bufferevent;
-typedef void (*evbuffercb)(struct bufferevent *, void *);
-typedef void (*everrorcb)(struct bufferevent *, short what, void *);
-
-struct event_watermark {
-	size_t low;
-	size_t high;
-};
-
-struct bufferevent {
-	struct event ev_read;
-	struct event ev_write;
-
-	struct evbuffer *input;
-	struct evbuffer *output;
-
-	struct event_watermark wm_read;
-	struct event_watermark wm_write;
-
-	evbuffercb readcb;
-	evbuffercb writecb;
-	everrorcb errorcb;
-	void *cbarg;
-
-	int timeout_read;	/* in seconds */
-	int timeout_write;	/* in seconds */
-
-	short enabled;	/* events that are currently enabled */
-};
-
-struct bufferevent *bufferevent_new(int fd,
-    evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg);
-int bufferevent_base_set(struct event_base *base, struct bufferevent *bufev);
-int bufferevent_priority_set(struct bufferevent *bufev, int pri);
-void bufferevent_free(struct bufferevent *bufev);
-int bufferevent_write(struct bufferevent *bufev, const void *data, size_t size);
-int bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *buf);
-size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);
-int bufferevent_enable(struct bufferevent *bufev, short event);
-int bufferevent_disable(struct bufferevent *bufev, short event);
-void bufferevent_settimeout(struct bufferevent *bufev,
-    int timeout_read, int timeout_write);
-
-#define EVBUFFER_LENGTH(x)	(x)->off
-#define EVBUFFER_DATA(x)	(x)->buffer
-#define EVBUFFER_INPUT(x)	(x)->input
-#define EVBUFFER_OUTPUT(x)	(x)->output
-
-struct evbuffer *evbuffer_new(void);
-void evbuffer_free(struct evbuffer *);
-int evbuffer_expand(struct evbuffer *, size_t);
-int evbuffer_add(struct evbuffer *, const void *, size_t);
-int evbuffer_remove(struct evbuffer *, void *, size_t);
-char *evbuffer_readline(struct evbuffer *);
-int evbuffer_add_buffer(struct evbuffer *, struct evbuffer *);
-int evbuffer_add_printf(struct evbuffer *, const char *fmt, ...);
-int evbuffer_add_vprintf(struct evbuffer *, const char *fmt, va_list ap);
-void evbuffer_drain(struct evbuffer *, size_t);
-int evbuffer_write(struct evbuffer *, int);
-int evbuffer_read(struct evbuffer *, int, int);
-u_char *evbuffer_find(struct evbuffer *, const u_char *, size_t);
-void evbuffer_setcb(struct evbuffer *, void (*)(struct evbuffer *, size_t, size_t, void *), void *);
-
-/*
- * Marshaling tagged data - We assume that all tags are inserted in their
- * numeric order - so that unknown tags will always be higher than the
- * known ones - and we can just ignore the end of an event buffer.
- */
-
-void evtag_init(void);
-
-void evtag_marshal(struct evbuffer *evbuf, uint32_t tag, const void *data,
-    uint32_t len);
-
-void encode_int(struct evbuffer *evbuf, uint32_t number);
-
-void evtag_marshal_int(struct evbuffer *evbuf, uint32_t tag, uint32_t integer);
-
-void evtag_marshal_string(struct evbuffer *buf, uint32_t tag,
-    const char *string);
-
-void evtag_marshal_timeval(struct evbuffer *evbuf, uint32_t tag,
-    struct timeval *tv);
-
-int evtag_unmarshal(struct evbuffer *src, uint32_t *ptag, struct evbuffer *dst);
-int evtag_peek(struct evbuffer *evbuf, uint32_t *ptag);
-int evtag_peek_length(struct evbuffer *evbuf, uint32_t *plength);
-int evtag_payload_length(struct evbuffer *evbuf, uint32_t *plength);
-int evtag_consume(struct evbuffer *evbuf);
-
-int evtag_unmarshal_int(struct evbuffer *evbuf, uint32_t need_tag,
-    uint32_t *pinteger);
-
-int evtag_unmarshal_fixed(struct evbuffer *src, uint32_t need_tag, void *data,
-    size_t len);
-
-int evtag_unmarshal_string(struct evbuffer *evbuf, uint32_t need_tag,
-    char **pstring);
-
-int evtag_unmarshal_timeval(struct evbuffer *evbuf, uint32_t need_tag,
-    struct timeval *ptv);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/libev/import_libevent b/libev/import_libevent
deleted file mode 100755
index 80d6bc1..0000000
--- a/libev/import_libevent
+++ /dev/null
@@ -1,131 +0,0 @@
-#!/bin/sh
-
-LE=../libevent-1.4.3-stable
-
-if ! [ -e evbuffer.c ]; then
-   echo do not run this programm unless you know what you are doing
-   exit 1
-fi
-
-# this program combines libev and libevent into a single package
-
-cvs update -AdP libev
-rsync -avP libev/. . --exclude CVS
-
-rm -f configure.ac
-
-cp $LE/evdns.h .
-
-perl -i -pe 's%^/.libevent-include./%#include "event_compat.h"%' event.h
-
-perl -ne '
-   s/\s+char buf\[64\];/\tchar buf[96];/;
-   if (/#include "event.h"/) {
-      print "#ifndef EV_STANDALONE\n$_#endif\n";
-      next;
-   }
-   if (/#include "misc.h"/) {
-      print "#ifndef EV_STANDALONE\n$_#endif\n";
-      next;
-   }
-   if (/#include "(unistd.h|sys\/time.h)"/) {
-      print "#ifndef WIN32\n$_#endif\n";
-      next;
-   }
-   next if /#include "log.h"/;
-
-   print;
-' <$LE/evdns.c >evdns.c
-
-cp $LE/autogen.sh .
-cp $LE/epoll_sub.c .
-cp $LE/evbuffer.c .
-cp $LE/buffer.c .
-cp $LE/evhttp.h .
-cp $LE/evutil.h .
-cp $LE/evutil.c .
-cp $LE/event-config.h .
-cp $LE/event-internal.h .
-cp $LE/evrpc.h .
-cp $LE/evrpc.c .
-cp $LE/evrpc-internal.h .
-cp $LE/http.c .
-cp $LE/event_tagging.c .
-cp $LE/http-internal.h .
-cp $LE/strlcpy-internal.h .
-cp $LE/log.c .
-cp $LE/log.h .
-cp $LE/strlcpy.c .
-rsync -a $LE/WIN32* $LE/sample $LE/test $LE/compat . --del
-#rename 's/libevent/libev/' WIN32-Prj/lib*
-cp $LE/aclocal.m4 .
-#cp $LE/acconfig.h .
-cp $LE/config.h.in .
-cp $LE/event_rpcgen.py .
-cp $LE/*.3 .
-
-#perl -i -pe 's/libevent/libev/g' sample/Makefile.am
-#perl -i -pe 's/libevent/libev/g' test/Makefile.am
-
-perl -i -pe 's/#include <event.h>$/#include "event.h"/' test/*.c
-
-perl -i -ne '
-   next if /"event-internal.h"/;
-   s/base\d?->sig.ev_signal_added/0/;
-   s/base\d?->sig.ev_signal_pair\[0\]/-1/;
-   s/base->sig.evsignal_caught/0/;
-   next if /^\ttest_signal_(dealloc|pipeloss|switchbase|assert|restore)\(\)/;
-   next if /^\ttest_simplesignal\(\)/; # non-default-loop
-   next if /^\ttest_immediatesignal\(\)/; # non-default-loop
-   next if /test_priorities\(\d\)/;
-   print;
-' test/regress.c
-
-perl -ne '
-   s/\bmin_heap.h\b//g;
-   s/\bsignal.c\b//g;
-   s/\bevport.c\b//g;
-   s/\bkqueue.c\b//g;
-   s/\bdevpoll.c\b//g;
-   s/\brtsig.c\b//g;
-   s/\bselect.c\b//g;
-   s/\bpoll.c\b//g;
-   s/\bepoll.c\b//g;
-   s/\bepoll_sub.c\b//g;
-   s/\bevent-internal.h\b//g;
-   s/\bevsignal.h\b//g;
-   s/^(man_MANS\s*=)/$1 ev.3 /;
-   s/^(EXTRA_DIST\s*=)/$1 libev.m4 ev.h ev_vars.h ev_wrap.h event_compat.h ev++.h ev_epoll.c ev_select.c ev_poll.c ev_kqueue.c ev_port.c ev_win32.c ev.3 ev.pod /;
-   s/^(include_HEADERS\s*=)/$1 ev.h event_compat.h ev++.h /;
-   s/^(CORE_SRC\s*=)/$1 ev.c /;
-   s/^(SYS_LIBS\s*=)/$1 -lm /;
-   #s/libevent/libev/g;
-   print;
-' <$LE/Makefile.am >Makefile.am
-
-perl -ne '
-   #s/-Wall/-Wall -Wno-comment -Wunused-function -Wno-unused-value/;
-   s/-Wall//g;
-   #s/libevent/libev/g;
-   #VERSION
-   s/AM_INIT_AUTOMAKE\s*\(.*,(.*)\)/AM_INIT_AUTOMAKE(libevent-$1+libev,3.1)/;
-   s/AC_LIBOBJ\(select\)/: ;/g;
-   s/AC_LIBOBJ\(poll\)/: ;/g;
-   s/AC_LIBOBJ\(kqueue\)/: ;/g;
-   s/AC_LIBOBJ\(epoll\)/: ;/g;
-   s/AC_LIBOBJ\(devpoll\)/: ;/g;
-   s/AC_LIBOBJ\(evport\)/: ;/g;
-   s/AC_LIBOBJ\(signal\)/: ;/g;
-   s/AC_LIBOBJ\(rtsig\)/: ;/g;
-   print "m4_include([libev.m4])\n" if /^AC_OUTPUT/;
-   print;
-' <$LE/configure.in >configure.in
-
-aclocal-1.7
-automake-1.7 --add-missing
-autoconf
-autoheader
-libtoolize
-CC="ccache gcc" ./configure --prefix=/opt/libev --disable-shared "$@"
-
-
diff --git a/libev/libev.m4 b/libev/libev.m4
deleted file mode 100644
index 439fbde..0000000
--- a/libev/libev.m4
+++ /dev/null
@@ -1,42 +0,0 @@
-dnl this file is part of libev, do not make local modifications
-dnl http://software.schmorp.de/pkg/libev
-
-dnl libev support
-AC_CHECK_HEADERS(sys/inotify.h sys/epoll.h sys/event.h port.h poll.h sys/select.h sys/eventfd.h sys/signalfd.h)
- 
-AC_CHECK_FUNCS(inotify_init epoll_ctl kqueue port_create poll select eventfd signalfd)
- 
-AC_CHECK_FUNCS(clock_gettime, [], [
-   dnl on linux, try syscall wrapper first
-   if test $(uname) = Linux; then
-      AC_MSG_CHECKING(for clock_gettime syscall)
-      AC_LINK_IFELSE([AC_LANG_PROGRAM(
-                      [#include <unistd.h>
-                       #include <sys/syscall.h>
-                       #include <time.h>],
-                      [struct timespec ts; int status = syscall (SYS_clock_gettime, CLOCK_REALTIME, &ts)])],
-                     [ac_have_clock_syscall=1
-                      AC_DEFINE(HAVE_CLOCK_SYSCALL, 1, Define to 1 to use the syscall interface for clock_gettime)
-                      AC_MSG_RESULT(yes)],
-                     [AC_MSG_RESULT(no)])
-   fi
-   if test -z "$LIBEV_M4_AVOID_LIBRT" && test -z "$ac_have_clock_syscall"; then
-      AC_CHECK_LIB(rt, clock_gettime)
-      unset ac_cv_func_clock_gettime
-      AC_CHECK_FUNCS(clock_gettime)
-   fi
-])
-
-AC_CHECK_FUNCS(nanosleep, [], [
-   if test -z "$LIBEV_M4_AVOID_LIBRT"; then
-      AC_CHECK_LIB(rt, nanosleep)
-      unset ac_cv_func_nanosleep
-      AC_CHECK_FUNCS(nanosleep)
-   fi
-])
-
-if test -z "$LIBEV_M4_AVOID_LIBM"; then
-   LIBM=m
-fi
-AC_SEARCH_LIBS(floor, $LIBM, [AC_DEFINE(HAVE_FLOOR, 1, Define to 1 if the floor function is available)])
-
diff --git a/libev/update_ev_c b/libev/update_ev_c
deleted file mode 100755
index b55fd7f..0000000
--- a/libev/update_ev_c
+++ /dev/null
@@ -1,8 +0,0 @@
-#!/bin/sh -e
-
-(
-   sed -ne '1,\%/\* ECB.H BEGIN \*/%p' ev.c
-   cat ~/src/libecb/ecb.h
-   sed -ne '\%/\* ECB.H END \*/%,$p' ev.c
-) >ev.c~ && mv ev.c~ ev.c
-
diff --git a/libev/update_ev_wrap b/libev/update_ev_wrap
deleted file mode 100755
index 995ea0c..0000000
--- a/libev/update_ev_wrap
+++ /dev/null
@@ -1,19 +0,0 @@
-#!/bin/sh
-
-(
-   echo '#define VAR(name,decl) name'
-   echo '#define EV_GENWRAP 1'
-   cat ev_vars.h
-) | cc -E -o - - | perl -ne '
-   while (<>) {
-      push @syms, $1 if /(^\w+)/;
-   }
-   print "/* DO NOT EDIT, automatically generated by update_ev_wrap */\n",
-         "#ifndef EV_WRAP_H\n",
-         "#define EV_WRAP_H\n",
-         (map "#define $_ ((loop)->$_)\n", sort @syms),
-         "#else\n",
-         "#undef EV_WRAP_H\n",
-         (map "#undef $_\n", sort @syms),
-         "#endif\n";
-' >ev_wrap.h
diff --git a/libev/update_symbols b/libev/update_symbols
deleted file mode 100755
index a1a1cb3..0000000
--- a/libev/update_symbols
+++ /dev/null
@@ -1,7 +0,0 @@
-#!/bin/sh
-
-make ev.o event.o || exit
-
-nm ev.o           | perl -ne 'print "$1\n" if /\S+ [A-Z] (\S+)/' > Symbols.ev
-nm event.o        | perl -ne 'print "$1\n" if /\S+ [A-Z] (\S+)/' > Symbols.event
-
-- 
2.25.1

